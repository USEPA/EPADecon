'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Vue = require('vue');
var tty = require('tty');
var util = require('util');
var os = require('os');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Vue__default = /*#__PURE__*/_interopDefaultLegacy(Vue);
var tty__default = /*#__PURE__*/_interopDefaultLegacy(tty);
var util__default = /*#__PURE__*/_interopDefaultLegacy(util);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}
var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

var tslib_es6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    __extends: __extends,
    get __assign () { return __assign; },
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __metadata: __metadata,
    __awaiter: __awaiter,
    __generator: __generator,
    __createBinding: __createBinding,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays,
    __spreadArray: __spreadArray,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault,
    __classPrivateFieldGet: __classPrivateFieldGet,
    __classPrivateFieldSet: __classPrivateFieldSet
});

/*!
 * Chart.js v3.7.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
const requestAnimFrame = (function() {
  if (typeof window === 'undefined') {
    return function(callback) {
      return callback();
    };
  }
  return window.requestAnimationFrame;
}());
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce$1(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
const _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
const _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
const _textX = (align, left, right, rtl) => {
  const check = rtl ? 'left' : 'right';
  return align === check ? right : align === 'center' ? (left + right) / 2 : left;
};

function noop$1() {}
const uid = (function() {
  let id = 0;
  return function() {
    return id++;
  };
}());
function isNullOrUndef(value) {
  return value === null || typeof value === 'undefined';
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === '[object Object]';
}
const isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === 'undefined' ? defaultValue : value;
}
const toPercentage = (value, dimension) =>
  typeof value === 'string' && value.endsWith('%') ?
    parseFloat(value) / 100
    : value / dimension;
const toDimension = (value, dimension) =>
  typeof value === 'string' && value.endsWith('%') ?
    parseFloat(value) / 100 * dimension
    : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === 'function') {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source = sources[i];
    if (!isObject(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, source, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {merger: _mergerIf});
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
const emptyString = '';
const dot = '.';
function indexOfDotOrLength(key, start) {
  const idx = key.indexOf(dot, start);
  return idx === -1 ? key.length : idx;
}
function resolveObjectKey(obj, key) {
  if (key === emptyString) {
    return obj;
  }
  let pos = 0;
  let idx = indexOfDotOrLength(key, pos);
  while (obj && idx > pos) {
    obj = obj[key.substr(pos, idx - pos)];
    pos = idx + 1;
    idx = indexOfDotOrLength(key, pos);
  }
  return obj;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value) => typeof value !== 'undefined';
const isFunction = (value) => typeof value === 'function';
const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
}

const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < (-0.5 * PI)) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || (sameAngleIsFullCircle && s === e)
    || (angleToStart > angleToEnd && startToAngle < endToAngle);
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}

const atEdge = (t) => t === 0 || t === 1;
const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
const effects = {
  linear: t => t,
  easeInQuad: t => t * t,
  easeOutQuad: t => -t * (t - 2),
  easeInOutQuad: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t
    : -0.5 * ((--t) * (t - 2) - 1),
  easeInCubic: t => t * t * t,
  easeOutCubic: t => (t -= 1) * t * t + 1,
  easeInOutCubic: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t
    : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: t => t * t * t * t,
  easeOutQuart: t => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t * t
    : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: t => t * t * t * t * t,
  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t * t * t
    : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: t => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: t => Math.sin(t * HALF_PI),
  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: t => atEdge(t) ? t : t < 0.5
    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))
    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: t => ((t /= 0.5) < 1)
    ? -0.5 * (Math.sqrt(1 - t * t) - 1)
    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t :
      t < 0.5
        ? 0.5 * elasticIn(t * 2, s, p)
        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
  },
  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < (1 / d)) {
      return m * t * t;
    }
    if (t < (2 / d)) {
      return m * (t -= (1.5 / d)) * t + 0.75;
    }
    if (t < (2.5 / d)) {
      return m * (t -= (2.25 / d)) * t + 0.9375;
    }
    return m * (t -= (2.625 / d)) * t + 0.984375;
  },
  easeInOutBounce: t => (t < 0.5)
    ? effects.easeInBounce(t * 2) * 0.5
    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,
};

/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */
const map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
const hex$1 = '0123456789ABCDEF';
const h1 = (b) => hex$1[b & 0xF];
const h2 = (b) => hex$1[(b & 0xF0) >> 4] + hex$1[b & 0xF];
const eq = (b) => (((b & 0xF0) >> 4) === (b & 0xF));
function isShort(v) {
	return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
}
function hexParse(str) {
	var len = str.length;
	var ret;
	if (str[0] === '#') {
		if (len === 4 || len === 5) {
			ret = {
				r: 255 & map$1[str[1]] * 17,
				g: 255 & map$1[str[2]] * 17,
				b: 255 & map$1[str[3]] * 17,
				a: len === 5 ? map$1[str[4]] * 17 : 255
			};
		} else if (len === 7 || len === 9) {
			ret = {
				r: map$1[str[1]] << 4 | map$1[str[2]],
				g: map$1[str[3]] << 4 | map$1[str[4]],
				b: map$1[str[5]] << 4 | map$1[str[6]],
				a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255
			};
		}
	}
	return ret;
}
function hexString(v) {
	var f = isShort(v) ? h1 : h2;
	return v
		? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '')
		: v;
}
function round(v) {
	return v + 0.5 | 0;
}
const lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
	return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
	return lim(round(v * 255), 0, 255);
}
function b2n(v) {
	return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
	return lim(round(v * 100), 0, 100);
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
	const m = RGB_RE.exec(str);
	let a = 255;
	let r, g, b;
	if (!m) {
		return;
	}
	if (m[7] !== r) {
		const v = +m[7];
		a = 255 & (m[8] ? p2b(v) : v * 255);
	}
	r = +m[1];
	g = +m[3];
	b = +m[5];
	r = 255 & (m[2] ? p2b(r) : r);
	g = 255 & (m[4] ? p2b(g) : g);
	b = 255 & (m[6] ? p2b(b) : b);
	return {
		r: r,
		g: g,
		b: b,
		a: a
	};
}
function rgbString(v) {
	return v && (
		v.a < 255
			? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
			: `rgb(${v.r}, ${v.g}, ${v.b})`
	);
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
	const a = s * Math.min(l, 1 - l);
	const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
	return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
	const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
	return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
	const rgb = hsl2rgbn(h, 1, 0.5);
	let i;
	if (w + b > 1) {
		i = 1 / (w + b);
		w *= i;
		b *= i;
	}
	for (i = 0; i < 3; i++) {
		rgb[i] *= 1 - w - b;
		rgb[i] += w;
	}
	return rgb;
}
function rgb2hsl(v) {
	const range = 255;
	const r = v.r / range;
	const g = v.g / range;
	const b = v.b / range;
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l = (max + min) / 2;
	let h, s, d;
	if (max !== min) {
		d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		h = max === r
			? ((g - b) / d) + (g < b ? 6 : 0)
			: max === g
				? (b - r) / d + 2
				: (r - g) / d + 4;
		h = h * 60 + 0.5;
	}
	return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
	return (
		Array.isArray(a)
			? f(a[0], a[1], a[2])
			: f(a, b, c)
	).map(n2b);
}
function hsl2rgb$1(h, s, l) {
	return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
	return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
	return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
	return (h % 360 + 360) % 360;
}
function hueParse(str) {
	const m = HUE_RE.exec(str);
	let a = 255;
	let v;
	if (!m) {
		return;
	}
	if (m[5] !== v) {
		a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
	}
	const h = hue(+m[2]);
	const p1 = +m[3] / 100;
	const p2 = +m[4] / 100;
	if (m[1] === 'hwb') {
		v = hwb2rgb(h, p1, p2);
	} else if (m[1] === 'hsv') {
		v = hsv2rgb(h, p1, p2);
	} else {
		v = hsl2rgb$1(h, p1, p2);
	}
	return {
		r: v[0],
		g: v[1],
		b: v[2],
		a: a
	};
}
function rotate(v, deg) {
	var h = rgb2hsl(v);
	h[0] = hue(h[0] + deg);
	h = hsl2rgb$1(h);
	v.r = h[0];
	v.g = h[1];
	v.b = h[2];
}
function hslString(v) {
	if (!v) {
		return;
	}
	const a = rgb2hsl(v);
	const h = a[0];
	const s = n2p(a[1]);
	const l = n2p(a[2]);
	return v.a < 255
		? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
		: `hsl(${h}, ${s}%, ${l}%)`;
}
const map$1$1 = {
	x: 'dark',
	Z: 'light',
	Y: 're',
	X: 'blu',
	W: 'gr',
	V: 'medium',
	U: 'slate',
	A: 'ee',
	T: 'ol',
	S: 'or',
	B: 'ra',
	C: 'lateg',
	D: 'ights',
	R: 'in',
	Q: 'turquois',
	E: 'hi',
	P: 'ro',
	O: 'al',
	N: 'le',
	M: 'de',
	L: 'yello',
	F: 'en',
	K: 'ch',
	G: 'arks',
	H: 'ea',
	I: 'ightg',
	J: 'wh'
};
const names = {
	OiceXe: 'f0f8ff',
	antiquewEte: 'faebd7',
	aqua: 'ffff',
	aquamarRe: '7fffd4',
	azuY: 'f0ffff',
	beige: 'f5f5dc',
	bisque: 'ffe4c4',
	black: '0',
	blanKedOmond: 'ffebcd',
	Xe: 'ff',
	XeviTet: '8a2be2',
	bPwn: 'a52a2a',
	burlywood: 'deb887',
	caMtXe: '5f9ea0',
	KartYuse: '7fff00',
	KocTate: 'd2691e',
	cSO: 'ff7f50',
	cSnflowerXe: '6495ed',
	cSnsilk: 'fff8dc',
	crimson: 'dc143c',
	cyan: 'ffff',
	xXe: '8b',
	xcyan: '8b8b',
	xgTMnPd: 'b8860b',
	xWay: 'a9a9a9',
	xgYF: '6400',
	xgYy: 'a9a9a9',
	xkhaki: 'bdb76b',
	xmagFta: '8b008b',
	xTivegYF: '556b2f',
	xSange: 'ff8c00',
	xScEd: '9932cc',
	xYd: '8b0000',
	xsOmon: 'e9967a',
	xsHgYF: '8fbc8f',
	xUXe: '483d8b',
	xUWay: '2f4f4f',
	xUgYy: '2f4f4f',
	xQe: 'ced1',
	xviTet: '9400d3',
	dAppRk: 'ff1493',
	dApskyXe: 'bfff',
	dimWay: '696969',
	dimgYy: '696969',
	dodgerXe: '1e90ff',
	fiYbrick: 'b22222',
	flSOwEte: 'fffaf0',
	foYstWAn: '228b22',
	fuKsia: 'ff00ff',
	gaRsbSo: 'dcdcdc',
	ghostwEte: 'f8f8ff',
	gTd: 'ffd700',
	gTMnPd: 'daa520',
	Way: '808080',
	gYF: '8000',
	gYFLw: 'adff2f',
	gYy: '808080',
	honeyMw: 'f0fff0',
	hotpRk: 'ff69b4',
	RdianYd: 'cd5c5c',
	Rdigo: '4b0082',
	ivSy: 'fffff0',
	khaki: 'f0e68c',
	lavFMr: 'e6e6fa',
	lavFMrXsh: 'fff0f5',
	lawngYF: '7cfc00',
	NmoncEffon: 'fffacd',
	ZXe: 'add8e6',
	ZcSO: 'f08080',
	Zcyan: 'e0ffff',
	ZgTMnPdLw: 'fafad2',
	ZWay: 'd3d3d3',
	ZgYF: '90ee90',
	ZgYy: 'd3d3d3',
	ZpRk: 'ffb6c1',
	ZsOmon: 'ffa07a',
	ZsHgYF: '20b2aa',
	ZskyXe: '87cefa',
	ZUWay: '778899',
	ZUgYy: '778899',
	ZstAlXe: 'b0c4de',
	ZLw: 'ffffe0',
	lime: 'ff00',
	limegYF: '32cd32',
	lRF: 'faf0e6',
	magFta: 'ff00ff',
	maPon: '800000',
	VaquamarRe: '66cdaa',
	VXe: 'cd',
	VScEd: 'ba55d3',
	VpurpN: '9370db',
	VsHgYF: '3cb371',
	VUXe: '7b68ee',
	VsprRggYF: 'fa9a',
	VQe: '48d1cc',
	VviTetYd: 'c71585',
	midnightXe: '191970',
	mRtcYam: 'f5fffa',
	mistyPse: 'ffe4e1',
	moccasR: 'ffe4b5',
	navajowEte: 'ffdead',
	navy: '80',
	Tdlace: 'fdf5e6',
	Tive: '808000',
	TivedBb: '6b8e23',
	Sange: 'ffa500',
	SangeYd: 'ff4500',
	ScEd: 'da70d6',
	pOegTMnPd: 'eee8aa',
	pOegYF: '98fb98',
	pOeQe: 'afeeee',
	pOeviTetYd: 'db7093',
	papayawEp: 'ffefd5',
	pHKpuff: 'ffdab9',
	peru: 'cd853f',
	pRk: 'ffc0cb',
	plum: 'dda0dd',
	powMrXe: 'b0e0e6',
	purpN: '800080',
	YbeccapurpN: '663399',
	Yd: 'ff0000',
	Psybrown: 'bc8f8f',
	PyOXe: '4169e1',
	saddNbPwn: '8b4513',
	sOmon: 'fa8072',
	sandybPwn: 'f4a460',
	sHgYF: '2e8b57',
	sHshell: 'fff5ee',
	siFna: 'a0522d',
	silver: 'c0c0c0',
	skyXe: '87ceeb',
	UXe: '6a5acd',
	UWay: '708090',
	UgYy: '708090',
	snow: 'fffafa',
	sprRggYF: 'ff7f',
	stAlXe: '4682b4',
	tan: 'd2b48c',
	teO: '8080',
	tEstN: 'd8bfd8',
	tomato: 'ff6347',
	Qe: '40e0d0',
	viTet: 'ee82ee',
	JHt: 'f5deb3',
	wEte: 'ffffff',
	wEtesmoke: 'f5f5f5',
	Lw: 'ffff00',
	LwgYF: '9acd32'
};
function unpack() {
	const unpacked = {};
	const keys = Object.keys(names);
	const tkeys = Object.keys(map$1$1);
	let i, j, k, ok, nk;
	for (i = 0; i < keys.length; i++) {
		ok = nk = keys[i];
		for (j = 0; j < tkeys.length; j++) {
			k = tkeys[j];
			nk = nk.replace(k, map$1$1[k]);
		}
		k = parseInt(names[ok], 16);
		unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
	}
	return unpacked;
}
let names$1;
function nameParse(str) {
	if (!names$1) {
		names$1 = unpack();
		names$1.transparent = [0, 0, 0, 0];
	}
	const a = names$1[str.toLowerCase()];
	return a && {
		r: a[0],
		g: a[1],
		b: a[2],
		a: a.length === 4 ? a[3] : 255
	};
}
function modHSL(v, i, ratio) {
	if (v) {
		let tmp = rgb2hsl(v);
		tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
		tmp = hsl2rgb$1(tmp);
		v.r = tmp[0];
		v.g = tmp[1];
		v.b = tmp[2];
	}
}
function clone(v, proto) {
	return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
	var v = {r: 0, g: 0, b: 0, a: 255};
	if (Array.isArray(input)) {
		if (input.length >= 3) {
			v = {r: input[0], g: input[1], b: input[2], a: 255};
			if (input.length > 3) {
				v.a = n2b(input[3]);
			}
		}
	} else {
		v = clone(input, {r: 0, g: 0, b: 0, a: 1});
		v.a = n2b(v.a);
	}
	return v;
}
function functionParse(str) {
	if (str.charAt(0) === 'r') {
		return rgbParse(str);
	}
	return hueParse(str);
}
class Color$1 {
	constructor(input) {
		if (input instanceof Color$1) {
			return input;
		}
		const type = typeof input;
		let v;
		if (type === 'object') {
			v = fromObject(input);
		} else if (type === 'string') {
			v = hexParse(input) || nameParse(input) || functionParse(input);
		}
		this._rgb = v;
		this._valid = !!v;
	}
	get valid() {
		return this._valid;
	}
	get rgb() {
		var v = clone(this._rgb);
		if (v) {
			v.a = b2n(v.a);
		}
		return v;
	}
	set rgb(obj) {
		this._rgb = fromObject(obj);
	}
	rgbString() {
		return this._valid ? rgbString(this._rgb) : this._rgb;
	}
	hexString() {
		return this._valid ? hexString(this._rgb) : this._rgb;
	}
	hslString() {
		return this._valid ? hslString(this._rgb) : this._rgb;
	}
	mix(color, weight) {
		const me = this;
		if (color) {
			const c1 = me.rgb;
			const c2 = color.rgb;
			let w2;
			const p = weight === w2 ? 0.5 : weight;
			const w = 2 * p - 1;
			const a = c1.a - c2.a;
			const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
			w2 = 1 - w1;
			c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
			c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
			c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
			c1.a = p * c1.a + (1 - p) * c2.a;
			me.rgb = c1;
		}
		return me;
	}
	clone() {
		return new Color$1(this.rgb);
	}
	alpha(a) {
		this._rgb.a = n2b(a);
		return this;
	}
	clearer(ratio) {
		const rgb = this._rgb;
		rgb.a *= 1 - ratio;
		return this;
	}
	greyscale() {
		const rgb = this._rgb;
		const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
		rgb.r = rgb.g = rgb.b = val;
		return this;
	}
	opaquer(ratio) {
		const rgb = this._rgb;
		rgb.a *= 1 + ratio;
		return this;
	}
	negate() {
		const v = this._rgb;
		v.r = 255 - v.r;
		v.g = 255 - v.g;
		v.b = 255 - v.b;
		return this;
	}
	lighten(ratio) {
		modHSL(this._rgb, 2, ratio);
		return this;
	}
	darken(ratio) {
		modHSL(this._rgb, 2, -ratio);
		return this;
	}
	saturate(ratio) {
		modHSL(this._rgb, 1, ratio);
		return this;
	}
	desaturate(ratio) {
		modHSL(this._rgb, 1, -ratio);
		return this;
	}
	rotate(deg) {
		rotate(this._rgb, deg);
		return this;
	}
}
function index_esm(input) {
	return new Color$1(input);
}

const isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;
function color$1(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value)
    ? value
    : index_esm(value).saturate(0.5).darken(0.1).hexString();
}

const overrides = Object.create(null);
const descriptors = Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split('.');
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = Object.create(null));
  }
  return node;
}
function set$2(root, scope, values) {
  if (typeof scope === 'string') {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ''), scope);
}
class Defaults {
  constructor(_descriptors) {
    this.animation = undefined;
    this.backgroundColor = 'rgba(0,0,0,0.1)';
    this.borderColor = 'rgba(0,0,0,0.1)';
    this.color = '#666';
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      'mousemove',
      'mouseout',
      'click',
      'touchstart',
      'touchmove'
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: 'normal',
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = 'x';
    this.interaction = {
      mode: 'nearest',
      intersect: true
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = undefined;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors);
  }
  set(scope, values) {
    return set$2(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set$2(descriptors, scope, values);
  }
  override(scope, values) {
    return set$2(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = '_' + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
}
var defaults$1 = new Defaults({
  _scriptable: (name) => !name.startsWith('on'),
  _indexable: (name) => name !== 'events',
  hover: {
    _fallback: 'interaction'
  },
  interaction: {
    _scriptable: false,
    _indexable: false,
  }
});

function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + ' ' : '')
		+ (font.weight ? font.weight + ' ' : '')
		+ font.size + 'px '
		+ font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== undefined && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext('2d');
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  let type, xOffset, yOffset, size, cornerRadius;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === 'object') {
    type = style.toString();
    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
  default:
    ctx.arc(x, y, radius, 0, TAU);
    ctx.closePath();
    break;
  case 'triangle':
    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    rad += TWO_THIRDS_PI;
    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    rad += TWO_THIRDS_PI;
    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    ctx.closePath();
    break;
  case 'rectRounded':
    cornerRadius = radius * 0.516;
    size = radius - cornerRadius;
    xOffset = Math.cos(rad + QUARTER_PI) * size;
    yOffset = Math.sin(rad + QUARTER_PI) * size;
    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
    ctx.closePath();
    break;
  case 'rect':
    if (!rotation) {
      size = Math.SQRT1_2 * radius;
      ctx.rect(x - size, y - size, 2 * size, 2 * size);
      break;
    }
    rad += QUARTER_PI;
  case 'rectRot':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + yOffset, y - xOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    ctx.closePath();
    break;
  case 'crossRot':
    rad += QUARTER_PI;
  case 'cross':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    break;
  case 'star':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    rad += QUARTER_PI;
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    break;
  case 'line':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    break;
  case 'dash':
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
    break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&
		point.y > area.top - margin && point.y < area.bottom + margin);
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === 'middle') {
    const midpoint = (previous.x + target.x) / 2.0;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === 'after' !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(
    flip ? previous.cp1x : previous.cp2x,
    flip ? previous.cp1y : previous.cp2y,
    flip ? target.cp2x : target.cp1x,
    flip ? target.cp2y : target.cp1y,
    target.x,
    target.y);
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const {x, y, w, h, radius} = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}

const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ('' + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === 'normal') {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
  case 'px':
    return value;
  case '%':
    value /= 100;
    break;
  }
  return size * value;
}
const numberOrZero = v => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value)
    ? objProps
      ? prop => valueOrDefault(value[prop], value[props[prop]])
      : prop => value[prop]
    : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults$1.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === 'string') {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !('' + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = '';
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ''
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === undefined) {
      continue;
    }
    if (context !== undefined && typeof value === 'function') {
      value = value(context);
      cacheable = false;
    }
    if (index !== undefined && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== undefined) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const {min, max} = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}

function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = (lo + hi) >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {lo, hi};
}
const _lookupByKey = (table, key, value) =>
  _lookup(table, value, index => table[index][key] < value);
const _rlookupByKey = (table, key, value) =>
  _lookup(table, value, index => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length
    ? values.slice(start, end)
    : values;
}
const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, '_chartjs', {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = '_onData' + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === 'function') {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set = new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set.add(items[i]);
  }
  if (set.size === ilen) {
    return items;
  }
  return Array.from(set);
}

function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve('_fallback', scopes);
  }
  const cache = {
    [Symbol.toStringTag]: 'Object',
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop,
        () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop,
        () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys
        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined
        : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {
  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&
  (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const {_proxy, _context, _subProxy, _stack} = target;
  if (_stack.has(prop)) {
    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter(s => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent) => key === true ? parent
  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
function addScopes(set, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set = new Set();
  set.add(value);
  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set), [''], rootScopes, fallback,
    () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value)
        ? createSubResolver(scopes, proxy, prop, value)
        : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set = new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {
      set.add(key);
    }
  }
  return Array.from(set);
}

const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i]
      : !pointAfter ? deltaK[i - 1]
      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0
      : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === 'monotone') {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(
        prev,
        point,
        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],
        options.tension
      );
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}

function _isDomSupported() {
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === '[object ShadowRoot]') {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === 'string') {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf('%') !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
const getComputedStyle = (element) => window.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
const positions = ['top', 'right', 'bottom', 'left'];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? '-' + suffix : '';
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(evt, canvas) {
  const e = evt.native || evt;
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const {offsetX, offsetY} = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {x, y, box};
}
function getRelativePosition$1(evt, chart) {
  const {canvas, currentDevicePixelRatio} = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === 'border-box';
  const paddings = getPositionedStyle(style, 'padding');
  const borders = getPositionedStyle(style, 'border', 'width');
  const {x, y, box} = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let {width, height} = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === undefined || height === undefined) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
      const containerPadding = getPositionedStyle(containerStyle, 'padding');
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
const round1 = v => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, 'margin');
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let {width, height} = containerSize;
  if (style.boxSizing === 'content-box') {
    const borders = getPositionedStyle(style, 'border', 'width');
    const paddings = getPositionedStyle(style, 'padding');
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio
      || canvas.height !== deviceHeight
      || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
const supportsEventListenerOptions = (function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener('test', null, options);
    window.removeEventListener('test', null, options);
  } catch (e) {
  }
  return passiveSupported;
}());
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : undefined;
}

function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y
    : mode === 'after' ? t < 1 ? p1.y : p2.y
    : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {x: p1.cp2x, y: p1.cp2y};
  const cp2 = {x: p2.cp1x, y: p2.cp1y};
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}

const intlCache = new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}

const getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === 'center') {
        return align;
      }
      return align === 'right' ? 'left' : 'right';
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    },
  };
};
const getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    },
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === 'ltr' || direction === 'rtl') {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue('direction'),
      style.getPropertyPriority('direction'),
    ];
    style.setProperty('direction', direction, 'important');
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== undefined) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty('direction', original[0], original[1]);
  }
}

function propertyFn(property) {
  if (property === 'angle') {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle,
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: x => x
  };
}
function normalizeSegment({start, end, count, loop, style}) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const {property, start: startBound, end: endBound} = bounds;
  const {between, normalize} = propertyFn(property);
  const count = points.length;
  let {start, end, loop} = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {start, end, loop, style: segment.style};
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const {property, start: startBound, end: endBound} = bounds;
  const count = points.length;
  const {compare, between, normalize} = propertyFn(property);
  const {start, end, loop, style} = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({start: subStart, end, loop, count, style}));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {start, end};
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({start: start % count, end: (end - 1) % count, loop});
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({start: start % count, end: last % count, loop});
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({start: s % count, end: e % count, loop: l, style: st});
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: 'segment',
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}

/*!
 * Chart.js v3.7.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */

class Animator {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = undefined;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach(fn => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw) {
        chart.draw();
        this._notify(chart, anims, date, 'progress');
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, 'complete');
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), 'complete');
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = new Animator();

const transparent = 'transparent';
const interpolators = {
  boolean(from, to, factor) {
    return factor > 0.5 ? to : from;
  },
  color(from, to, factor) {
    const c0 = color$1(from || transparent);
    const c1 = c0.valid && color$1(to || transparent);
    return c1 && c1.valid
      ? c1.mix(c0, factor).hexString()
      : to;
  },
  number(from, to, factor) {
    return from + (to - from) * factor;
  }
};
class Animation {
  constructor(cfg, target, prop, to) {
    const currentValue = target[prop];
    to = resolve([cfg.to, to, currentValue, cfg.from]);
    const from = resolve([cfg.from, currentValue, to]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from;
    this._to = to;
    this._promises = undefined;
  }
  active() {
    return this._active;
  }
  update(cfg, to, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from = this._from;
    const loop = this._loop;
    const to = this._to;
    let factor;
    this._active = from !== to && (loop || (elapsed < duration));
    if (!this._active) {
      this._target[prop] = to;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from;
      return;
    }
    factor = (elapsed / duration) % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from, to, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({res, rej});
    });
  }
  _notify(resolved) {
    const method = resolved ? 'res' : 'rej';
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
}

const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];
const colors$1 = ['color', 'borderColor', 'backgroundColor'];
defaults$1.set('animation', {
  delay: undefined,
  duration: 1000,
  easing: 'easeOutQuart',
  fn: undefined,
  from: undefined,
  loop: undefined,
  to: undefined,
  type: undefined,
});
const animationOptions = Object.keys(defaults$1.animation);
defaults$1.describe('animation', {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',
});
defaults$1.set('animations', {
  colors: {
    type: 'color',
    properties: colors$1
  },
  numbers: {
    type: 'number',
    properties: numbers
  },
});
defaults$1.describe('animations', {
  _fallback: 'animation',
});
defaults$1.set('transitions', {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: 'transparent'
      },
      visible: {
        type: 'boolean',
        duration: 0
      },
    }
  },
  hide: {
    animations: {
      colors: {
        to: 'transparent'
      },
      visible: {
        type: 'boolean',
        easing: 'linear',
        fn: v => v | 0
      },
    }
  }
});
class Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach(key => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === '$') {
        continue;
      }
      if (prop === 'options') {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});
  }
  return options;
}

function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === undefined ? allowedOverflow : 0;
  const max = opts.max === undefined ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === 'single';
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || (stacked === undefined && meta.stack !== undefined);
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const {min, max, minDefined, maxDefined} = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if ((positive && value > 0) || (!positive && value < 0)) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const {chart, _cachedMeta: meta} = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const {iScale, vScale, index: datasetIndex} = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const {[iAxis]: index, [vAxis]: value} = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent,
    {
      active: false,
      dataset: undefined,
      datasetIndex: index,
      index,
      mode: 'default',
      type: 'dataset'
    }
  );
}
function createDataContext(parent, index, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: undefined,
    raw: undefined,
    element,
    index,
    mode: 'default',
    type: 'data'
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
const isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked
  && {keys: getSortedDatasetIndices(chart, true), values: null};
class DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = undefined;
    this._parsing = false;
    this._data = undefined;
    this._objectData = undefined;
    this._sharedOptions = undefined;
    this._drawStart = undefined;
    this._drawCount = undefined;
    this.enableOptionSharing = false;
    this.$context = undefined;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale
      ? meta.vScale
      : meta.iScale;
  }
  reset() {
    this._update('reset');
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const {_cachedMeta: meta, _data: data} = this;
    const {iScale, _stacked} = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const {iScale, vScale} = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const {xScale, yScale} = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const {xScale, yScale} = meta;
    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, {mode});
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};
    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || 'default');
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {}
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || (elements.length - start);
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? 'active' : 'default';
    return index === undefined && this._cachedMeta.dataset
      ? this.resolveDatasetElementOptions(mode)
      : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context ||
        (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context ||
        (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = 'default', index) {
    const active = mode === 'active';
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + '-' + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names = Object.keys(defaults$1.elements[elementType]);
    const context = () => this.getContext(index, active);
    const values = config.resolveNamedOptions(scopes, names, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: (!active && this.getSharedOptions(options)) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, undefined, 'active', false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, undefined, 'active', true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, 'reset');
    }
  }
  updateElements(element, start, count, mode) {}
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(['_insertElements', this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(['_removeElements', 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(['_removeElements', start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(['_insertElements', start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(['_insertElements', 0, arguments.length]);
  }
}
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;

function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = undefined;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - (size / 2)
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = 'left';
    end = 'right';
  } else {
    reverse = properties.base < properties.y;
    start = 'bottom';
    end = 'top';
  }
  if (reverse) {
    top = 'end';
    bottom = 'start';
  } else {
    top = 'start';
    bottom = 'end';
  }
  return {start, end, reverse, top, bottom};
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  const {start, end, reverse, top, bottom} = borderProps(properties);
  if (edge === 'middle' && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === 'start' ? start : v === 'end' ? end : v;
}
function setInflateAmount(properties, {inflateAmount}, ratio) {
  properties.inflateAmount = inflateAmount === 'auto'
    ? ratio === 1 ? 0.33 : 0
    : inflateAmount;
}
class BarController extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const {iScale, vScale} = meta;
    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const {iScale, vScale} = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom)
      ? '[' + custom.start + ', ' + custom.end + ']'
      : '' + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === 'reset';
    const {index, _cachedMeta: {vScale}} = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const metasets = iScale.getMatchingVisibleMetas(this._type);
    const stacked = iScale.options.stacked;
    const ilen = metasets.length;
    const stacks = [];
    let i, item;
    for (i = 0; i < ilen; ++i) {
      item = metasets[i];
      if (!item.controller.options.grouped) {
        continue;
      }
      if (typeof dataIndex !== 'undefined') {
        const val = item.controller.getParsed(dataIndex)[
          item.controller._cachedMeta.vScale.axis
        ];
        if (isNullOrUndef(val) || isNaN(val)) {
          continue;
        }
      }
      if (stacked === false || stacks.indexOf(item.stack) === -1 ||
				(stacked === undefined && item.stack === undefined)) {
        stacks.push(item.stack);
      }
      if (item.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(undefined);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(undefined, index).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = (name !== undefined)
      ? stacks.indexOf(name)
      : -1;
    return (index === -1)
      ? stacks.length - 1
      : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === 'flex'
        ? computeFlexCategoryTraits(index, ruler, options, stackCount)
        : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
}
BarController.id = 'bar';
BarController.defaults = {
  datasetElementType: false,
  dataElementType: 'bar',
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'base', 'width', 'height']
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: 'category',
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: 'linear',
      beginAtZero: true,
    }
  }
};

class BubbleController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const {xScale, yScale} = meta;
    const parsed = this.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta.label,
      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {iScale, vScale} = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  resolveDataElementOptions(index, mode) {
    const parsed = this.getParsed(index);
    let values = super.resolveDataElementOptions(index, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {$shared: false});
    }
    const radius = values.radius;
    if (mode !== 'active') {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
}
BubbleController.id = 'bubble';
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: 'point',
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'borderWidth', 'radius']
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: 'linear'
    },
    y: {
      type: 'linear'
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return '';
        }
      }
    }
  }
};

function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {ratioX, ratioY, offsetX, offsetY};
}
class DoughnutController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.offsetX = undefined;
    this.offsetY = undefined;
  }
  linkScales() {}
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i) => +data[i];
      if (isObject(data[start])) {
        const {key = 'value'} = this._parsing;
        getter = (i) => +resolveObjectKey(data[i], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min,
    };
  }
  update(mode) {
    const chart = this.chart;
    const {chartArea} = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const {circumference, rotation} = this._getRotationExtents();
    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === 'reset';
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || '',
      value,
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== 'inner') {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
DoughnutController.id = 'doughnut';
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: 'arc',
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: 'number',
      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']
    },
  },
  cutout: '50%',
  rotation: 0,
  circumference: 360,
  radius: '100%',
  spacing: 0,
  indexAxis: 'r',
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== 'spacing',
  _indexable: (name) => name !== 'spacing',
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const {labels: {pointStyle}} = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle: pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ': ' + tooltipItem.formattedValue;
          if (isArray(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};

class LineController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const {dataset: line, data: points = [], _dataset} = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, undefined, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const {spanGaps, segment} = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && (parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
}
LineController.id = 'line';
LineController.defaults = {
  datasetElementType: 'line',
  dataElementType: 'point',
  showLine: true,
  spanGaps: false,
};
LineController.overrides = {
  scales: {
    _index_: {
      type: 'category',
    },
    _value_: {
      type: 'linear',
    },
  }
};
function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const {iScale, _parsed} = meta;
    const axis = iScale.axis;
    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(
        _lookupByKey(_parsed, iScale.axis, min).lo,
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),
      0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        _lookupByKey(_parsed, iScale.axis, max).hi + 1,
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1),
      start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {start, count};
}
function scaleRangesChanged(meta) {
  const {xScale, yScale, _scaleRanges} = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min
		|| _scaleRanges.xmax !== xScale.max
		|| _scaleRanges.ymin !== yScale.min
		|| _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}

class PolarAreaController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = undefined;
    this.outerRadius = undefined;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index].r, chart.options.locale);
    return {
      label: labels[index] || '',
      value,
    };
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - (radiusLength * this.index);
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === 'reset';
    const chart = this.chart;
    const dataset = this.getDataset();
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const dataset = this.getDataset();
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index) => {
      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index, mode, defaultAngle) {
    return this.chart.getDataVisibility(index)
      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)
      : 0;
  }
}
PolarAreaController.id = 'polarArea';
PolarAreaController.defaults = {
  dataElementType: 'arc',
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']
    },
  },
  indexAxis: 'r',
  startAngle: 0,
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const {labels: {pointStyle}} = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle: pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: 'radialLinear',
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};

class PieController extends DoughnutController {
}
PieController.id = 'pie';
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: '100%'
};

class RadarController extends DatasetController {
  getLabelAndValue(index) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: vScale.getLabels()[index],
      value: '' + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== 'resize') {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, undefined, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const dataset = this.getDataset();
    const scale = this._cachedMeta.rScale;
    const reset = mode === 'reset';
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
}
RadarController.id = 'radar';
RadarController.defaults = {
  datasetElementType: 'line',
  dataElementType: 'point',
  indexAxis: 'r',
  showLine: true,
  elements: {
    line: {
      fill: 'start'
    }
  },
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: 'radialLinear',
    }
  }
};

class ScatterController extends LineController {
}
ScatterController.id = 'scatter';
ScatterController.defaults = {
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: 'point'
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(item) {
          return '(' + item.label + ', ' + item.formattedValue + ')';
        }
      }
    }
  },
  scales: {
    x: {
      type: 'linear'
    },
    y: {
      type: 'linear'
    }
  }
};

var controllers = /*#__PURE__*/Object.freeze({
__proto__: null,
BarController: BarController,
BubbleController: BubbleController,
DoughnutController: DoughnutController,
LineController: LineController,
PolarAreaController: PolarAreaController,
PieController: PieController,
RadarController: RadarController,
ScatterController: ScatterController
});

function abstract() {
  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
}
class DateAdapter {
  constructor(options) {
    this.options = options || {};
  }
  formats() {
    return abstract();
  }
  parse(value, format) {
    return abstract();
  }
  format(timestamp, format) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
}
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};

function getRelativePosition(e, chart) {
  if ('native' in e) {
    return {
      x: e.x,
      y: e.y
    };
  }
  return getRelativePosition$1(e, chart);
}
function evaluateAllVisibleItems(chart, handler) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  let index, data, element;
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    ({index, data} = metasets[i]);
    for (let j = 0, jlen = data.length; j < jlen; ++j) {
      element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function binarySearch(metaset, axis, value, intersect) {
  const {controller, data, _sorted} = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === 'function' && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {lo: start.lo, hi: end.hi};
      }
    }
  }
  return {lo: 0, hi: data.length - 1};
}
function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const {index, data} = metasets[i];
    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf('x') !== -1;
  const useY = axis.indexOf('y') !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition) {
  const items = [];
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({element, datasetIndex, index});
    }
  };
  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index) {
    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);
    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({element, datasetIndex, index});
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index) {
    const inRange = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = _isPointInArea(center, chart.chartArea, chart._minPadding);
    if (!pointInArea && !inRange) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{element, datasetIndex, index}];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({element, datasetIndex, index});
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return [];
  }
  return axis === 'r' && !intersect
    ? getNearestRadialItems(chart, position, axis, useFinalPosition)
    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition);
}
function getAxisItems(chart, e, options, useFinalPosition) {
  const position = getRelativePosition(e, chart);
  const items = [];
  const axis = options.axis;
  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
  let intersectsItem = false;
  evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({element, datasetIndex, index});
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      intersectsItem = true;
    }
  });
  if (options.intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'x';
      const items = options.intersect
        ? getIntersectItems(chart, position, axis, useFinalPosition)
        : getNearestItems(chart, position, axis, false, useFinalPosition);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({element, datasetIndex: meta.index, index});
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      let items = options.intersect
        ? getIntersectItems(chart, position, axis, useFinalPosition) :
        getNearestItems(chart, position, axis, false, useFinalPosition);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({element: data[i], datasetIndex, index: i});
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      return getIntersectItems(chart, position, axis, useFinalPosition);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);
    },
    x(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, {axis: 'x', intersect: options.intersect}, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, {axis: 'y', intersect: options.intersect}, useFinalPosition);
    }
  }
};

const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];
function filterByPosition(array, position) {
  return array.filter(v => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ?
      v0.index - v1.index :
      v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({position: pos, options: {stack, stackWeight = 1}} = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && (pos + stack),
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts) {
  const stacks = {};
  for (const wrap of layouts) {
    const {stack, pos, stackWeight} = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts, params) {
  const stacks = buildStacks(layouts);
  const {vBoxMaxWidth, hBoxMaxHeight} = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts.length; i < ilen; ++i) {
    layout = layouts[i];
    const {fullSize} = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, 'chartArea'),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const {pos, box} = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {size: 0, count: 1};
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal
    ? {same: widthChanged, other: heightChanged}
    : {same: heightChanged, other: widthChanged};
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos('top');
  chartArea.x += updatePos('left');
  updatePos('right');
  updatePos('bottom');
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions) {
    const margin = {left: 0, top: 0, right: 0, bottom: 0};
    positions.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal
    ? marginForPositions(['left', 'right'])
    : marginForPositions(['top', 'bottom']);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(
      layout.width || chartArea.w,
      layout.height || chartArea.h,
      getMargins(layout.horizontal, chartArea)
    );
    const {same, other} = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let {x, y} = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};
    const weight = (layout.stackWeight / stack.weight) || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
defaults$1.set('layout', {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || 'top';
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, box => {
      if (typeof box.beforeLayout === 'function') {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>
      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w,
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});
    });
  }
};

class BasePlatform {
  acquireContext(canvas, aspectRatio) {}
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {}
  removeEventListener(chart, type, listener) {}
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
}

class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext('2d') || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
}

const EXPANDO_KEY$1 = '$chartjs';
const EVENT_TYPES = {
  touchstart: 'mousedown',
  touchmove: 'mousemove',
  touchend: 'mouseup',
  pointerenter: 'mouseenter',
  pointerdown: 'mousedown',
  pointermove: 'mousemove',
  pointerup: 'mouseup',
  pointerleave: 'mouseout',
  pointerout: 'mouseout'
};
const isNullOrEmpty = value => value === null || value === '';
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute('height');
  const renderWidth = canvas.getAttribute('width');
  canvas[EXPANDO_KEY$1] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || 'block';
  style.boxSizing = style.boxSizing || 'border-box';
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, 'width');
    if (displayWidth !== undefined) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === '') {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, 'height');
      if (displayHeight !== undefined) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
const eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const {x, y} = getRelativePosition$1(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== undefined ? x : null,
    y: y !== undefined ? y : null,
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver(entries => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {childList: true, subtree: true});
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver(entries => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {childList: true, subtree: true});
  return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener('resize', onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener('resize', onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver(entries => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === 'resize') {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
class DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext('2d');
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY$1]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY$1].initial;
    ['height', 'width'].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY$1];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = undefined;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
}

function _detectPlatform(canvas) {
  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {
    return BasicPlatform;
  }
  return DomPlatform;
}

class Element {
  constructor() {
    this.x = undefined;
    this.y = undefined;
    this.active = false;
    this.options = undefined;
    this.$animations = undefined;
  }
  tooltipPosition(useFinalPosition) {
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return {x, y};
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach(prop => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
}
Element.defaults = {};
Element.defaultRoutes = undefined;

const formatters = {
  values(value) {
    return isArray(value) ? value : '' + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e+15) {
        notation = 'scientific';
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }
    const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return '';
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {formatters};

defaults$1.set('scale', {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: 'ticks',
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0.0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: '',
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: '',
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: 'center',
    crossAlign: 'near',
    showLabelBackdrop: false,
    backdropColor: 'rgba(255, 255, 255, 0.75)',
    backdropPadding: 2,
  }
});
defaults$1.route('scale.ticks', 'color', '', 'color');
defaults$1.route('scale.grid', 'color', '', 'borderColor');
defaults$1.route('scale.grid', 'borderColor', '', 'borderColor');
defaults$1.route('scale.title', 'color', '', 'color');
defaults$1.describe('scale', {
  _fallback: false,
  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',
});
defaults$1.describe('scales', {
  _fallback: 'scale',
});
defaults$1.describe('scale.ticks', {
  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',
  _indexable: (name) => name !== 'backdropPadding',
});

function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}

const reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;
const offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
    }
    lineValue += validIndex < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return (lines * font.lineHeight) + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: 'scale'
  });
}
function createTickContext(parent, index, tick) {
  return createContext(parent, {
    tick,
    index,
    type: 'tick'
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const {top, left, bottom, right, chart} = scale;
  const {chartArea, scales} = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === 'center') {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === 'center') {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === 'left' ? -HALF_PI : HALF_PI;
  }
  return {titleX, titleY, maxWidth, rotation};
}
class Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = undefined;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = undefined;
    this.maxHeight = undefined;
    this.paddingTop = undefined;
    this.paddingBottom = undefined;
    this.paddingLeft = undefined;
    this.paddingRight = undefined;
    this.axis = undefined;
    this.labelRotation = undefined;
    this.min = undefined;
    this.max = undefined;
    this._range = undefined;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = undefined;
    this._endPixel = undefined;
    this._reversePixels = false;
    this._userMax = undefined;
    this._userMin = undefined;
    this._suggestedMax = undefined;
    this._suggestedMin = undefined;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = undefined;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let {min, max, minDefined, maxDefined} = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {min, max};
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const {beginAtZero, grace, ticks: tickOpts} = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal()
      ? this.width + margins.left + margins.right
      : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks('beforeDataLimits');
  }
  determineDataLimits() {}
  afterDataLimits() {
    this._callHooks('afterDataLimits');
  }
  beforeBuildTicks() {
    this._callHooks('beforeBuildTicks');
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks('afterBuildTicks');
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid)
				- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(
        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))
      ));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const {first, last, widest, highest} = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const {ticks: {align, padding}, position} = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== 'top' && this.axis === 'x';
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === 'start') {
        paddingRight = last.width;
      } else if (align === 'end') {
        paddingLeft = first.width;
      } else {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === 'start') {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === 'end') {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const {axis, position} = this.options;
    return position === 'top' || position === 'bottom' || axis === 'x';
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const {ctx, _longestTextCache: caches} = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights,
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {}
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const {min, max} = this;
    return min < 0 && max < 0 ? max :
      min > 0 && max > 0 ? min :
      0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context ||
				(tick.$context = createTickContext(this.getContext(), index, tick));
    }
    return this.$context ||
			(this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal()
      ? h * cos > w * sin ? w / cos : h / sin
      : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== 'auto') {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const {grid, position} = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === 'top') {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === 'bottom') {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === 'left') {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === 'right') {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === 'x') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === 'y') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(this.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = grid.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === undefined) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset,
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const {position, ticks: optionTicks} = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const {align, crossAlign, padding, mirror} = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = 'middle';
    if (position === 'top') {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === 'bottom') {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === 'left') {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === 'right') {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === 'x') {
      if (position === 'center') {
        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === 'y') {
      if (position === 'center') {
        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === 'y') {
      if (align === 'start') {
        textBaseline = 'top';
      } else if (align === 'end') {
        textBaseline = 'bottom';
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      if (isHorizontal) {
        x = pixel;
        if (position === 'top') {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
        case 'middle':
          top -= height / 2;
          break;
        case 'bottom':
          top -= height;
          break;
        }
        switch (textAlign) {
        case 'center':
          left -= width / 2;
          break;
        case 'right':
          left -= width;
          break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor,
        };
      }
      items.push({
        rotation,
        label,
        font,
        color,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign,
        textBaseline,
        translation: [x, y],
        backdrop,
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const {position, ticks} = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === 'top' ? 'left' : 'right';
    }
    let align = 'center';
    if (ticks.align === 'start') {
      align = 'left';
    } else if (ticks.align === 'end') {
      align = 'right';
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const {position, ticks: {crossAlign, mirror, padding}} = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === 'left') {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += (widest / 2);
        } else {
          textAlign = 'right';
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= (widest / 2);
        } else {
          textAlign = 'left';
          x = this.left;
        }
      }
    } else if (position === 'right') {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= (widest / 2);
        } else {
          textAlign = 'left';
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += widest / 2;
        } else {
          textAlign = 'right';
          x = this.right;
        }
      }
    } else {
      textAlign = 'right';
    }
    return {textAlign, x};
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === 'left' || position === 'right') {
      return {top: 0, left: this.left, bottom: chart.height, right: this.right};
    } if (position === 'top' || position === 'bottom') {
      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};
    }
  }
  drawBackground() {
    const {ctx, options: {backgroundColor}, left, top, width, height} = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex(t => t.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine(
            {x: item.x1, y: item.y1},
            {x: item.x2, y: item.y2},
            item
          );
        }
        if (grid.drawTicks) {
          drawLine(
            {x: item.tx1, y: item.ty1},
            {x: item.tx2, y: item.ty2},
            {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            }
          );
        }
      }
    }
  }
  drawBorder() {
    const {chart, ctx, options: {grid}} = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const {ctx, options: {position, title, reverse}} = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === 'bottom' || position === 'center' || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: 'middle',
      translation: [titleX, titleY],
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + 'AxisID';
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
}

class TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + '.' + id;
    if (!id) {
      throw new Error('class does not have id: ' + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults$1.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults$1[scope]) {
      delete defaults$1[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(Object.create(null), [
    parentScope ? defaults$1.get(parentScope) : {},
    defaults$1.get(scope),
    item.defaults
  ]);
  defaults$1.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults$1.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach(property => {
    const propertyParts = property.split('.');
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join('.');
    const parts = routes[property].split('.');
    const targetName = parts.pop();
    const targetScope = parts.join('.');
    defaults$1.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return 'id' in proto && 'defaults' in proto;
}

class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
    this.elements = new TypedRegistry(Element, 'elements');
    this.plugins = new TypedRegistry(Object, 'plugins');
    this.scales = new TypedRegistry(Scale, 'scales');
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each('register', args);
  }
  remove(...args) {
    this._each('unregister', args);
  }
  addControllers(...args) {
    this._each('register', args, this.controllers);
  }
  addElements(...args) {
    this._each('register', args, this.elements);
  }
  addPlugins(...args) {
    this._each('register', args, this.plugins);
  }
  addScales(...args) {
    this._each('register', args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, 'controller');
  }
  getElement(id) {
    return this._get(id, this.elements, 'element');
  }
  getPlugin(id) {
    return this._get(id, this.plugins, 'plugin');
  }
  getScale(id) {
    return this._get(id, this.scales, 'scale');
  }
  removeControllers(...args) {
    this._each('unregister', args, this.controllers);
  }
  removeElements(...args) {
    this._each('unregister', args, this.elements);
  }
  removePlugins(...args) {
    this._each('unregister', args, this.plugins);
  }
  removeScales(...args) {
    this._each('unregister', args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach(arg => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {
        this._exec(method, reg, arg);
      } else {
        each(arg, item => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry, component) {
    const camelMethod = _capitalize(method);
    callback(component['before' + camelMethod], [], component);
    registry[method](component);
    callback(component['after' + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === undefined) {
      throw new Error('"' + id + '" is not a registered ' + type + '.');
    }
    return item;
  }
}
var registry = new Registry();

class PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === 'beforeInit') {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, 'install');
    }
    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors, chart, hook, args);
    if (hook === 'afterDestroy') {
      this._notify(descriptors, chart, 'stop');
      this._notify(this._init, chart, 'uninstall');
    }
    return result;
  }
  _notify(descriptors, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = undefined;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors = this._cache;
    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
    this._notify(diff(descriptors, previousDescriptors), chart, 'start');
  }
}
function allPlugins(config) {
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
    }
  }
  return plugins;
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, plugins, options, all) {
  const result = [];
  const context = chart.getContext();
  for (let i = 0; i < plugins.length; i++) {
    const plugin = plugins[i];
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, plugin, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, plugin, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  return config.createResolver(scopes, context, [''], {scriptable: false, indexable: false, allKeys: true});
}

function getIndexAxis(type, options) {
  const datasetDefaults = defaults$1.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === '_index_') {
    axis = indexAxis;
  } else if (id === '_value_') {
    axis = indexAxis === 'x' ? 'y' : 'x';
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? '_index_' : '_value_';
}
function axisFromPosition(position) {
  if (position === 'top' || position === 'bottom') {
    return 'x';
  }
  if (position === 'left' || position === 'right') {
    return 'y';
  }
}
function determineAxis(id, scaleOptions) {
  if (id === 'x' || id === 'y') {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {scales: {}};
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = Object.create(null);
  const scales = Object.create(null);
  Object.keys(configScales).forEach(id => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach(dataset => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach(defaultID => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;
      scales[id] = scales[id] || Object.create(null);
      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales).forEach(key => {
    const scale = scales[key];
    mergeIf(scale, [defaults$1.scales[scale.type], defaults$1.scale]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
const addIfFound = (set, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== undefined) {
    set.add(opts);
  }
};
class Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType,
      () => [[
        `datasets.${datasetType}`,
        ''
      ]]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`,
      () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`,
        ],
        [
          `datasets.${datasetType}`,
          ''
        ]
      ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`,
      () => [[
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ''
      ]]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`,
      () => [[
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || [],
      ]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const {options, type} = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = new Set();
    keyLists.forEach(keys => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach(key => addIfFound(scopes, mainScope, key));
      }
      keys.forEach(key => addIfFound(scopes, options, key));
      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach(key => addIfFound(scopes, defaults$1, key));
      keys.forEach(key => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const {options, type} = this;
    return [
      options,
      overrides[type] || {},
      defaults$1.datasets[type] || {},
      {type},
      defaults$1,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names, context, prefixes = ['']) {
    const result = {$shared: true};
    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {
    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context)
      ? _attachContext(resolver, context, undefined, descriptorDefaults)
      : resolver;
  }
}
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
const hasFunction = value => isObject(value)
  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names) {
  const {isScriptable, isIndexable} = _descriptors(proxy);
  for (const prop of names) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if ((scriptable && (isFunction(value) || hasFunction(value)))
      || (indexable && isArray(value))) {
      return true;
    }
  }
  return false;
}

var version$1 = "3.7.1";

const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];
function positionIsHorizontal(position, axis) {
  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1]
      ? a[l2] - b[l2]
      : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins('afterRender');
  callback(animationOptions && animationOptions.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [context], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === 'string') {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === 'mouseout') {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
class Chart {
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error(
        'Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' +
				' must be destroyed before the canvas can be reused.'
      );
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = undefined;
    this.boxes = [];
    this.currentDevicePixelRatio = undefined;
    this.chartArea = undefined;
    this._active = [];
    this._lastEvent = undefined;
    this._listeners = {};
    this._responsiveListeners = undefined;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = undefined;
    this.$context = undefined;
    this._doResize = debounce$1(mode => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, 'complete', onAnimationsComplete);
    animator.listen(this, 'progress', onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins('beforeInit');
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins('afterInit');
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {width, height};
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? 'resize' : 'attach';
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins('resize', {size: newSize});
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(
        Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === 'r';
          const isHorizontal = axis === 'x';
          return {
            options: scaleOptions,
            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
          };
        })
      );
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
  }
  _removeUnreferencedMetasets() {
    const {_metasets: metasets, data: {datasets}} = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter(x => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = '' + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const {datasetElementType, dataElementType} = defaults$1.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins('reset');
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins('beforeElementsUpdate');
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const {controller} = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins('afterUpdate', {mode});
    this._layers.sort(compare2Level('z', '_idx'));
    const {_active, _lastEvent} = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const {_hiddenIndices} = this;
    const changes = this._getUniformDataChanges() || [];
    for (const {method, start, count} of changes) {
      const move = method === '_removeElements' ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(
      _dataChanges
        .filter(c => c[0] === idx)
        .map((c, i) => i + ',' + c.splice(1).join(','))
    );
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet)
      .map(c => c.split(','))
      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === 'chartArea') {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins('afterLayout');
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);
    }
    this.notifyPlugins('afterDatasetsUpdate', {mode});
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = {meta, index, mode, cancelable: true};
    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins('afterDatasetUpdate', args);
  }
  render() {
    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({chart: this});
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const {width, height} = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins('afterDraw');
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins('afterDatasetsDraw');
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins('afterDatasetDraw', args);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === 'function') {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter(x => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? 'show' : 'hide';
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(undefined, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {visible});
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins('beforeDestroy');
    const {canvas, ctx} = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins('destroy');
    delete instances[this.id];
    this.notifyPlugins('afterDestroy');
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener) => {
      platform.addEventListener(this, type, listener);
      listeners[type] = listener;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener) => {
      platform.addEventListener(this, type, listener);
      listeners[type] = listener;
    };
    const _remove = (type, listener) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove('attach', attached);
      this.attached = true;
      this.resize();
      _add('resize', listener);
      _add('detach', detached);
    };
    detached = () => {
      this.attached = false;
      _remove('resize', listener);
      this._stop();
      this._resize(0, 0);
      _add('attach', attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = undefined;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? 'set' : 'remove';
    let meta, item, i, ilen;
    if (mode === 'dataset') {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller['_' + prefix + 'DatasetHoverStyle']();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({datasetIndex, index}) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error('No dataset found at index ' + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index,
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: _isPointInArea(e, this.chartArea, this._minPadding)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins('afterEvent', args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const {_active: lastActive = [], options} = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === 'mouseout') {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}
const invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
const enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: defaults$1
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version$1
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});

function clipArc(ctx, element, endAngle) {
  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta),
  };
}
function pathArc(ctx, element, offset, spacing, end) {
  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;
    spacingOffset = (alpha - adjustedAngle) / 2;
  }
  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
  if (outerEnd > 0) {
    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
  }
  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
  ctx.lineTo(p4.x, p4.y);
  if (innerEnd > 0) {
    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
  }
  ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);
  if (innerStart > 0) {
    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
  }
  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
  ctx.lineTo(p8.x, p8.y);
  if (outerStart > 0) {
    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing) {
  const {fullCircles, startAngle, circumference} = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, startAngle + TAU);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
  const {x, y, startAngle, pixelMargin, fullCircles} = element;
  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
  const innerRadius = element.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element, offset, spacing, endAngle) {
  const {options} = element;
  const {borderWidth, borderJoinStyle} = options;
  const inner = options.borderAlign === 'inner';
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || 'round';
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || 'bevel';
  }
  if (element.fullCircles) {
    drawFullCircleBorders(ctx, element, inner);
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  pathArc(ctx, element, offset, spacing, endAngle);
  ctx.stroke();
}
class ArcElement extends Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.circumference = undefined;
    this.startAngle = undefined;
    this.endAngle = undefined;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(['x', 'y'], useFinalPosition);
    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});
    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([
      'startAngle',
      'endAngle',
      'innerRadius',
      'outerRadius',
      'circumference'
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return (betweenAngles && withinRadius);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([
      'x',
      'y',
      'startAngle',
      'endAngle',
      'innerRadius',
      'outerRadius',
      'circumference',
    ], useFinalPosition);
    const {offset, spacing} = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const {options, circumference} = this;
    const offset = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset) {
      radiusOffset = offset / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle);
    ctx.restore();
  }
}
ArcElement.id = 'arc';
ArcElement.defaults = {
  borderAlign: 'center',
  borderColor: '#fff',
  borderJoinStyle: undefined,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: undefined,
};
ArcElement.defaultRoutes = {
  backgroundColor: 'backgroundColor'
};

function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;
  const {start: segmentStart, end: segmentEnd} = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const {points, options} = line;
  const {count, start, loop, ilen} = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let {move = true, reverse} = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const {count, start, ilen} = pathVars(points, segment, params);
  const {move = true, reverse} = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const {segments, options} = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
const usePath2D = typeof Path2D === 'function';
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
class LineElement extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = undefined;
    this._chart = undefined;
    this._loop = undefined;
    this._fullLoop = undefined;
    this._path = undefined;
    this._points = undefined;
    this._segments = undefined;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {property, start: value, end: value});
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const {start, end} = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || (this.points.length - start);
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = undefined;
    }
  }
}
LineElement.id = 'line';
LineElement.defaults = {
  borderCapStyle: 'butt',
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: 'miter',
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: 'default',
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0,
};
LineElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== 'borderDash' && name !== 'fill',
};

function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const {[axis]: value} = el.getProps([axis], useFinalPosition);
  return (Math.abs(pos - value) < options.radius + options.hitRadius);
}
class PointElement extends Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.parsed = undefined;
    this.skip = undefined;
    this.stop = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, 'x', useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, 'y', useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return {x, y};
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
}
PointElement.id = 'point';
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: 'circle',
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};

function getBarBounds(bar, useFinalPosition) {
  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {left, top, right, bottom};
}
function skipOrLimit(skip, value, min, max) {
  return skip ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip.top, o.top, 0, maxH),
    r: skipOrLimit(skip.right, o.right, 0, maxW),
    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects$1(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds
		&& (skipX || _isBetween(x, bounds.left, bounds.right))
		&& (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
class BarElement extends Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.horizontal = undefined;
    this.base = undefined;
    this.width = undefined;
    this.height = undefined;
    this.inflateAmount = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const {inflateAmount, options: {borderColor, backgroundColor}} = this;
    const {inner, outer} = boundingRects$1(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill('evenodd');
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === 'x' ? this.width / 2 : this.height / 2;
  }
}
BarElement.id = 'bar';
BarElement.defaults = {
  borderSkipped: 'start',
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: 'auto',
  pointStyle: undefined
};
BarElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};

var elements = /*#__PURE__*/Object.freeze({
__proto__: null,
ArcElement: ArcElement,
LineElement: LineElement,
PointElement: PointElement,
BarElement: BarElement
});

function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const {x: pointAx, y: pointAy} = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs(
        (pointAx - avgX) * (data[j].y - pointAy) -
        (pointAx - data[j].x) * (avgY - pointAy)
      );
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX,
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, 'data', {value: data});
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const {iScale} = meta;
  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {start, count};
}
var plugin_decimation = {
  id: 'decimation',
  defaults: {
    algorithm: 'min-max',
    enabled: false,
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const {_data, indexAxis} = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {
        return;
      }
      if (meta.type !== 'line') {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, 'data', {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
      case 'lttb':
        decimated = lttbDecimation(data, start, count, availableWidth, options);
        break;
      case 'min-max':
        decimated = minMaxDecimation(data, start, count, availableWidth);
        break;
      default:
        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};

function getLineByIndex(chart, index) {
  const meta = chart.getDatasetMeta(index);
  const visible = meta && chart.isDatasetVisible(index);
  return visible ? meta.dataset : null;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill === undefined) {
    fill = !!options.backgroundColor;
  }
  if (fill === false || fill === null) {
    return false;
  }
  if (fill === true) {
    return 'origin';
  }
  return fill;
}
function decodeFill(line, index, count) {
  const fill = parseFillOption(line);
  if (isObject(fill)) {
    return isNaN(fill.value) ? false : fill;
  }
  let target = parseFloat(fill);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    if (fill[0] === '-' || fill[0] === '+') {
      target = index + target;
    }
    if (target === index || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;
}
function computeLinearBoundary(source) {
  const {scale = {}, fill} = source;
  let target = null;
  let horizontal;
  if (fill === 'start') {
    target = scale.bottom;
  } else if (fill === 'end') {
    target = scale.top;
  } else if (isObject(fill)) {
    target = scale.getPixelForValue(fill.value);
  } else if (scale.getBasePixel) {
    target = scale.getBasePixel();
  }
  if (isNumberFinite(target)) {
    horizontal = scale.isHorizontal();
    return {
      x: horizontal ? target : null,
      y: horizontal ? null : target
    };
  }
  return null;
}
class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const {x, y, radius} = this;
    bounds = bounds || {start: 0, end: TAU};
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const {x, y, radius} = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
}
function computeCircularBoundary(source) {
  const {scale, fill} = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const target = [];
  const start = options.reverse ? scale.max : scale.min;
  const end = options.reverse ? scale.min : scale.max;
  let i, center, value;
  if (fill === 'start') {
    value = start;
  } else if (fill === 'end') {
    value = end;
  } else if (isObject(fill)) {
    value = fill.value;
  } else {
    value = scale.getBaseValue();
  }
  if (options.grid.circular) {
    center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function findSegmentEnd(start, end, points) {
  for (;end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function pointsFromSegments(boundary, line) {
  const {x = null, y = null} = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({start, end}) => {
    end = findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({x: first.x, y});
      points.push({x: last.x, y});
    } else if (x !== null) {
      points.push({x, y: first.y});
      points.push({x, y: last.y});
    }
  });
  return points;
}
function buildStackLine(source) {
  const {scale, index, line} = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index);
  linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({points, options: {}});
}
function getLinesBelow(scale, index) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas('line');
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const {first, last, point} = findPoint(line, sourcePoint, 'x');
    if (!point || (first && last)) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {first, last, point};
}
function getTarget(source) {
  const {chart, fill, line} = source;
  if (isNumberFinite(fill)) {
    return getLineByIndex(chart, fill);
  }
  if (fill === 'stack') {
    return buildStackLine(source);
  }
  if (fill === 'shape') {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return createBoundaryLine(boundary, line);
}
function createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {tension: 0},
    _loop,
    _fullLoop: _loop
  }) : null;
}
function resolveTarget(sources, index, propagate) {
  const source = sources[index];
  let fill = source.fill;
  const visited = [index];
  let target;
  if (!propagate) {
    return fill;
  }
  while (fill !== false && visited.indexOf(fill) === -1) {
    if (!isNumberFinite(fill)) {
      return fill;
    }
    target = sources[fill];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill;
    }
    visited.push(fill);
    fill = target.fill;
  }
  return false;
}
function _clip(ctx, target, clipY) {
  const {segments, points} = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const {start, end} = segment;
    const firstPoint = points[start];
    const lastPoint = points[findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === 'angle') {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {property, start, end};
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let {start, end} = segment;
    end = findSegmentEnd(start, end, points);
    const bounds = getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, 'start', Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, 'end', Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function clipBounds(ctx, scale, bounds) {
  const {top, bottom} = scale.chart.chartArea;
  const {property, start, end} = bounds || {};
  if (property === 'x') {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
function _fill(ctx, cfg) {
  const {line, target, property, color, scale} = cfg;
  const segments = _segments(line, target, property);
  for (const {source: src, target: tgt, start, end} of segments) {
    const {style: {backgroundColor = color} = {}} = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? 'evenodd' : 'nonzero');
    ctx.restore();
  }
}
function doFill(ctx, cfg) {
  const {line, target, above, below, area, scale} = cfg;
  const property = line._loop ? 'angle' : cfg.axis;
  ctx.save();
  if (property === 'x' && below !== above) {
    _clip(ctx, target, area.top);
    _fill(ctx, {line, target, color: above, scale, property});
    ctx.restore();
    ctx.save();
    _clip(ctx, target, area.bottom);
  }
  _fill(ctx, {line, target, color: below, scale, property});
  ctx.restore();
}
function drawfill(ctx, source, area) {
  const target = getTarget(source);
  const {line, scale, axis} = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color = lineOpts.backgroundColor;
  const {above = color, below = color} = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {line, target, above, below, area, scale, axis});
    unclipArea(ctx);
  }
}
var plugin_filler = {
  id: 'filler',
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line,
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw = options.drawTime === 'beforeDraw';
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw) {
        drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== 'beforeDatasetsDraw') {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (source) {
        drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {
      return;
    }
    drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: 'beforeDatasetDraw'
  }
};

const getBoxSize = (labelOpts, fontSize) => {
  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = undefined;
    this.columnSizes = undefined;
    this.lineWidths = undefined;
    this.maxHeight = undefined;
    this.maxWidth = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.height = undefined;
    this.width = undefined;
    this._margins = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const {options, ctx} = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const {ctx, maxWidth, options: {labels: {padding}}} = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const {ctx, maxHeight, options: {labels: {padding}}} = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({width: currentColWidth, height: currentColHeight});
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({width: currentColWidth, height: currentColHeight});
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === 'top' || this.options.position === 'bottom';
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const {options: opts, columnSizes, lineWidths, ctx} = this;
    const {align, labels: labelOpts} = opts;
    const defaultColor = defaults$1.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const {color: fontColor, padding} = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign('left');
    ctx.textBaseline = 'middle';
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxWidth * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some(v => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius,
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = 'middle';
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right)
      && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)
          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === 'mousemove') {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
}
function isListened(type, opts) {
  if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === 'click' || type === 'mouseup')) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: 'legend',
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: 'top',
    align: 'center',
    fullSize: true,
    reverse: false,
    weight: 1000,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: 'center',
      text: '',
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith('on'),
    labels: {
      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),
    }
  },
};

class Title extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === 'top' || pos === 'bottom';
  }
  _drawArgs(offset) {
    const {top, left, bottom, right, options} = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === 'left') {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {titleX, titleY, maxWidth, rotation};
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: 'middle',
      translation: [titleX, titleY],
    });
  }
}
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: 'title',
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'bold',
    },
    fullSize: true,
    padding: 10,
    position: 'top',
    text: '',
    weight: 2000
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false,
  },
};

const map = new WeakMap();
var plugin_subtitle = {
  id: 'subtitle',
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map.get(chart));
    map.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'normal',
    },
    fullSize: true,
    padding: 0,
    position: 'top',
    text: '',
    weight: 1500
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false,
  },
};

const positioners$1 = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
    return str.split('\n');
  }
  return str;
}
function createTooltipItem(chart, item) {
  const {element, datasetIndex, index} = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const {label, value} = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const {body, footer, title} = tooltip;
  const {boxWidth, boxHeight} = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight
			+ (titleLineCount - 1) * options.titleSpacing
			+ options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight
			+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight
			+ (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop
			+ footerLineCount * footerFont.lineHeight
			+ (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {width, height};
}
function determineYAlign(chart, size) {
  const {y, height} = size;
  if (y < height / 2) {
    return 'top';
  } else if (y > (chart.height - height / 2)) {
    return 'bottom';
  }
  return 'center';
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const {x, width} = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === 'left' && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === 'right' && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const {x, width} = size;
  const {width: chartWidth, chartArea: {left, right}} = chart;
  let xAlign = 'center';
  if (yAlign === 'center') {
    xAlign = x <= (left + right) / 2 ? 'left' : 'right';
  } else if (x <= width / 2) {
    xAlign = 'left';
  } else if (x >= chartWidth - width / 2) {
    xAlign = 'right';
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = 'center';
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let {x, width} = size;
  if (xAlign === 'right') {
    x -= width;
  } else if (xAlign === 'center') {
    x -= (width / 2);
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let {y, height} = size;
  if (yAlign === 'top') {
    y += paddingAndSize;
  } else if (yAlign === 'bottom') {
    y -= height + paddingAndSize;
  } else {
    y -= (height / 2);
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const {caretSize, caretPadding, cornerRadius} = options;
  const {xAlign, yAlign} = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === 'center') {
    if (xAlign === 'left') {
      x += paddingAndSize;
    } else if (xAlign === 'right') {
      x -= paddingAndSize;
    }
  } else if (xAlign === 'left') {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === 'right') {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === 'center'
    ? tooltip.x + tooltip.width / 2
    : align === 'right'
      ? tooltip.x + tooltip.width - padding.right
      : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback) {
  return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: 'tooltip'
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
class Tooltip extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = undefined;
    this._size = undefined;
    this._cachedAnimations = undefined;
    this._tooltipItems = [];
    this.$animations = undefined;
    this.$context = undefined;
    this.chart = config.chart || config._chart;
    this._chart = this.chart;
    this.options = config.options;
    this.dataPoints = undefined;
    this.title = undefined;
    this.beforeBody = undefined;
    this.body = undefined;
    this.afterBody = undefined;
    this.footer = undefined;
    this.xAlign = undefined;
    this.yAlign = undefined;
    this.x = undefined;
    this.y = undefined;
    this.height = undefined;
    this.width = undefined;
    this.caretX = undefined;
    this.caretY = undefined;
    this.labelColors = undefined;
    this.labelPointStyles = undefined;
    this.labelTextColors = undefined;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = undefined;
    this.$context = undefined;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context ||
			(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const {callbacks} = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const {callbacks} = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const {callbacks} = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners$1[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = undefined;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {chart: this.chart, tooltip: this, replay});
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const {xAlign, yAlign} = this;
    const {caretSize, cornerRadius} = options;
    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
    const {x: ptX, y: ptY} = tooltipPoint;
    const {width, height} = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === 'center') {
      y2 = ptY + (height / 2);
      if (xAlign === 'left') {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === 'left') {
        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);
      } else if (xAlign === 'right') {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === 'top') {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {x1, x2, x3, y1, y2, y3};
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = 'middle';
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const {boxHeight, boxWidth, boxPadding} = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, 'left', options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some(v => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius,
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius,
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const {body} = this;
    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = 'middle';
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'
      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)
      : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = 'middle';
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const {xAlign, yAlign} = this;
    const {x, y} = pt;
    const {width, height} = tooltipSize;
    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === 'top') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === 'center' && xAlign === 'right') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === 'bottom') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === 'center' && xAlign === 'left') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners$1[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({datasetIndex, index}) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error('Cannot find a dataset at index ' + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index,
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === 'mouseout') {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const {caretX, caretY, options} = this;
    const position = positioners$1[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
}
Tooltip.positioners = positioners$1;
var plugin_tooltip = {
  id: 'tooltip',
  _element: Tooltip,
  positioners: positioners$1,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({chart, options});
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    const args = {
      tooltip
    };
    if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {
      return;
    }
    if (tooltip) {
      tooltip.draw(chart.ctx);
    }
    chart.notifyPlugins('afterTooltipDraw', args);
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: 'average',
    backgroundColor: 'rgba(0,0,0,0.8)',
    titleColor: '#fff',
    titleFont: {
      weight: 'bold',
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: 'left',
    bodyColor: '#fff',
    bodySpacing: 2,
    bodyFont: {
    },
    bodyAlign: 'left',
    footerColor: '#fff',
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: 'bold',
    },
    footerAlign: 'left',
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: '#fff',
    displayColors: true,
    boxPadding: 0,
    borderColor: 'rgba(0,0,0,0)',
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: 'easeOutQuart',
    },
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],
      },
      opacity: {
        easing: 'linear',
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop$1,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === 'dataset') {
            return item.dataset.label || '';
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return '';
      },
      afterTitle: noop$1,
      beforeBody: noop$1,
      beforeLabel: noop$1,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === 'dataset') {
          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || '';
        if (label) {
          label += ': ';
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0,
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation,
        };
      },
      afterLabel: noop$1,
      afterBody: noop$1,
      beforeFooter: noop$1,
      footer: noop$1,
      afterFooter: noop$1
    }
  },
  defaultRoutes: {
    bodyFont: 'font',
    footerFont: 'font',
    titleFont: 'font'
  },
  descriptors: {
    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false,
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: 'animation'
    }
  },
  additionalOptionScopes: ['interaction']
};

var plugins = /*#__PURE__*/Object.freeze({
__proto__: null,
Decimation: plugin_decimation,
Filler: plugin_filler,
Legend: plugin_legend,
SubTitle: plugin_subtitle,
Title: plugin_title,
Tooltip: plugin_tooltip
});

const addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === 'string') {
    index = labels.push(raw) - 1;
    addedLabels.unshift({index, label: raw});
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
const validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
class CategoryScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = undefined;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const {index, label} of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index
      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const {minDefined, maxDefined} = this.getUserBounds();
    let {min, max} = this.getMinMax(true);
    if (this.options.bounds === 'ticks') {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({value});
    }
    return ticks;
  }
  getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== 'number') {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
CategoryScale.id = 'category';
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};

function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const {min: rmin, max: rmax} = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{value: rmin}, {value: rmax}];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === 'ticks') {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(
    _decimalPlaces(spacing),
    _decimalPlaces(niceMin)
  );
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({value: min});
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({value: max});
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({value: niceMax});
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
  const length = 0.75 * minSpacing * ('' + value).length;
  return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._endValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const {beginAtZero} = this.options;
    const {minDefined, maxDefined} = this.getUserBounds();
    let {min, max} = this;
    const setMin = v => (min = minDefined ? min : v);
    const setMax = v => (max = maxDefined ? max : v);
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset = Math.abs(max * 0.05);
      }
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let {maxTicksLimit, stepSize} = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1000) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1000;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === 'ticks') {
      _setMinAndMaxByKey(ticks, this, 'value');
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
}

class LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const {min, max} = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
LinearScale.id = 'linear';
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};

function isMajor(tickVal) {
  const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({value: tickVal, major: isMajor(tickVal)});
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || (exp === endExp && significand < endSignificand));
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks.push({value: lastTick, major: isMajor(tickVal)});
  return ticks;
}
class LogarithmicScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
    if (value === 0) {
      this._zero = true;
      return undefined;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const {min, max} = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const {minDefined, maxDefined} = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = v => (min = minDefined ? min : v);
    const setMax = v => (max = maxDefined ? max : v);
    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, +1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, +1));
    }
    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
      setMin(exp(min, -1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === 'ticks') {
      _setMinAndMaxByKey(ticks, this, 'value');
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === undefined
      ? '0'
      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === undefined || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min
      ? 0
      : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
}
LogarithmicScale.id = 'logarithmic';
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};

function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults$1.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - (size / 2),
      end: pos + (size / 2)
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(
    orig.l - limits.l,
    limits.r - orig.r,
    orig.t - limits.t,
    limits.b - orig.b
  );
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return 'center';
  } else if (angle < 180) {
    return 'left';
  }
  return 'right';
}
function leftForTextAlign(x, w, align) {
  if (align === 'right') {
    x -= w;
  } else if (align === 'center') {
    x -= (w / 2);
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= (h / 2);
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const {ctx, options: {pointLabels}} = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];
    const {backdropColor} = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
    }
    renderText(
      ctx,
      scale._pointLabels[i],
      x,
      y + (plFont.lineHeight / 2),
      plFont,
      {
        color: optsAtIndex.color,
        textAlign: textAlign,
        textBaseline: 'middle'
      }
    );
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const {ctx} = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const {color, lineWidth} = gridLineOpts;
  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: 'pointLabel'
  });
}
class RadialLinearScale extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = undefined;
    this.yCenter = undefined;
    this.drawingArea = undefined;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const {min, max} = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels()
      .map((value, index) => {
        const label = callback(this.options.pointLabels.callback, [value, index], this);
        return label || label === 0 ? label : '';
      })
      .filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const {left, top, right, bottom} = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom,
    };
  }
  drawBackground() {
    const {backgroundColor, grid: {circular}} = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const {angleLines, grid} = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const optsAtIndex = grid.setContext(this.getContext(index - 1));
          drawRadiusLine(this, optsAtIndex, offset, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const {color, lineWidth} = optsAtIndex;
        if (!lineWidth || !color) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {}
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    this.ticks.forEach((tick, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(
          -width / 2 - padding.left,
          -offset - tickFont.size / 2 - padding.top,
          width + padding.width,
          tickFont.size + padding.height
        );
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
      });
    });
    ctx.restore();
  }
  drawTitle() {}
}
RadialLinearScale.id = 'radialLinear';
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: 'chartArea',
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0.0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: undefined,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
RadialLinearScale.defaultRoutes = {
  'angleLines.color': 'borderColor',
  'pointLabels.color': 'color',
  'ticks.color': 'color'
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: 'grid'
  }
};

const INTERVALS = {
  millisecond: {common: true, size: 1, steps: 1000},
  second: {common: true, size: 1000, steps: 60},
  minute: {common: true, size: 60000, steps: 60},
  hour: {common: true, size: 3600000, steps: 24},
  day: {common: true, size: 86400000, steps: 30},
  week: {common: false, size: 604800000, steps: 4},
  month: {common: true, size: 2.628e9, steps: 12},
  quarter: {common: false, size: 7.884e9, steps: 4},
  year: {common: true, size: 3.154e10}
};
const UNITS = (Object.keys(INTERVALS));
function sorter(a, b) {
  return a - b;
}
function parse$1(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const {parser, round, isoWeekday} = scale._parseOpts;
  let value = input;
  if (typeof parser === 'function') {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === 'string'
      ? adapter.parse(value, parser)
      : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round) {
    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)
      ? adapter.startOf(value, 'isoWeek', isoWeekday)
      : adapter.startOf(value, round);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const {lo, hi} = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}
class TimeScale extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = 'day';
    this._majorUnit = undefined;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = undefined;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === undefined) {
      return null;
    }
    return parse$1(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || 'day';
    let {min, max, minDefined, maxDefined} = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {min, max};
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === 'ticks' && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip
      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))
      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined
      : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {start, end, factor: 1 / (start + 1 + end)};
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, 'isoWeek', weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
    if (adapter.diff(max, min, minor) > 100000 * stepSize) {
      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
    }
    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === 'ticks' || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index, ticks], this) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),
      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return (this._cache.data = metas[0].controller.getAllParsedValues(this));
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return (this._cache.data = this.normalize(timestamps));
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse$1(this, labels[i]));
    }
    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
}
TimeScale.id = 'time';
TimeScale.defaults = {
  bounds: 'data',
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: 'millisecond',
    displayFormats: {}
  },
  ticks: {
    source: 'auto',
    major: {
      enabled: false
    }
  }
};

function interpolate$1(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({lo, hi} = _lookupByKey(table, 'pos', val));
    }
    ({pos: prevSource, time: prevTarget} = table[lo]);
    ({pos: nextSource, time: nextTarget} = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({lo, hi} = _lookupByKey(table, 'time', val));
    }
    ({time: prevSource, pos: prevTarget} = table[lo]);
    ({time: nextSource, pos: nextTarget} = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = undefined;
    this._tableRange = undefined;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate$1(table, this.min);
    this._tableRange = interpolate$1(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const {min, max} = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {time: min, pos: 0},
        {time: max, pos: 1}
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({time: curr, pos: i / (ilen - 1)});
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate$1(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate$1(this._table, decimal * this._tableRange + this._minPos, true);
  }
}
TimeSeriesScale.id = 'timeseries';
TimeSeriesScale.defaults = TimeScale.defaults;

var scales = /*#__PURE__*/Object.freeze({
__proto__: null,
CategoryScale: CategoryScale,
LinearScale: LinearScale,
LogarithmicScale: LogarithmicScale,
RadialLinearScale: RadialLinearScale,
TimeScale: TimeScale,
TimeSeriesScale: TimeSeriesScale
});

const registerables = [
  controllers,
  elements,
  plugins,
  scales,
];

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var hammer = createCommonjsModule(function (module) {
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined$1) {

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined$1) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined$1 || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined$1 && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined$1)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined$1 : undefined$1, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined$1) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined$1;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined$1;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined$1)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined$1) {
            return;
        }
        if (handler === undefined$1) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined$1) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof undefined$1 === 'function' && undefined$1.amd) {
    undefined$1(function() {
        return Hammer;
    });
} else if (module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');
});

/*!
* chartjs-plugin-zoom v1.2.1
* undefined
 * (c) 2016-2022 chartjs-plugin-zoom Contributors
 * Released under the MIT License
 */

const getModifierKey = opts => opts && opts.enabled && opts.modifierKey;
const keyPressed = (key, event) => key && event[key + 'Key'];
const keyNotPressed = (key, event) => key && !event[key + 'Key'];

/**
 * @param {string|function} mode can be 'x', 'y' or 'xy'
 * @param {string} dir can be 'x' or 'y'
 * @param {import('chart.js').Chart} chart instance of the chart in question
 * @returns {boolean}
 */
function directionEnabled(mode, dir, chart) {
  if (mode === undefined) {
    return true;
  } else if (typeof mode === 'string') {
    return mode.indexOf(dir) !== -1;
  } else if (typeof mode === 'function') {
    return mode({chart}).indexOf(dir) !== -1;
  }

  return false;
}

/**
 * Debounces calling `fn` for `delay` ms
 * @param {function} fn - Function to call. No arguments are passed.
 * @param {number} delay - Delay in ms. 0 = immediate invocation.
 * @returns {function}
 */
function debounce(fn, delay) {
  let timeout;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(fn, delay);
    return delay;
  };
}

/** This function use for check what axis now under mouse cursor.
 * @param {{x: number, y: number}} point - the mouse location
 * @param {import('chart.js').Chart} [chart] instance of the chart in question
 * @return {import('chart.js').Scale}
 */
function getScaleUnderPoint({x, y}, chart) {
  const scales = chart.scales;
  const scaleIds = Object.keys(scales);
  for (let i = 0; i < scaleIds.length; i++) {
    const scale = scales[scaleIds[i]];
    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {
      return scale;
    }
  }
  return null;
}

/** This function return only one scale whose position is under mouse cursor and which direction is enabled.
 * If under mouse hasn't scale, then return all other scales which 'mode' is diffrent with overScaleMode.
 * So 'overScaleMode' works as a limiter to scale the user-selected scale (in 'mode') only when the cursor is under the scale,
 * and other directions in 'mode' works as before.
 * Example: mode = 'xy', overScaleMode = 'y' -> it's means 'x' - works as before, and 'y' only works for one scale when cursor is under it.
 * options.overScaleMode can be a function if user want zoom only one scale of many for example.
 * @param {string} mode - 'xy', 'x' or 'y'
 * @param {{x: number, y: number}} point - the mouse location
 * @param {import('chart.js').Chart} [chart] instance of the chart in question
 * @return {import('chart.js').Scale[]}
 */
function getEnabledScalesByPoint(mode, point, chart) {
  const scale = getScaleUnderPoint(point, chart);

  if (scale && directionEnabled(mode, scale.axis, chart)) {
    return [scale];
  }

  const enabledScales = [];
  each(chart.scales, function(scaleItem) {
    if (!directionEnabled(mode, scaleItem.axis, chart)) {
      enabledScales.push(scaleItem);
    }
  });
  return enabledScales;
}

const chartStates = new WeakMap();

function getState(chart) {
  let state = chartStates.get(chart);
  if (!state) {
    state = {
      originalScaleLimits: {},
      updatedScaleLimits: {},
      handlers: {},
      panDelta: {}
    };
    chartStates.set(chart, state);
  }
  return state;
}

function removeState(chart) {
  chartStates.delete(chart);
}

function zoomDelta(scale, zoom, center) {
  const range = scale.max - scale.min;
  const newRange = range * (zoom - 1);

  const centerPoint = scale.isHorizontal() ? center.x : center.y;
  // `scale.getValueForPixel()` can return a value less than the `scale.min` or
  // greater than `scale.max` when `centerPoint` is outside chartArea.
  const minPercent = Math.max(0, Math.min(1,
    (scale.getValueForPixel(centerPoint) - scale.min) / range || 0
  ));

  const maxPercent = 1 - minPercent;

  return {
    min: newRange * minPercent,
    max: newRange * maxPercent
  };
}

function getLimit(state, scale, scaleLimits, prop, fallback) {
  let limit = scaleLimits[prop];
  if (limit === 'original') {
    const original = state.originalScaleLimits[scale.id][prop];
    limit = valueOrDefault(original.options, original.scale);
  }
  return valueOrDefault(limit, fallback);
}

function updateRange(scale, {min, max}, limits, zoom = false) {
  const state = getState(scale.chart);
  const {id, axis, options: scaleOpts} = scale;

  const scaleLimits = limits && (limits[id] || limits[axis]) || {};
  const {minRange = 0} = scaleLimits;
  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);
  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);

  const cmin = Math.max(min, minLimit);
  const cmax = Math.min(max, maxLimit);
  const range = zoom ? Math.max(cmax - cmin, minRange) : scale.max - scale.min;
  if (cmax - cmin !== range) {
    if (minLimit > cmax - range) {
      min = cmin;
      max = cmin + range;
    } else if (maxLimit < cmin + range) {
      max = cmax;
      min = cmax - range;
    } else {
      const offset = (range - cmax + cmin) / 2;
      min = cmin - offset;
      max = cmax + offset;
    }
  } else {
    min = cmin;
    max = cmax;
  }
  scaleOpts.min = min;
  scaleOpts.max = max;

  state.updatedScaleLimits[scale.id] = {min, max};

  // return true if the scale range is changed
  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;
}

function zoomNumericalScale(scale, zoom, center, limits) {
  const delta = zoomDelta(scale, zoom, center);
  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};
  return updateRange(scale, newRange, limits, true);
}

const integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);

function existCategoryFromMaxZoom(scale) {
  const labels = scale.getLabels();
  const maxIndex = labels.length - 1;

  if (scale.min > 0) {
    scale.min -= 1;
  }
  if (scale.max < maxIndex) {
    scale.max += 1;
  }
}

function zoomCategoryScale(scale, zoom, center, limits) {
  const delta = zoomDelta(scale, zoom, center);
  if (scale.min === scale.max && zoom < 1) {
    existCategoryFromMaxZoom(scale);
  }
  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};
  return updateRange(scale, newRange, limits, true);
}

function scaleLength(scale) {
  return scale.isHorizontal() ? scale.width : scale.height;
}

function panCategoryScale(scale, delta, limits) {
  const labels = scale.getLabels();
  const lastLabelIndex = labels.length - 1;
  let {min, max} = scale;
  // The visible range. Ticks can be skipped, and thus not reliable.
  const range = Math.max(max - min, 1);
  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.
  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));
  const stepSize = Math.round(Math.abs(delta / stepDelta));
  let applied;
  if (delta < -stepDelta) {
    max = Math.min(max + stepSize, lastLabelIndex);
    min = range === 1 ? max : max - range;
    applied = max === lastLabelIndex;
  } else if (delta > stepDelta) {
    min = Math.max(0, min - stepSize);
    max = range === 1 ? min : min + range;
    applied = min === 0;
  }

  return updateRange(scale, {min, max}, limits) || applied;
}

const OFFSETS = {
  second: 500, // 500 ms
  minute: 30 * 1000, // 30 s
  hour: 30 * 60 * 1000, // 30 m
  day: 12 * 60 * 60 * 1000, // 12 h
  week: 3.5 * 24 * 60 * 60 * 1000, // 3.5 d
  month: 15 * 24 * 60 * 60 * 1000, // 15 d
  quarter: 60 * 24 * 60 * 60 * 1000, // 60 d
  year: 182 * 24 * 60 * 60 * 1000 // 182 d
};

function panNumericalScale(scale, delta, limits, canZoom = false) {
  const {min: prevStart, max: prevEnd, options} = scale;
  const round = options.time && options.time.round;
  const offset = OFFSETS[round] || 0;
  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);
  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);
  const {min: minLimit = -Infinity, max: maxLimit = Infinity} = canZoom && limits && limits[scale.axis] || {};
  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {
    // At limit: No change but return true to indicate no need to store the delta.
    // NaN can happen for 0-dimension scales (either because they were configured
    // with min === max or because the chart has 0 plottable area).
    return true;
  }
  return updateRange(scale, {min: newMin, max: newMax}, limits, canZoom);
}

function panNonLinearScale(scale, delta, limits) {
  return panNumericalScale(scale, delta, limits, true);
}

const zoomFunctions = {
  category: zoomCategoryScale,
  default: zoomNumericalScale,
};

const panFunctions = {
  category: panCategoryScale,
  default: panNumericalScale,
  logarithmic: panNonLinearScale,
  timeseries: panNonLinearScale,
};

function shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {
  const {id, options: {min, max}} = scale;
  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {
    return true;
  }
  const previous = updatedScaleLimits[id];
  return previous.min !== min || previous.max !== max;
}

function removeMissingScales(limits, scales) {
  each(limits, (opt, key) => {
    if (!scales[key]) {
      delete limits[key];
    }
  });
}

function storeOriginalScaleLimits(chart, state) {
  const {scales} = chart;
  const {originalScaleLimits, updatedScaleLimits} = state;

  each(scales, function(scale) {
    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {
      originalScaleLimits[scale.id] = {
        min: {scale: scale.min, options: scale.options.min},
        max: {scale: scale.max, options: scale.options.max},
      };
    }
  });

  removeMissingScales(originalScaleLimits, scales);
  removeMissingScales(updatedScaleLimits, scales);
  return originalScaleLimits;
}

function doZoom(scale, amount, center, limits) {
  const fn = zoomFunctions[scale.type] || zoomFunctions.default;
  callback(fn, [scale, amount, center, limits]);
}

function getCenter(chart) {
  const ca = chart.chartArea;
  return {
    x: (ca.left + ca.right) / 2,
    y: (ca.top + ca.bottom) / 2,
  };
}

/**
 * @param chart The chart instance
 * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point
 * @param {string} [transition] Which transition mode to use. Defaults to 'none'
 */
function zoom(chart, amount, transition = 'none') {
  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;
  const state = getState(chart);
  const {options: {limits, zoom: zoomOptions}} = state;
  const {mode = 'xy', overScaleMode} = zoomOptions || {};

  storeOriginalScaleLimits(chart, state);

  const xEnabled = x !== 1 && directionEnabled(mode, 'x', chart);
  const yEnabled = y !== 1 && directionEnabled(mode, 'y', chart);
  const enabledScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, focalPoint, chart);

  each(enabledScales || chart.scales, function(scale) {
    if (scale.isHorizontal() && xEnabled) {
      doZoom(scale, x, focalPoint, limits);
    } else if (!scale.isHorizontal() && yEnabled) {
      doZoom(scale, y, focalPoint, limits);
    }
  });

  chart.update(transition);

  callback(zoomOptions.onZoom, [{chart}]);
}

function getRange(scale, pixel0, pixel1) {
  const v0 = scale.getValueForPixel(pixel0);
  const v1 = scale.getValueForPixel(pixel1);
  return {
    min: Math.min(v0, v1),
    max: Math.max(v0, v1)
  };
}

function zoomRect(chart, p0, p1, transition = 'none') {
  const state = getState(chart);
  const {options: {limits, zoom: zoomOptions}} = state;
  const {mode = 'xy'} = zoomOptions;

  storeOriginalScaleLimits(chart, state);
  const xEnabled = directionEnabled(mode, 'x', chart);
  const yEnabled = directionEnabled(mode, 'y', chart);

  each(chart.scales, function(scale) {
    if (scale.isHorizontal() && xEnabled) {
      updateRange(scale, getRange(scale, p0.x, p1.x), limits, true);
    } else if (!scale.isHorizontal() && yEnabled) {
      updateRange(scale, getRange(scale, p0.y, p1.y), limits, true);
    }
  });

  chart.update(transition);

  callback(zoomOptions.onZoom, [{chart}]);
}

function zoomScale(chart, scaleId, range, transition = 'none') {
  storeOriginalScaleLimits(chart, getState(chart));
  const scale = chart.scales[scaleId];
  updateRange(scale, range, undefined, true);
  chart.update(transition);
}

function resetZoom(chart, transition = 'default') {
  const state = getState(chart);
  const originalScaleLimits = storeOriginalScaleLimits(chart, state);

  each(chart.scales, function(scale) {
    const scaleOptions = scale.options;
    if (originalScaleLimits[scale.id]) {
      scaleOptions.min = originalScaleLimits[scale.id].min.options;
      scaleOptions.max = originalScaleLimits[scale.id].max.options;
    } else {
      delete scaleOptions.min;
      delete scaleOptions.max;
    }
  });
  chart.update(transition);
  callback(state.options.zoom.onZoomComplete, [{chart}]);
}

function getOriginalRange(state, scaleId) {
  const original = state.originalScaleLimits[scaleId];
  if (!original) {
    return;
  }
  const {min, max} = original;
  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);
}

function getZoomLevel(chart) {
  const state = getState(chart);
  let min = 1;
  let max = 1;
  each(chart.scales, function(scale) {
    const origRange = getOriginalRange(state, scale.id);
    if (origRange) {
      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;
      min = Math.min(min, level);
      max = Math.max(max, level);
    }
  });
  return min < 1 ? min : max;
}

function panScale(scale, delta, limits, state) {
  const {panDelta} = state;
  // Add possible cumulative delta from previous pan attempts where scale did not change
  const storedDelta = panDelta[scale.id] || 0;
  if (sign(storedDelta) === sign(delta)) {
    delta += storedDelta;
  }
  const fn = panFunctions[scale.type] || panFunctions.default;
  if (callback(fn, [scale, delta, limits])) {
    // The scale changed, reset cumulative delta
    panDelta[scale.id] = 0;
  } else {
    // The scale did not change, store cumulative delta
    panDelta[scale.id] = delta;
  }
}

function pan(chart, delta, enabledScales, transition = 'none') {
  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;
  const state = getState(chart);
  const {options: {pan: panOptions, limits}} = state;
  const {mode = 'xy', onPan} = panOptions || {};

  storeOriginalScaleLimits(chart, state);

  const xEnabled = x !== 0 && directionEnabled(mode, 'x', chart);
  const yEnabled = y !== 0 && directionEnabled(mode, 'y', chart);

  each(enabledScales || chart.scales, function(scale) {
    if (scale.isHorizontal() && xEnabled) {
      panScale(scale, x, limits, state);
    } else if (!scale.isHorizontal() && yEnabled) {
      panScale(scale, y, limits, state);
    }
  });

  chart.update(transition);

  callback(onPan, [{chart}]);
}

function getInitialScaleBounds(chart) {
  const state = getState(chart);
  const scaleBounds = {};
  for (const scaleId of Object.keys(chart.scales)) {
    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};
    scaleBounds[scaleId] = {min: min.scale, max: max.scale};
  }

  return scaleBounds;
}

function isZoomedOrPanned(chart) {
  const scaleBounds = getInitialScaleBounds(chart);
  for (const scaleId of Object.keys(chart.scales)) {
    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];

    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {
      return true;
    }

    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {
      return true;
    }
  }

  return false;
}

function removeHandler(chart, type) {
  const {handlers} = getState(chart);
  const handler = handlers[type];
  if (handler && handler.target) {
    handler.target.removeEventListener(type, handler);
    delete handlers[type];
  }
}

function addHandler(chart, target, type, handler) {
  const {handlers, options} = getState(chart);
  const oldHandler = handlers[type];
  if (oldHandler && oldHandler.target === target) {
    // already attached
    return;
  }
  removeHandler(chart, type);
  handlers[type] = (event) => handler(chart, event, options);
  handlers[type].target = target;
  target.addEventListener(type, handlers[type]);
}

function mouseMove(chart, event) {
  const state = getState(chart);
  if (state.dragStart) {
    state.dragging = true;
    state.dragEnd = event;
    chart.update('none');
  }
}

function zoomStart(chart, event, zoomOptions) {
  const {onZoomStart, onZoomRejected} = zoomOptions;
  if (onZoomStart) {
    const {left: offsetX, top: offsetY} = event.target.getBoundingClientRect();
    const point = {
      x: event.clientX - offsetX,
      y: event.clientY - offsetY
    };
    if (callback(onZoomStart, [{chart, event, point}]) === false) {
      callback(onZoomRejected, [{chart, event}]);
      return false;
    }
  }
}

function mouseDown(chart, event) {
  const state = getState(chart);
  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;
  if (keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {
    return callback(zoomOptions.onZoomRejected, [{chart, event}]);
  }

  if (zoomStart(chart, event, zoomOptions) === false) {
    return;
  }
  state.dragStart = event;

  addHandler(chart, chart.canvas, 'mousemove', mouseMove);
}

function computeDragRect(chart, mode, beginPoint, endPoint) {
  const {left: offsetX, top: offsetY} = beginPoint.target.getBoundingClientRect();
  const xEnabled = directionEnabled(mode, 'x', chart);
  const yEnabled = directionEnabled(mode, 'y', chart);
  let {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;

  if (xEnabled) {
    left = Math.min(beginPoint.clientX, endPoint.clientX) - offsetX;
    right = Math.max(beginPoint.clientX, endPoint.clientX) - offsetX;
  }

  if (yEnabled) {
    top = Math.min(beginPoint.clientY, endPoint.clientY) - offsetY;
    bottom = Math.max(beginPoint.clientY, endPoint.clientY) - offsetY;
  }
  const width = right - left;
  const height = bottom - top;

  return {
    left,
    top,
    right,
    bottom,
    width,
    height,
    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,
    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1
  };
}

function mouseUp(chart, event) {
  const state = getState(chart);
  if (!state.dragStart) {
    return;
  }

  removeHandler(chart, 'mousemove');
  const {mode, onZoomComplete, drag: {threshold = 0}} = state.options.zoom;
  const rect = computeDragRect(chart, mode, state.dragStart, event);
  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;
  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;
  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

  // Remove drag start and end before chart update to stop drawing selected area
  state.dragStart = state.dragEnd = null;

  if (distance <= threshold) {
    state.dragging = false;
    chart.update('none');
    return;
  }

  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom');

  setTimeout(() => (state.dragging = false), 500);
  callback(onZoomComplete, [{chart}]);
}

function wheelPreconditions(chart, event, zoomOptions) {
  // Before preventDefault, check if the modifier key required and pressed
  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {
    callback(zoomOptions.onZoomRejected, [{chart, event}]);
    return;
  }

  if (zoomStart(chart, event, zoomOptions) === false) {
    return;
  }

  // Prevent the event from triggering the default behavior (eg. Content scrolling).
  if (event.cancelable) {
    event.preventDefault();
  }

  // Firefox always fires the wheel event twice:
  // First without the delta and right after that once with the delta properties.
  if (event.deltaY === undefined) {
    return;
  }
  return true;
}

function wheel(chart, event) {
  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);

  if (!wheelPreconditions(chart, event, zoomOptions)) {
    return;
  }

  const rect = event.target.getBoundingClientRect();
  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);
  const amount = {
    x: speed,
    y: speed,
    focalPoint: {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    }
  };

  zoom(chart, amount);

  if (onZoomComplete) {
    onZoomComplete();
  }
}

function addDebouncedHandler(chart, name, handler, delay) {
  if (handler) {
    getState(chart).handlers[name] = debounce(() => callback(handler, [{chart}]), delay);
  }
}

function addListeners(chart, options) {
  const canvas = chart.canvas;
  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;

  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off
  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page
  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled
  if (wheelOptions.enabled) {
    addHandler(chart, canvas, 'wheel', wheel);
    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);
  } else {
    removeHandler(chart, 'wheel');
  }
  if (dragOptions.enabled) {
    addHandler(chart, canvas, 'mousedown', mouseDown);
    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);
  } else {
    removeHandler(chart, 'mousedown');
    removeHandler(chart, 'mousemove');
    removeHandler(chart, 'mouseup');
  }
}

function removeListeners(chart) {
  removeHandler(chart, 'mousedown');
  removeHandler(chart, 'mousemove');
  removeHandler(chart, 'mouseup');
  removeHandler(chart, 'wheel');
  removeHandler(chart, 'click');
}

function createEnabler(chart, state) {
  return function(recognizer, event) {
    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;
    if (!panOptions || !panOptions.enabled) {
      return false;
    }
    const srcEvent = event && event.srcEvent;
    if (!srcEvent) { // Sometimes Hammer queries this with a null event.
      return true;
    }
    if (!state.panning && event.pointerType === 'mouse' && (
      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))
    ) {
      callback(panOptions.onPanRejected, [{chart, event}]);
      return false;
    }
    return true;
  };
}

function pinchAxes(p0, p1) {
  // fingers position difference
  const pinchX = Math.abs(p0.clientX - p1.clientX);
  const pinchY = Math.abs(p0.clientY - p1.clientY);

  // diagonal fingers will change both (xy) axes
  const p = pinchX / pinchY;
  let x, y;
  if (p > 0.3 && p < 1.7) {
    x = y = true;
  } else if (pinchX > pinchY) {
    x = true;
  } else {
    y = true;
  }
  return {x, y};
}

function handlePinch(chart, state, e) {
  if (state.scale) {
    const {center, pointers} = e;
    // Hammer reports the total scaling. We need the incremental amount
    const zoomPercent = 1 / state.scale * e.scale;
    const rect = e.target.getBoundingClientRect();
    const pinch = pinchAxes(pointers[0], pointers[1]);
    const mode = state.options.zoom.mode;
    const amount = {
      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,
      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,
      focalPoint: {
        x: center.x - rect.left,
        y: center.y - rect.top
      }
    };

    zoom(chart, amount);

    // Keep track of overall scale
    state.scale = e.scale;
  }
}

function startPinch(chart, state) {
  if (state.options.zoom.pinch.enabled) {
    state.scale = 1;
  }
}

function endPinch(chart, state, e) {
  if (state.scale) {
    handlePinch(chart, state, e);
    state.scale = null; // reset
    callback(state.options.zoom.onZoomComplete, [{chart}]);
  }
}

function handlePan(chart, state, e) {
  const delta = state.delta;
  if (delta) {
    state.panning = true;
    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);
    state.delta = {x: e.deltaX, y: e.deltaY};
  }
}

function startPan(chart, state, event) {
  const {enabled, overScaleMode, onPanStart, onPanRejected} = state.options.pan;
  if (!enabled) {
    return;
  }
  const rect = event.target.getBoundingClientRect();
  const point = {
    x: event.center.x - rect.left,
    y: event.center.y - rect.top
  };

  if (callback(onPanStart, [{chart, event, point}]) === false) {
    return callback(onPanRejected, [{chart, event}]);
  }

  state.panScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, point, chart);
  state.delta = {x: 0, y: 0};
  clearTimeout(state.panEndTimeout);
  handlePan(chart, state, event);
}

function endPan(chart, state) {
  state.delta = null;
  if (state.panning) {
    state.panEndTimeout = setTimeout(() => (state.panning = false), 500);
    callback(state.options.pan.onPanComplete, [{chart}]);
  }
}

const hammers = new WeakMap();
function startHammer(chart, options) {
  const state = getState(chart);
  const canvas = chart.canvas;
  const {pan: panOptions, zoom: zoomOptions} = options;

  const mc = new hammer.Manager(canvas);
  if (zoomOptions && zoomOptions.pinch.enabled) {
    mc.add(new hammer.Pinch());
    mc.on('pinchstart', () => startPinch(chart, state));
    mc.on('pinch', (e) => handlePinch(chart, state, e));
    mc.on('pinchend', (e) => endPinch(chart, state, e));
  }

  if (panOptions && panOptions.enabled) {
    mc.add(new hammer.Pan({
      threshold: panOptions.threshold,
      enable: createEnabler(chart, state)
    }));
    mc.on('panstart', (e) => startPan(chart, state, e));
    mc.on('panmove', (e) => handlePan(chart, state, e));
    mc.on('panend', () => endPan(chart, state));
  }

  hammers.set(chart, mc);
}

function stopHammer(chart) {
  const mc = hammers.get(chart);
  if (mc) {
    mc.remove('pinchstart');
    mc.remove('pinch');
    mc.remove('pinchend');
    mc.remove('panstart');
    mc.remove('pan');
    mc.remove('panend');
    mc.destroy();
    hammers.delete(chart);
  }
}

var version = "1.2.1";

var plugin$1 = {
  id: 'zoom',

  version,

  defaults: {
    pan: {
      enabled: false,
      mode: 'xy',
      threshold: 10,
      modifierKey: null,
    },
    zoom: {
      wheel: {
        enabled: false,
        speed: 0.1,
        modifierKey: null
      },
      drag: {
        enabled: false,
        modifierKey: null
      },
      pinch: {
        enabled: false
      },
      mode: 'xy',
    }
  },

  start: function(chart, _args, options) {
    const state = getState(chart);
    state.options = options;

    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {
      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');
    }

    if (hammer) {
      startHammer(chart, options);
    }

    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);
    chart.zoom = (args, transition) => zoom(chart, args, transition);
    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);
    chart.resetZoom = (transition) => resetZoom(chart, transition);
    chart.getZoomLevel = () => getZoomLevel(chart);
    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);
    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);
  },

  beforeEvent(chart) {
    const state = getState(chart);
    if (state.panning || state.dragging) {
      // cancel any event handling while panning or dragging
      return false;
    }
  },

  beforeUpdate: function(chart, args, options) {
    const state = getState(chart);
    state.options = options;
    addListeners(chart, options);
  },

  beforeDatasetsDraw: function(chart, args, options) {
    const {dragStart, dragEnd} = getState(chart);

    if (dragEnd) {
      const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);

      const dragOptions = options.zoom.drag;
      const ctx = chart.ctx;

      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';
      ctx.fillRect(left, top, width, height);

      if (dragOptions.borderWidth > 0) {
        ctx.lineWidth = dragOptions.borderWidth;
        ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';
        ctx.strokeRect(left, top, width, height);
      }
      ctx.restore();
    }
  },

  stop: function(chart) {
    removeListeners(chart);

    if (hammer) {
      stopHammer(chart);
    }
    removeState(chart);
  },

  panFunctions,

  zoomFunctions
};

/*!
 * chartjs-plugin-datalabels v2.0.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2021 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */

var devicePixelRatio = (function() {
  if (typeof window !== 'undefined') {
    if (window.devicePixelRatio) {
      return window.devicePixelRatio;
    }

    // devicePixelRatio is undefined on IE10
    // https://stackoverflow.com/a/20204180/8837887
    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/85
    var screen = window.screen;
    if (screen) {
      return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
    }
  }

  return 1;
}());

var utils = {
  // @todo move this in Chart.helpers.toTextLines
  toTextLines: function(inputs) {
    var lines = [];
    var input;

    inputs = [].concat(inputs);
    while (inputs.length) {
      input = inputs.pop();
      if (typeof input === 'string') {
        lines.unshift.apply(lines, input.split('\n'));
      } else if (Array.isArray(input)) {
        inputs.push.apply(inputs, input);
      } else if (!isNullOrUndef(inputs)) {
        lines.unshift('' + input);
      }
    }

    return lines;
  },

  // @todo move this in Chart.helpers.canvas.textSize
  // @todo cache calls of measureText if font doesn't change?!
  textSize: function(ctx, lines, font) {
    var items = [].concat(lines);
    var ilen = items.length;
    var prev = ctx.font;
    var width = 0;
    var i;

    ctx.font = font.string;

    for (i = 0; i < ilen; ++i) {
      width = Math.max(ctx.measureText(items[i]).width, width);
    }

    ctx.font = prev;

    return {
      height: ilen * font.lineHeight,
      width: width
    };
  },

  /**
   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).
   * @todo move this method in Chart.helpers.bound
   * https://doc.qt.io/qt-5/qtglobal.html#qBound
   */
  bound: function(min, value, max) {
    return Math.max(min, Math.min(value, max));
  },

  /**
   * Returns an array of pair [value, state] where state is:
   * * -1: value is only in a0 (removed)
   * *  1: value is only in a1 (added)
   */
  arrayDiff: function(a0, a1) {
    var prev = a0.slice();
    var updates = [];
    var i, j, ilen, v;

    for (i = 0, ilen = a1.length; i < ilen; ++i) {
      v = a1[i];
      j = prev.indexOf(v);

      if (j === -1) {
        updates.push([v, 1]);
      } else {
        prev.splice(j, 1);
      }
    }

    for (i = 0, ilen = prev.length; i < ilen; ++i) {
      updates.push([prev[i], -1]);
    }

    return updates;
  },

  /**
   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70
   */
  rasterize: function(v) {
    return Math.round(v * devicePixelRatio) / devicePixelRatio;
  }
};

function orient(point, origin) {
  var x0 = origin.x;
  var y0 = origin.y;

  if (x0 === null) {
    return {x: 0, y: -1};
  }
  if (y0 === null) {
    return {x: 1, y: 0};
  }

  var dx = point.x - x0;
  var dy = point.y - y0;
  var ln = Math.sqrt(dx * dx + dy * dy);

  return {
    x: ln ? dx / ln : 0,
    y: ln ? dy / ln : -1
  };
}

function aligned(x, y, vx, vy, align) {
  switch (align) {
  case 'center':
    vx = vy = 0;
    break;
  case 'bottom':
    vx = 0;
    vy = 1;
    break;
  case 'right':
    vx = 1;
    vy = 0;
    break;
  case 'left':
    vx = -1;
    vy = 0;
    break;
  case 'top':
    vx = 0;
    vy = -1;
    break;
  case 'start':
    vx = -vx;
    vy = -vy;
    break;
  case 'end':
    // keep natural orientation
    break;
  default:
    // clockwise rotation (in degree)
    align *= (Math.PI / 180);
    vx = Math.cos(align);
    vy = Math.sin(align);
    break;
  }

  return {
    x: x,
    y: y,
    vx: vx,
    vy: vy
  };
}

// Line clipping (CohenSutherland algorithm)
// https://en.wikipedia.org/wiki/CohenSutherland_algorithm

var R_INSIDE = 0;
var R_LEFT = 1;
var R_RIGHT = 2;
var R_BOTTOM = 4;
var R_TOP = 8;

function region(x, y, rect) {
  var res = R_INSIDE;

  if (x < rect.left) {
    res |= R_LEFT;
  } else if (x > rect.right) {
    res |= R_RIGHT;
  }
  if (y < rect.top) {
    res |= R_TOP;
  } else if (y > rect.bottom) {
    res |= R_BOTTOM;
  }

  return res;
}

function clipped(segment, area) {
  var x0 = segment.x0;
  var y0 = segment.y0;
  var x1 = segment.x1;
  var y1 = segment.y1;
  var r0 = region(x0, y0, area);
  var r1 = region(x1, y1, area);
  var r, x, y;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    if (!(r0 | r1) || (r0 & r1)) {
      // both points inside or on the same side: no clipping
      break;
    }

    // at least one point is outside
    r = r0 || r1;

    if (r & R_TOP) {
      x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);
      y = area.top;
    } else if (r & R_BOTTOM) {
      x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);
      y = area.bottom;
    } else if (r & R_RIGHT) {
      y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);
      x = area.right;
    } else if (r & R_LEFT) {
      y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);
      x = area.left;
    }

    if (r === r0) {
      x0 = x;
      y0 = y;
      r0 = region(x0, y0, area);
    } else {
      x1 = x;
      y1 = y;
      r1 = region(x1, y1, area);
    }
  }

  return {
    x0: x0,
    x1: x1,
    y0: y0,
    y1: y1
  };
}

function compute$1(range, config) {
  var anchor = config.anchor;
  var segment = range;
  var x, y;

  if (config.clamp) {
    segment = clipped(segment, config.area);
  }

  if (anchor === 'start') {
    x = segment.x0;
    y = segment.y0;
  } else if (anchor === 'end') {
    x = segment.x1;
    y = segment.y1;
  } else {
    x = (segment.x0 + segment.x1) / 2;
    y = (segment.y0 + segment.y1) / 2;
  }

  return aligned(x, y, range.vx, range.vy, config.align);
}

var positioners = {
  arc: function(el, config) {
    var angle = (el.startAngle + el.endAngle) / 2;
    var vx = Math.cos(angle);
    var vy = Math.sin(angle);
    var r0 = el.innerRadius;
    var r1 = el.outerRadius;

    return compute$1({
      x0: el.x + vx * r0,
      y0: el.y + vy * r0,
      x1: el.x + vx * r1,
      y1: el.y + vy * r1,
      vx: vx,
      vy: vy
    }, config);
  },

  point: function(el, config) {
    var v = orient(el, config.origin);
    var rx = v.x * el.options.radius;
    var ry = v.y * el.options.radius;

    return compute$1({
      x0: el.x - rx,
      y0: el.y - ry,
      x1: el.x + rx,
      y1: el.y + ry,
      vx: v.x,
      vy: v.y
    }, config);
  },

  bar: function(el, config) {
    var v = orient(el, config.origin);
    var x = el.x;
    var y = el.y;
    var sx = 0;
    var sy = 0;

    if (el.horizontal) {
      x = Math.min(el.x, el.base);
      sx = Math.abs(el.base - el.x);
    } else {
      y = Math.min(el.y, el.base);
      sy = Math.abs(el.base - el.y);
    }

    return compute$1({
      x0: x,
      y0: y + sy,
      x1: x + sx,
      y1: y,
      vx: v.x,
      vy: v.y
    }, config);
  },

  fallback: function(el, config) {
    var v = orient(el, config.origin);

    return compute$1({
      x0: el.x,
      y0: el.y,
      x1: el.x,
      y1: el.y,
      vx: v.x,
      vy: v.y
    }, config);
  }
};

var rasterize = utils.rasterize;

function boundingRects(model) {
  var borderWidth = model.borderWidth || 0;
  var padding = model.padding;
  var th = model.size.height;
  var tw = model.size.width;
  var tx = -tw / 2;
  var ty = -th / 2;

  return {
    frame: {
      x: tx - padding.left - borderWidth,
      y: ty - padding.top - borderWidth,
      w: tw + padding.width + borderWidth * 2,
      h: th + padding.height + borderWidth * 2
    },
    text: {
      x: tx,
      y: ty,
      w: tw,
      h: th
    }
  };
}

function getScaleOrigin(el, context) {
  var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;

  if (!scale) {
    return null;
  }

  if (scale.xCenter !== undefined && scale.yCenter !== undefined) {
    return {x: scale.xCenter, y: scale.yCenter};
  }

  var pixel = scale.getBasePixel();
  return el.horizontal ?
    {x: pixel, y: null} :
    {x: null, y: pixel};
}

function getPositioner(el) {
  if (el instanceof ArcElement) {
    return positioners.arc;
  }
  if (el instanceof PointElement) {
    return positioners.point;
  }
  if (el instanceof BarElement) {
    return positioners.bar;
  }
  return positioners.fallback;
}

function drawRoundedRect(ctx, x, y, w, h, radius) {
  var HALF_PI = Math.PI / 2;

  if (radius) {
    var r = Math.min(radius, h / 2, w / 2);
    var left = x + r;
    var top = y + r;
    var right = x + w - r;
    var bottom = y + h - r;

    ctx.moveTo(x, top);
    if (left < right && top < bottom) {
      ctx.arc(left, top, r, -Math.PI, -HALF_PI);
      ctx.arc(right, top, r, -HALF_PI, 0);
      ctx.arc(right, bottom, r, 0, HALF_PI);
      ctx.arc(left, bottom, r, HALF_PI, Math.PI);
    } else if (left < right) {
      ctx.moveTo(left, y);
      ctx.arc(right, top, r, -HALF_PI, HALF_PI);
      ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);
    } else if (top < bottom) {
      ctx.arc(left, top, r, -Math.PI, 0);
      ctx.arc(left, bottom, r, 0, Math.PI);
    } else {
      ctx.arc(left, top, r, -Math.PI, Math.PI);
    }
    ctx.closePath();
    ctx.moveTo(x, y);
  } else {
    ctx.rect(x, y, w, h);
  }
}

function drawFrame(ctx, rect, model) {
  var bgColor = model.backgroundColor;
  var borderColor = model.borderColor;
  var borderWidth = model.borderWidth;

  if (!bgColor && (!borderColor || !borderWidth)) {
    return;
  }

  ctx.beginPath();

  drawRoundedRect(
    ctx,
    rasterize(rect.x) + borderWidth / 2,
    rasterize(rect.y) + borderWidth / 2,
    rasterize(rect.w) - borderWidth,
    rasterize(rect.h) - borderWidth,
    model.borderRadius);

  ctx.closePath();

  if (bgColor) {
    ctx.fillStyle = bgColor;
    ctx.fill();
  }

  if (borderColor && borderWidth) {
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = 'miter';
    ctx.stroke();
  }
}

function textGeometry(rect, align, font) {
  var h = font.lineHeight;
  var w = rect.w;
  var x = rect.x;
  var y = rect.y + h / 2;

  if (align === 'center') {
    x += w / 2;
  } else if (align === 'end' || align === 'right') {
    x += w;
  }

  return {
    h: h,
    w: w,
    x: x,
    y: y
  };
}

function drawTextLine(ctx, text, cfg) {
  var shadow = ctx.shadowBlur;
  var stroked = cfg.stroked;
  var x = rasterize(cfg.x);
  var y = rasterize(cfg.y);
  var w = rasterize(cfg.w);

  if (stroked) {
    ctx.strokeText(text, x, y, w);
  }

  if (cfg.filled) {
    if (shadow && stroked) {
      // Prevent drawing shadow on both the text stroke and fill, so
      // if the text is stroked, remove the shadow for the text fill.
      ctx.shadowBlur = 0;
    }

    ctx.fillText(text, x, y, w);

    if (shadow && stroked) {
      ctx.shadowBlur = shadow;
    }
  }
}

function drawText(ctx, lines, rect, model) {
  var align = model.textAlign;
  var color = model.color;
  var filled = !!color;
  var font = model.font;
  var ilen = lines.length;
  var strokeColor = model.textStrokeColor;
  var strokeWidth = model.textStrokeWidth;
  var stroked = strokeColor && strokeWidth;
  var i;

  if (!ilen || (!filled && !stroked)) {
    return;
  }

  // Adjust coordinates based on text alignment and line height
  rect = textGeometry(rect, align, font);

  ctx.font = font.string;
  ctx.textAlign = align;
  ctx.textBaseline = 'middle';
  ctx.shadowBlur = model.textShadowBlur;
  ctx.shadowColor = model.textShadowColor;

  if (filled) {
    ctx.fillStyle = color;
  }
  if (stroked) {
    ctx.lineJoin = 'round';
    ctx.lineWidth = strokeWidth;
    ctx.strokeStyle = strokeColor;
  }

  for (i = 0, ilen = lines.length; i < ilen; ++i) {
    drawTextLine(ctx, lines[i], {
      stroked: stroked,
      filled: filled,
      w: rect.w,
      x: rect.x,
      y: rect.y + rect.h * i
    });
  }
}

var Label = function(config, ctx, el, index) {
  var me = this;

  me._config = config;
  me._index = index;
  me._model = null;
  me._rects = null;
  me._ctx = ctx;
  me._el = el;
};

merge(Label.prototype, {
  /**
   * @private
   */
  _modelize: function(display, lines, config, context) {
    var me = this;
    var index = me._index;
    var font = toFont(resolve([config.font, {}], context, index));
    var color = resolve([config.color, defaults$1.color], context, index);

    return {
      align: resolve([config.align, 'center'], context, index),
      anchor: resolve([config.anchor, 'center'], context, index),
      area: context.chart.chartArea,
      backgroundColor: resolve([config.backgroundColor, null], context, index),
      borderColor: resolve([config.borderColor, null], context, index),
      borderRadius: resolve([config.borderRadius, 0], context, index),
      borderWidth: resolve([config.borderWidth, 0], context, index),
      clamp: resolve([config.clamp, false], context, index),
      clip: resolve([config.clip, false], context, index),
      color: color,
      display: display,
      font: font,
      lines: lines,
      offset: resolve([config.offset, 0], context, index),
      opacity: resolve([config.opacity, 1], context, index),
      origin: getScaleOrigin(me._el, context),
      padding: toPadding(resolve([config.padding, 0], context, index)),
      positioner: getPositioner(me._el),
      rotation: resolve([config.rotation, 0], context, index) * (Math.PI / 180),
      size: utils.textSize(me._ctx, lines, font),
      textAlign: resolve([config.textAlign, 'start'], context, index),
      textShadowBlur: resolve([config.textShadowBlur, 0], context, index),
      textShadowColor: resolve([config.textShadowColor, color], context, index),
      textStrokeColor: resolve([config.textStrokeColor, color], context, index),
      textStrokeWidth: resolve([config.textStrokeWidth, 0], context, index)
    };
  },

  update: function(context) {
    var me = this;
    var model = null;
    var rects = null;
    var index = me._index;
    var config = me._config;
    var value, label, lines;

    // We first resolve the display option (separately) to avoid computing
    // other options in case the label is hidden (i.e. display: false).
    var display = resolve([config.display, true], context, index);

    if (display) {
      value = context.dataset.data[index];
      label = valueOrDefault(callback(config.formatter, [value, context]), value);
      lines = isNullOrUndef(label) ? [] : utils.toTextLines(label);

      if (lines.length) {
        model = me._modelize(display, lines, config, context);
        rects = boundingRects(model);
      }
    }

    me._model = model;
    me._rects = rects;
  },

  geometry: function() {
    return this._rects ? this._rects.frame : {};
  },

  rotation: function() {
    return this._model ? this._model.rotation : 0;
  },

  visible: function() {
    return this._model && this._model.opacity;
  },

  model: function() {
    return this._model;
  },

  draw: function(chart, center) {
    var me = this;
    var ctx = chart.ctx;
    var model = me._model;
    var rects = me._rects;
    var area;

    if (!this.visible()) {
      return;
    }

    ctx.save();

    if (model.clip) {
      area = model.area;
      ctx.beginPath();
      ctx.rect(
        area.left,
        area.top,
        area.right - area.left,
        area.bottom - area.top);
      ctx.clip();
    }

    ctx.globalAlpha = utils.bound(0, model.opacity, 1);
    ctx.translate(rasterize(center.x), rasterize(center.y));
    ctx.rotate(model.rotation);

    drawFrame(ctx, rects.frame, model);
    drawText(ctx, model.lines, rects.text, model);

    ctx.restore();
  }
});

var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991; // eslint-disable-line es/no-number-minsafeinteger
var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;  // eslint-disable-line es/no-number-maxsafeinteger

function rotated(point, center, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var cx = center.x;
  var cy = center.y;

  return {
    x: cx + cos * (point.x - cx) - sin * (point.y - cy),
    y: cy + sin * (point.x - cx) + cos * (point.y - cy)
  };
}

function projected(points, axis) {
  var min = MAX_INTEGER;
  var max = MIN_INTEGER;
  var origin = axis.origin;
  var i, pt, vx, vy, dp;

  for (i = 0; i < points.length; ++i) {
    pt = points[i];
    vx = pt.x - origin.x;
    vy = pt.y - origin.y;
    dp = axis.vx * vx + axis.vy * vy;
    min = Math.min(min, dp);
    max = Math.max(max, dp);
  }

  return {
    min: min,
    max: max
  };
}

function toAxis(p0, p1) {
  var vx = p1.x - p0.x;
  var vy = p1.y - p0.y;
  var ln = Math.sqrt(vx * vx + vy * vy);

  return {
    vx: (p1.x - p0.x) / ln,
    vy: (p1.y - p0.y) / ln,
    origin: p0,
    ln: ln
  };
}

var HitBox = function() {
  this._rotation = 0;
  this._rect = {
    x: 0,
    y: 0,
    w: 0,
    h: 0
  };
};

merge(HitBox.prototype, {
  center: function() {
    var r = this._rect;
    return {
      x: r.x + r.w / 2,
      y: r.y + r.h / 2
    };
  },

  update: function(center, rect, rotation) {
    this._rotation = rotation;
    this._rect = {
      x: rect.x + center.x,
      y: rect.y + center.y,
      w: rect.w,
      h: rect.h
    };
  },

  contains: function(point) {
    var me = this;
    var margin = 1;
    var rect = me._rect;

    point = rotated(point, me.center(), -me._rotation);

    return !(point.x < rect.x - margin
      || point.y < rect.y - margin
      || point.x > rect.x + rect.w + margin * 2
      || point.y > rect.y + rect.h + margin * 2);
  },

  // Separating Axis Theorem
  // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169
  intersects: function(other) {
    var r0 = this._points();
    var r1 = other._points();
    var axes = [
      toAxis(r0[0], r0[1]),
      toAxis(r0[0], r0[3])
    ];
    var i, pr0, pr1;

    if (this._rotation !== other._rotation) {
      // Only separate with r1 axis if the rotation is different,
      // else it's enough to separate r0 and r1 with r0 axis only!
      axes.push(
        toAxis(r1[0], r1[1]),
        toAxis(r1[0], r1[3])
      );
    }

    for (i = 0; i < axes.length; ++i) {
      pr0 = projected(r0, axes[i]);
      pr1 = projected(r1, axes[i]);

      if (pr0.max < pr1.min || pr1.max < pr0.min) {
        return false;
      }
    }

    return true;
  },

  /**
   * @private
   */
  _points: function() {
    var me = this;
    var rect = me._rect;
    var angle = me._rotation;
    var center = me.center();

    return [
      rotated({x: rect.x, y: rect.y}, center, angle),
      rotated({x: rect.x + rect.w, y: rect.y}, center, angle),
      rotated({x: rect.x + rect.w, y: rect.y + rect.h}, center, angle),
      rotated({x: rect.x, y: rect.y + rect.h}, center, angle)
    ];
  }
});

function coordinates(el, model, geometry) {
  var point = model.positioner(el, model);
  var vx = point.vx;
  var vy = point.vy;

  if (!vx && !vy) {
    // if aligned center, we don't want to offset the center point
    return {x: point.x, y: point.y};
  }

  var w = geometry.w;
  var h = geometry.h;

  // take in account the label rotation
  var rotation = model.rotation;
  var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));
  var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));

  // scale the unit vector (vx, vy) to get at least dx or dy equal to
  // w or h respectively (else we would calculate the distance to the
  // ellipse inscribed in the bounding rect)
  var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
  dx *= vx * vs;
  dy *= vy * vs;

  // finally, include the explicit offset
  dx += model.offset * vx;
  dy += model.offset * vy;

  return {
    x: point.x + dx,
    y: point.y + dy
  };
}

function collide(labels, collider) {
  var i, j, s0, s1;

  // IMPORTANT Iterate in the reverse order since items at the end of the
  // list have an higher weight/priority and thus should be less impacted
  // by the overlapping strategy.

  for (i = labels.length - 1; i >= 0; --i) {
    s0 = labels[i].$layout;

    for (j = i - 1; j >= 0 && s0._visible; --j) {
      s1 = labels[j].$layout;

      if (s1._visible && s0._box.intersects(s1._box)) {
        collider(s0, s1);
      }
    }
  }

  return labels;
}

function compute(labels) {
  var i, ilen, label, state, geometry, center, proxy;

  // Initialize labels for overlap detection
  for (i = 0, ilen = labels.length; i < ilen; ++i) {
    label = labels[i];
    state = label.$layout;

    if (state._visible) {
      // Chart.js 3 removed el._model in favor of getProps(), making harder to
      // abstract reading values in positioners. Also, using string arrays to
      // read values (i.e. var {a,b,c} = el.getProps(["a","b","c"])) would make
      // positioners inefficient in the normal case (i.e. not the final values)
      // and the code a bit ugly, so let's use a Proxy instead.
      proxy = new Proxy(label._el, {get: (el, p) => el.getProps([p], true)[p]});

      geometry = label.geometry();
      center = coordinates(proxy, label.model(), geometry);
      state._box.update(center, geometry, label.rotation());
    }
  }

  // Auto hide overlapping labels
  return collide(labels, function(s0, s1) {
    var h0 = s0._hidable;
    var h1 = s1._hidable;

    if ((h0 && h1) || h1) {
      s1._visible = false;
    } else if (h0) {
      s0._visible = false;
    }
  });
}

var layout = {
  prepare: function(datasets) {
    var labels = [];
    var i, j, ilen, jlen, label;

    for (i = 0, ilen = datasets.length; i < ilen; ++i) {
      for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
        label = datasets[i][j];
        labels.push(label);
        label.$layout = {
          _box: new HitBox(),
          _hidable: false,
          _visible: true,
          _set: i,
          _idx: j
        };
      }
    }

    // TODO New `z` option: labels with a higher z-index are drawn
    // of top of the ones with a lower index. Lowest z-index labels
    // are also discarded first when hiding overlapping labels.
    labels.sort(function(a, b) {
      var sa = a.$layout;
      var sb = b.$layout;

      return sa._idx === sb._idx
        ? sb._set - sa._set
        : sb._idx - sa._idx;
    });

    this.update(labels);

    return labels;
  },

  update: function(labels) {
    var dirty = false;
    var i, ilen, label, model, state;

    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      label = labels[i];
      model = label.model();
      state = label.$layout;
      state._hidable = model && model.display === 'auto';
      state._visible = label.visible();
      dirty |= state._hidable;
    }

    if (dirty) {
      compute(labels);
    }
  },

  lookup: function(labels, point) {
    var i, state;

    // IMPORTANT Iterate in the reverse order since items at the end of
    // the list have an higher z-index, thus should be picked first.

    for (i = labels.length - 1; i >= 0; --i) {
      state = labels[i].$layout;

      if (state && state._visible && state._box.contains(point)) {
        return labels[i];
      }
    }

    return null;
  },

  draw: function(chart, labels) {
    var i, ilen, label, state, geometry, center;

    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      label = labels[i];
      state = label.$layout;

      if (state._visible) {
        geometry = label.geometry();
        center = coordinates(label._el, label.model(), geometry);
        state._box.update(center, geometry, label.rotation());
        label.draw(chart, center);
      }
    }
  }
};

var formatter = function(value) {
  if (isNullOrUndef(value)) {
    return null;
  }

  var label = value;
  var keys, klen, k;
  if (isObject(value)) {
    if (!isNullOrUndef(value.label)) {
      label = value.label;
    } else if (!isNullOrUndef(value.r)) {
      label = value.r;
    } else {
      label = '';
      keys = Object.keys(value);
      for (k = 0, klen = keys.length; k < klen; ++k) {
        label += (k !== 0 ? ', ' : '') + keys[k] + ': ' + value[keys[k]];
      }
    }
  }

  return '' + label;
};

/**
 * IMPORTANT: make sure to also update tests and TypeScript definition
 * files (`/test/specs/defaults.spec.js` and `/types/options.d.ts`)
 */

var defaults = {
  align: 'center',
  anchor: 'center',
  backgroundColor: null,
  borderColor: null,
  borderRadius: 0,
  borderWidth: 0,
  clamp: false,
  clip: false,
  color: undefined,
  display: true,
  font: {
    family: undefined,
    lineHeight: 1.2,
    size: undefined,
    style: undefined,
    weight: null
  },
  formatter: formatter,
  labels: undefined,
  listeners: {},
  offset: 4,
  opacity: 1,
  padding: {
    top: 4,
    right: 4,
    bottom: 4,
    left: 4
  },
  rotation: 0,
  textAlign: 'start',
  textStrokeColor: undefined,
  textStrokeWidth: 0,
  textShadowBlur: 0,
  textShadowColor: undefined
};

/**
 * @see https://github.com/chartjs/Chart.js/issues/4176
 */

var EXPANDO_KEY = '$datalabels';
var DEFAULT_KEY = '$default';

function configure(dataset, options) {
  var override = dataset.datalabels;
  var listeners = {};
  var configs = [];
  var labels, keys;

  if (override === false) {
    return null;
  }
  if (override === true) {
    override = {};
  }

  options = merge({}, [options, override]);
  labels = options.labels || {};
  keys = Object.keys(labels);
  delete options.labels;

  if (keys.length) {
    keys.forEach(function(key) {
      if (labels[key]) {
        configs.push(merge({}, [
          options,
          labels[key],
          {_key: key}
        ]));
      }
    });
  } else {
    // Default label if no "named" label defined.
    configs.push(options);
  }

  // listeners: {<event-type>: {<label-key>: <fn>}}
  listeners = configs.reduce(function(target, config) {
    each(config.listeners || {}, function(fn, event) {
      target[event] = target[event] || {};
      target[event][config._key || DEFAULT_KEY] = fn;
    });

    delete config.listeners;
    return target;
  }, {});

  return {
    labels: configs,
    listeners: listeners
  };
}

function dispatchEvent$1(chart, listeners, label) {
  if (!listeners) {
    return;
  }

  var context = label.$context;
  var groups = label.$groups;
  var callback$1;

  if (!listeners[groups._set]) {
    return;
  }

  callback$1 = listeners[groups._set][groups._key];
  if (!callback$1) {
    return;
  }

  if (callback(callback$1, [context]) === true) {
    // Users are allowed to tweak the given context by injecting values that can be
    // used in scriptable options to display labels differently based on the current
    // event (e.g. highlight an hovered label). That's why we update the label with
    // the output context and schedule a new chart render by setting it dirty.
    chart[EXPANDO_KEY]._dirty = true;
    label.update(context);
  }
}

function dispatchMoveEvents(chart, listeners, previous, label) {
  var enter, leave;

  if (!previous && !label) {
    return;
  }

  if (!previous) {
    enter = true;
  } else if (!label) {
    leave = true;
  } else if (previous !== label) {
    leave = enter = true;
  }

  if (leave) {
    dispatchEvent$1(chart, listeners.leave, previous);
  }
  if (enter) {
    dispatchEvent$1(chart, listeners.enter, label);
  }
}

function handleMoveEvents(chart, event) {
  var expando = chart[EXPANDO_KEY];
  var listeners = expando._listeners;
  var previous, label;

  if (!listeners.enter && !listeners.leave) {
    return;
  }

  if (event.type === 'mousemove') {
    label = layout.lookup(expando._labels, event);
  } else if (event.type !== 'mouseout') {
    return;
  }

  previous = expando._hovered;
  expando._hovered = label;
  dispatchMoveEvents(chart, listeners, previous, label);
}

function handleClickEvents(chart, event) {
  var expando = chart[EXPANDO_KEY];
  var handlers = expando._listeners.click;
  var label = handlers && layout.lookup(expando._labels, event);
  if (label) {
    dispatchEvent$1(chart, handlers, label);
  }
}

var plugin = {
  id: 'datalabels',

  defaults: defaults,

  beforeInit: function(chart) {
    chart[EXPANDO_KEY] = {
      _actives: []
    };
  },

  beforeUpdate: function(chart) {
    var expando = chart[EXPANDO_KEY];
    expando._listened = false;
    expando._listeners = {};     // {<event-type>: {<dataset-index>: {<label-key>: <fn>}}}
    expando._datasets = [];      // per dataset labels: [Label[]]
    expando._labels = [];        // layouted labels: Label[]
  },

  afterDatasetUpdate: function(chart, args, options) {
    var datasetIndex = args.index;
    var expando = chart[EXPANDO_KEY];
    var labels = expando._datasets[datasetIndex] = [];
    var visible = chart.isDatasetVisible(datasetIndex);
    var dataset = chart.data.datasets[datasetIndex];
    var config = configure(dataset, options);
    var elements = args.meta.data || [];
    var ctx = chart.ctx;
    var i, j, ilen, jlen, cfg, key, el, label;

    ctx.save();

    for (i = 0, ilen = elements.length; i < ilen; ++i) {
      el = elements[i];
      el[EXPANDO_KEY] = [];

      if (visible && el && chart.getDataVisibility(i) && !el.skip) {
        for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
          cfg = config.labels[j];
          key = cfg._key;

          label = new Label(cfg, ctx, el, i);
          label.$groups = {
            _set: datasetIndex,
            _key: key || DEFAULT_KEY
          };
          label.$context = {
            active: false,
            chart: chart,
            dataIndex: i,
            dataset: dataset,
            datasetIndex: datasetIndex
          };

          label.update(label.$context);
          el[EXPANDO_KEY].push(label);
          labels.push(label);
        }
      }
    }

    ctx.restore();

    // Store listeners at the chart level and per event type to optimize
    // cases where no listeners are registered for a specific event.
    merge(expando._listeners, config.listeners, {
      merger: function(event, target, source) {
        target[event] = target[event] || {};
        target[event][args.index] = source[event];
        expando._listened = true;
      }
    });
  },

  afterUpdate: function(chart, options) {
    chart[EXPANDO_KEY]._labels = layout.prepare(
      chart[EXPANDO_KEY]._datasets,
      options);
  },

  // Draw labels on top of all dataset elements
  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29
  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32
  afterDatasetsDraw: function(chart) {
    layout.draw(chart, chart[EXPANDO_KEY]._labels);
  },

  beforeEvent: function(chart, args) {
    // If there is no listener registered for this chart, `listened` will be false,
    // meaning we can immediately ignore the incoming event and avoid useless extra
    // computation for users who don't implement label interactions.
    if (chart[EXPANDO_KEY]._listened) {
      var event = args.event;
      switch (event.type) {
      case 'mousemove':
      case 'mouseout':
        handleMoveEvents(chart, event);
        break;
      case 'click':
        handleClickEvents(chart, event);
        break;
      }
    }
  },

  afterEvent: function(chart) {
    var expando = chart[EXPANDO_KEY];
    var previous = expando._actives;
    var actives = expando._actives = chart.getActiveElements();
    var updates = utils.arrayDiff(previous, actives);
    var i, ilen, j, jlen, update, label, labels;

    for (i = 0, ilen = updates.length; i < ilen; ++i) {
      update = updates[i];
      if (update[1]) {
        labels = update[0].element[EXPANDO_KEY] || [];
        for (j = 0, jlen = labels.length; j < jlen; ++j) {
          label = labels[j];
          label.$context.active = (update[1] === 1);
          label.update(label.$context);
        }
      }
    }

    if (expando._dirty || updates.length) {
      layout.update(expando._labels);
      chart.render();
    }

    delete expando._dirty;
  }
};

/**
  * vue-class-component v7.2.6
  * (c) 2015-present Evan You
  * @license MIT
  */

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

// The rational behind the verbose Reflect-feature check below is the fact that there are polyfills
// which add an implementation for Reflect.defineMetadata but not for Reflect.getOwnMetadataKeys.
// Without this check consumers will encounter hard to track down runtime errors.
function reflectionIsSupported() {
  return typeof Reflect !== 'undefined' && Reflect.defineMetadata && Reflect.getOwnMetadataKeys;
}
function copyReflectionMetadata(to, from) {
  forwardMetadata(to, from);
  Object.getOwnPropertyNames(from.prototype).forEach(function (key) {
    forwardMetadata(to.prototype, from.prototype, key);
  });
  Object.getOwnPropertyNames(from).forEach(function (key) {
    forwardMetadata(to, from, key);
  });
}

function forwardMetadata(to, from, propertyKey) {
  var metaKeys = propertyKey ? Reflect.getOwnMetadataKeys(from, propertyKey) : Reflect.getOwnMetadataKeys(from);
  metaKeys.forEach(function (metaKey) {
    var metadata = propertyKey ? Reflect.getOwnMetadata(metaKey, from, propertyKey) : Reflect.getOwnMetadata(metaKey, from);

    if (propertyKey) {
      Reflect.defineMetadata(metaKey, metadata, to, propertyKey);
    } else {
      Reflect.defineMetadata(metaKey, metadata, to);
    }
  });
}

var fakeArray = {
  __proto__: []
};
var hasProto = fakeArray instanceof Array;
function createDecorator(factory) {
  return function (target, key, index) {
    var Ctor = typeof target === 'function' ? target : target.constructor;

    if (!Ctor.__decorators__) {
      Ctor.__decorators__ = [];
    }

    if (typeof index !== 'number') {
      index = undefined;
    }

    Ctor.__decorators__.push(function (options) {
      return factory(options, key, index);
    });
  };
}
function isPrimitive(value) {
  var type = _typeof(value);

  return value == null || type !== 'object' && type !== 'function';
}
function warn(message) {
  if (typeof console !== 'undefined') {
    console.warn('[vue-class-component] ' + message);
  }
}

function collectDataFromConstructor(vm, Component) {
  // override _init to prevent to init as Vue instance
  var originalInit = Component.prototype._init;

  Component.prototype._init = function () {
    var _this = this;

    // proxy to actual vm
    var keys = Object.getOwnPropertyNames(vm); // 2.2.0 compat (props are no longer exposed as self properties)

    if (vm.$options.props) {
      for (var key in vm.$options.props) {
        if (!vm.hasOwnProperty(key)) {
          keys.push(key);
        }
      }
    }

    keys.forEach(function (key) {
      Object.defineProperty(_this, key, {
        get: function get() {
          return vm[key];
        },
        set: function set(value) {
          vm[key] = value;
        },
        configurable: true
      });
    });
  }; // should be acquired class property values


  var data = new Component(); // restore original _init to avoid memory leak (#209)

  Component.prototype._init = originalInit; // create plain data object

  var plainData = {};
  Object.keys(data).forEach(function (key) {
    if (data[key] !== undefined) {
      plainData[key] = data[key];
    }
  });

  if (process.env.NODE_ENV !== 'production') {
    if (!(Component.prototype instanceof Vue__default["default"]) && Object.keys(plainData).length > 0) {
      warn('Component class must inherit Vue or its descendant class ' + 'when class property is used.');
    }
  }

  return plainData;
}

var $internalHooks = ['data', 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeDestroy', 'destroyed', 'beforeUpdate', 'updated', 'activated', 'deactivated', 'render', 'errorCaptured', 'serverPrefetch' // 2.6
];
function componentFactory(Component) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options.name = options.name || Component._componentTag || Component.name; // prototype props.

  var proto = Component.prototype;
  Object.getOwnPropertyNames(proto).forEach(function (key) {
    if (key === 'constructor') {
      return;
    } // hooks


    if ($internalHooks.indexOf(key) > -1) {
      options[key] = proto[key];
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(proto, key);

    if (descriptor.value !== void 0) {
      // methods
      if (typeof descriptor.value === 'function') {
        (options.methods || (options.methods = {}))[key] = descriptor.value;
      } else {
        // typescript decorated data
        (options.mixins || (options.mixins = [])).push({
          data: function data() {
            return _defineProperty({}, key, descriptor.value);
          }
        });
      }
    } else if (descriptor.get || descriptor.set) {
      // computed properties
      (options.computed || (options.computed = {}))[key] = {
        get: descriptor.get,
        set: descriptor.set
      };
    }
  });
  (options.mixins || (options.mixins = [])).push({
    data: function data() {
      return collectDataFromConstructor(this, Component);
    }
  }); // decorate options

  var decorators = Component.__decorators__;

  if (decorators) {
    decorators.forEach(function (fn) {
      return fn(options);
    });
    delete Component.__decorators__;
  } // find super


  var superProto = Object.getPrototypeOf(Component.prototype);
  var Super = superProto instanceof Vue__default["default"] ? superProto.constructor : Vue__default["default"];
  var Extended = Super.extend(options);
  forwardStaticMembers(Extended, Component, Super);

  if (reflectionIsSupported()) {
    copyReflectionMetadata(Extended, Component);
  }

  return Extended;
}
var reservedPropertyNames = [// Unique id
'cid', // Super Vue constructor
'super', // Component options that will be used by the component
'options', 'superOptions', 'extendOptions', 'sealedOptions', // Private assets
'component', 'directive', 'filter'];
var shouldIgnore = {
  prototype: true,
  arguments: true,
  callee: true,
  caller: true
};

function forwardStaticMembers(Extended, Original, Super) {
  // We have to use getOwnPropertyNames since Babel registers methods as non-enumerable
  Object.getOwnPropertyNames(Original).forEach(function (key) {
    // Skip the properties that should not be overwritten
    if (shouldIgnore[key]) {
      return;
    } // Some browsers does not allow reconfigure built-in properties


    var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);

    if (extendedDescriptor && !extendedDescriptor.configurable) {
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(Original, key); // If the user agent does not support `__proto__` or its family (IE <= 10),
    // the sub class properties may be inherited properties from the super class in TypeScript.
    // We need to exclude such properties to prevent to overwrite
    // the component options object which stored on the extended constructor (See #192).
    // If the value is a referenced value (object or function),
    // we can check equality of them and exclude it if they have the same reference.
    // If it is a primitive value, it will be forwarded for safety.

    if (!hasProto) {
      // Only `cid` is explicitly exluded from property forwarding
      // because we cannot detect whether it is a inherited property or not
      // on the no `__proto__` environment even though the property is reserved.
      if (key === 'cid') {
        return;
      }

      var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);

      if (!isPrimitive(descriptor.value) && superDescriptor && superDescriptor.value === descriptor.value) {
        return;
      }
    } // Warn if the users manually declare reserved properties


    if (process.env.NODE_ENV !== 'production' && reservedPropertyNames.indexOf(key) >= 0) {
      warn("Static property name '".concat(key, "' declared on class '").concat(Original.name, "' ") + 'conflicts with reserved property name of Vue internal. ' + 'It may cause unexpected behavior of the component. Consider renaming the property.');
    }

    Object.defineProperty(Extended, key, descriptor);
  });
}

function Component(options) {
  if (typeof options === 'function') {
    return componentFactory(options);
  }

  return function (Component) {
    return componentFactory(Component, options);
  };
}

Component.registerHooks = function registerHooks(keys) {
  $internalHooks.push.apply($internalHooks, _toConsumableArray(keys));
};

(undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

/** @see {@link https://github.com/vuejs/vue-class-component/blob/master/src/reflect.ts} */
var reflectMetadataIsSupported = typeof Reflect !== 'undefined' && typeof Reflect.getMetadata !== 'undefined';
function applyMetadata(options, target, key) {
    if (reflectMetadataIsSupported) {
        if (!Array.isArray(options) &&
            typeof options !== 'function' &&
            !options.hasOwnProperty('type') &&
            typeof options.type === 'undefined') {
            var type = Reflect.getMetadata('design:type', target, key);
            if (type !== Object) {
                options.type = type;
            }
        }
    }
}

/**
 * decorator of a prop
 * @param  options the options for the prop
 * @return PropertyDecorator | void
 */
function Prop(options) {
    if (options === void 0) { options = {}; }
    return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
            (componentOptions.props || (componentOptions.props = {}))[k] = options;
        })(target, key);
    };
}

/**
 * decorator of a watch function
 * @param  path the path or the expression to observe
 * @param  WatchOption
 * @return MethodDecorator
 */
function Watch(path, options) {
    if (options === void 0) { options = {}; }
    var _a = options.deep, deep = _a === void 0 ? false : _a, _b = options.immediate, immediate = _b === void 0 ? false : _b;
    return createDecorator(function (componentOptions, handler) {
        if (typeof componentOptions.watch !== 'object') {
            componentOptions.watch = Object.create(null);
        }
        var watch = componentOptions.watch;
        if (typeof watch[path] === 'object' && !Array.isArray(watch[path])) {
            watch[path] = [watch[path]];
        }
        else if (typeof watch[path] === 'undefined') {
            watch[path] = [];
        }
        watch[path].push({ handler: handler, deep: deep, immediate: immediate });
    });
}

var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames$1(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get$1(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set$1(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection$1(subgroups, this._parents);
}

// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we dont ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}

function selection_selectAll(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection$1(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

function selection_selectChild(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : childMatcher(match)));
}

var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

function selection_selectChildren(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection$1(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant$2(x) {
  return function() {
    return x;
  };
}

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

function selection_data(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant$2(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isnt worried about live collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// dont; wed rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}

function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection$1(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection$1(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  return Array.from(this);
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
      : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove$1 : typeof value === "function"
            ? styleFunction$1
            : styleConstant$1)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction$1
          : textConstant$1)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

var root = [null];

function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection$1([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
      : new Selection$1([[selector]], root);
}

function sourceEvent(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

function pointer(event, node) {
  event = sourceEvent(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

function dragDisable(view) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", noevent, nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

var constant$1 = x => () => x;

function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x, y, dx, dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    subject: {value: subject, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    identifier: {value: identifier, enumerable: true, configurable: true},
    active: {value: active, enumerable: true, configurable: true},
    x: {value: x, enumerable: true, configurable: true},
    y: {value: y, enumerable: true, configurable: true},
    dx: {value: dx, enumerable: true, configurable: true},
    dy: {value: dy, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function drag() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved, nonpassive)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    select(event.view)
      .on("mousemove.drag", mousemoved, nonpassivecapture)
      .on("mouseup.drag", mouseupped, nonpassivecapture);
    dragDisable(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }

  function mousemoved(event) {
    noevent(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }

  function mouseupped(event) {
    select(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent(event);
    gestures.mouse("end", event);
  }

  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
        c = container.call(this, event, d),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        nopropagation(event);
        gesture("start", event, touches[i]);
      }
    }
  }

  function touchmoved(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent(event);
        gesture("drag", event, touches[i]);
      }
    }
  }

  function touchended(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i]);
      }
    }
  }

  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
        p = pointer(touch || event, container), dx, dy,
        s;

    if ((s = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch
      }), d)) == null) return;

    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;

    return function gesture(type, event, touch) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[identifier] = gesture, n = active++; break;
        case "end": delete gestures[identifier], --active; // falls through
        case "drag": p = pointer(touch || event, container), n = active; break;
      }
      dispatch.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event,
          subject: s,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch
        }),
        d
      );
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$1(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant$1(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$1(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$1(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var constant = x => () => x;

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function gamma$1(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var interpolateRgb = (function rgbGamma(y) {
  var color = gamma$1(y);

  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$1.gamma = rgbGamma;

  return rgb$1;
})(1);

function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: interpolateNumber(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var frame = 0, // is an animation frame pending?
    timeout$1 = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout$1) timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return timeout(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber
      : b instanceof color ? interpolateRgb
      : (c = color(b)) ? (b = c, interpolateRgb)
      : interpolateString)(a, b);
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}

function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
}

function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    set(this, id).ease = v;
  };
}

function transition_easeVarying(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}

function transition_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection = selection.prototype.constructor;

function transition_selection() {
  return new Selection(this._groups, this._parents);
}

function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}

function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}

function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

function transition_end() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = set(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function newId() {
  return ++id;
}

var selection_prototype = selection.prototype;

Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

var ChartJsWrapper = /** @class */ (function (_super) {
    __extends(ChartJsWrapper, _super);
    function ChartJsWrapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ChartJsWrapper.prototype.mounted = function () {
        var _this = this;
        this.resetChart();
        this.$nextTick(function () {
            window.addEventListener('resize', _this.windowResized);
        });
        if (this.dragYaxis) {
            var item = select(this.chart.canvas);
            item.call(drag()
                .container(this.chart.canvas)
                .on('start', function (e) { return _this.getElement(e.sourceEvent, _this.chart); })
                .on('drag', function (e) { return _this.updateData(e.sourceEvent, _this.chart); })
                .on('end', function (e) { return _this.dragEndCallback(e.sourceEvent, _this.chart); }));
        }
    };
    ChartJsWrapper.prototype.getElement = function (sourceEvent, chartInstance) {
        var _this = this;
        if (this.draggableDataSet === -1) {
            // eslint-disable-next-line prefer-destructuring
            this.element = chartInstance.getElementsAtEventForMode(sourceEvent, 'nearest', { intersect: true }, false)[0];
        }
        else {
            chartInstance.getElementsAtEventForMode(sourceEvent, 'nearest', { intersect: true }, false).forEach(function (ele) {
                if (ele.datasetIndex === _this.draggableDataSet) {
                    _this.element = ele;
                }
            });
        }
        if (this.element) {
            var datasetIndex = this.element.datasetIndex;
            var datasetMeta = chartInstance.getDatasetMeta(datasetIndex);
            this.yAxisID = datasetMeta.yAxisID;
        }
    };
    ChartJsWrapper.prototype.updateData = function (sourceEvent, chartInstance) {
        if (this.element && this.yAxisID) {
            var curDatasetIndex = this.element.datasetIndex;
            var curIndex = this.element.index;
            var y = void 0;
            if (sourceEvent.touches) {
                y = this.chart.scales[this.yAxisID].getValueForPixel(sourceEvent.touches[0].clientY - chartInstance.canvas.getBoundingClientRect().top);
            }
            else {
                y = this.chart.scales[this.yAxisID].getValueForPixel(sourceEvent.clientY - chartInstance.canvas.getBoundingClientRect().top);
            }
            this.chart.data.datasets[curDatasetIndex].data[curIndex].y = y || 0;
            this.chart.update();
        }
    };
    ChartJsWrapper.prototype.dragEndCallback = function (sourceEvent, chart) {
        var _a, _b;
        if (this.element && this.yAxisID) {
            this.$emit('valueChanged', (_a = this.element) === null || _a === void 0 ? void 0 : _a.index, (_b = this.element) === null || _b === void 0 ? void 0 : _b.datasetIndex, chart);
        }
        this.element = undefined;
        this.yAxisID = undefined;
    };
    ChartJsWrapper.prototype.resetChart = function () {
        var _a;
        if (this.chart) {
            this.chart.destroy();
        }
        var point = (_a = this.options.elements) === null || _a === void 0 ? void 0 : _a.point;
        if (point !== undefined) {
            point.radius = 10;
        }
        this.chart = new Chart(this.$el.firstChild, {
            type: this.type,
            data: this.data,
            options: this.options,
            plugins: this.plugins,
        });
    };
    ChartJsWrapper.prototype.windowResized = function () {
        this.resetChart();
    };
    ChartJsWrapper.prototype.beforeDestroy = function () {
        window.removeEventListener('resize', this.windowResized);
    };
    ChartJsWrapper.prototype.onTypeChanged = function () {
        var _this = this;
        this.$nextTick(function () { return _this.resetChart(); });
    };
    ChartJsWrapper.prototype.onDataChanged = function (newData) {
        this.chart.config.data = newData;
        this.chart.update('none');
    };
    ChartJsWrapper.prototype.onOptionsChanged = function () {
        var _this = this;
        this.$nextTick(function () { return _this.resetChart(); });
    };
    __decorate([
        Prop({ required: true })
    ], ChartJsWrapper.prototype, "type", void 0);
    __decorate([
        Prop({ required: true })
    ], ChartJsWrapper.prototype, "data", void 0);
    __decorate([
        Prop({ required: true })
    ], ChartJsWrapper.prototype, "options", void 0);
    __decorate([
        Prop({ required: true })
    ], ChartJsWrapper.prototype, "plugins", void 0);
    __decorate([
        Prop({ default: false })
    ], ChartJsWrapper.prototype, "dragYaxis", void 0);
    __decorate([
        Prop({ default: 0 })
    ], ChartJsWrapper.prototype, "draggableDataSet", void 0);
    __decorate([
        Watch('type')
    ], ChartJsWrapper.prototype, "onTypeChanged", null);
    __decorate([
        Watch('data')
    ], ChartJsWrapper.prototype, "onDataChanged", null);
    __decorate([
        Watch('options')
    ], ChartJsWrapper.prototype, "onOptionsChanged", null);
    ChartJsWrapper = __decorate([
        Component
    ], ChartJsWrapper);
    return ChartJsWrapper;
}(Vue__default["default"]));

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            const originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            const existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}

const isOldIE = typeof navigator !== 'undefined' &&
    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
function createInjector(context) {
    return (id, style) => addStyle(id, style);
}
let HEAD;
const styles = {};
function addStyle(id, css) {
    const group = isOldIE ? css.media || 'default' : id;
    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });
    if (!style.ids.has(id)) {
        style.ids.add(id);
        let code = css.source;
        if (css.map) {
            // https://developer.chrome.com/devtools/docs/javascript-debugging
            // this makes source maps inside style tags work properly in Chrome
            code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
            // http://stackoverflow.com/a/26603875
            code +=
                '\n/*# sourceMappingURL=data:application/json;base64,' +
                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
                    ' */';
        }
        if (!style.element) {
            style.element = document.createElement('style');
            style.element.type = 'text/css';
            if (css.media)
                style.element.setAttribute('media', css.media);
            if (HEAD === undefined) {
                HEAD = document.head || document.getElementsByTagName('head')[0];
            }
            HEAD.appendChild(style.element);
        }
        if ('styleSheet' in style.element) {
            style.styles.push(code);
            style.element.styleSheet.cssText = style.styles
                .filter(Boolean)
                .join('\n');
        }
        else {
            const index = style.ids.size - 1;
            const textNode = document.createTextNode(code);
            const nodes = style.element.childNodes;
            if (nodes[index])
                style.element.removeChild(nodes[index]);
            if (nodes.length)
                style.element.insertBefore(textNode, nodes[index]);
            else
                style.element.appendChild(textNode);
        }
    }
}

/* script */
const __vue_script__$6 = ChartJsWrapper;

/* template */
var __vue_render__$6 = function () {
  var _vm = this;
  var _h = _vm.$createElement;
  _vm._self._c || _h;
  return _vm._m(0)
};
var __vue_staticRenderFns__$6 = [
  function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "chart-container",
        staticStyle: { position: "relative", height: "100%", width: "100%" },
      },
      [_c("canvas", { attrs: { id: "chart" } })]
    )
  },
];
__vue_render__$6._withStripped = true;

  /* style */
  const __vue_inject_styles__$6 = function (inject) {
    if (!inject) return
    inject("data-v-51b53033_0", { source: "canvas.chartjs {\n  max-width: 100%;\n}\n\n/*# sourceMappingURL=ChartJsWrapper.vue.map */", map: {"version":3,"sources":["D:\\Repositories\\Common\\Vue\\Charting\\src\\components\\ChartJsWrapper.vue","ChartJsWrapper.vue"],"names":[],"mappings":"AAkJA;EACA,eAAA;ACjJA;;AAEA,6CAA6C","file":"ChartJsWrapper.vue","sourcesContent":["<template>\r\n  <div class=\"chart-container\" style=\"position: relative; height:100%; width:100%\">\r\n    <canvas id=\"chart\"></canvas>\r\n  </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport Vue from 'vue';\r\nimport { Component, Prop, Watch } from 'vue-property-decorator';\r\nimport { Chart, ChartData, ChartOptions, ChartType, InteractionItem, Plugin, ScatterDataPoint } from 'chart.js';\r\nimport { drag, select } from 'd3';\r\n\r\n@Component\r\nexport default class ChartJsWrapper extends Vue {\r\n  @Prop({ required: true })\r\n  type!: ChartType;\r\n\r\n  @Prop({ required: true })\r\n  data!: ChartData;\r\n\r\n  @Prop({ required: true })\r\n  options!: ChartOptions;\r\n\r\n  @Prop({ required: true })\r\n  plugins!: Plugin[];\r\n\r\n  @Prop({ default: false })\r\n  dragYaxis!: boolean;\r\n\r\n  @Prop({ default: 0 }) draggableDataSet!: number;\r\n\r\n  mounted() {\r\n    this.resetChart();\r\n\r\n    this.$nextTick(() => {\r\n      window.addEventListener('resize', this.windowResized);\r\n    });\r\n\r\n    if (this.dragYaxis) {\r\n      const item = select<Element, unknown>(this.chart.canvas);\r\n      item.call(\r\n        drag()\r\n          .container(this.chart.canvas)\r\n          .on('start', (e) => this.getElement(e.sourceEvent, this.chart))\r\n          .on('drag', (e) => this.updateData(e.sourceEvent, this.chart))\r\n          .on('end', (e) => this.dragEndCallback(e.sourceEvent, this.chart)),\r\n      );\r\n    }\r\n  }\r\n\r\n  element: InteractionItem | undefined;\r\n\r\n  yAxisID: string | undefined;\r\n\r\n  getElement(sourceEvent: any, chartInstance: Chart): void {\r\n    if (this.draggableDataSet === -1) {\r\n      // eslint-disable-next-line prefer-destructuring\r\n      this.element = chartInstance.getElementsAtEventForMode(sourceEvent, 'nearest', { intersect: true }, false)[0];\r\n    } else {\r\n      chartInstance.getElementsAtEventForMode(sourceEvent, 'nearest', { intersect: true }, false).forEach((ele) => {\r\n        if (ele.datasetIndex === this.draggableDataSet) {\r\n          this.element = ele;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (this.element) {\r\n      const { datasetIndex } = this.element;\r\n      const datasetMeta = chartInstance.getDatasetMeta(datasetIndex);\r\n      this.yAxisID = datasetMeta.yAxisID;\r\n    }\r\n  }\r\n\r\n  updateData(sourceEvent: any, chartInstance: Chart): void {\r\n    if (this.element && this.yAxisID) {\r\n      const curDatasetIndex = this.element.datasetIndex;\r\n      const curIndex = this.element.index;\r\n\r\n      let y: number | undefined;\r\n      if (sourceEvent.touches) {\r\n        y = this.chart.scales[this.yAxisID].getValueForPixel(\r\n          sourceEvent.touches[0].clientY - chartInstance.canvas.getBoundingClientRect().top,\r\n        );\r\n      } else {\r\n        y = this.chart.scales[this.yAxisID].getValueForPixel(\r\n          sourceEvent.clientY - chartInstance.canvas.getBoundingClientRect().top,\r\n        );\r\n      }\r\n      (this.chart.data.datasets[curDatasetIndex].data[curIndex] as ScatterDataPoint).y = y || 0;\r\n      this.chart.update();\r\n    }\r\n  }\r\n\r\n  dragEndCallback(sourceEvent: any, chart: Chart): void {\r\n    if (this.element && this.yAxisID) {\r\n      this.$emit('valueChanged', this.element?.index, this.element?.datasetIndex, chart);\r\n    }\r\n    this.element = undefined;\r\n    this.yAxisID = undefined;\r\n  }\r\n\r\n  chart!: Chart;\r\n\r\n  resetChart() {\r\n    if (this.chart) {\r\n      this.chart.destroy();\r\n    }\r\n    const point = this.options.elements?.point;\r\n    if (point !== undefined) {\r\n      point.radius = 10;\r\n    }\r\n    this.chart = new Chart(this.$el.firstChild as HTMLCanvasElement, {\r\n      type: this.type,\r\n      data: this.data,\r\n      options: this.options,\r\n      plugins: this.plugins,\r\n    });\r\n  }\r\n\r\n  windowResized() {\r\n    this.resetChart();\r\n  }\r\n\r\n  beforeDestroy() {\r\n    window.removeEventListener('resize', this.windowResized);\r\n  }\r\n\r\n  @Watch('type')\r\n  onTypeChanged() {\r\n    this.$nextTick(() => this.resetChart());\r\n  }\r\n\r\n  @Watch('data')\r\n  onDataChanged(newData: ChartData) {\r\n    this.chart.config.data = newData;\r\n    this.chart.update('none');\r\n  }\r\n\r\n  @Watch('options')\r\n  onOptionsChanged() {\r\n    this.$nextTick(() => this.resetChart());\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\">\r\ncanvas.chartjs {\r\n  max-width: 100%;\r\n}\r\n</style>\r\n\r\nfunction drag() { throw new Error('Function not implemented.'); }\r\n","canvas.chartjs {\n  max-width: 100%;\n}\n\n/*# sourceMappingURL=ChartJsWrapper.vue.map */"]}, media: undefined });

  };
  /* scoped */
  const __vue_scope_id__$6 = undefined;
  /* module identifier */
  const __vue_module_identifier__$6 = undefined;
  /* functional template */
  const __vue_is_functional_template__$6 = false;
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$6 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
    __vue_inject_styles__$6,
    __vue_script__$6,
    __vue_scope_id__$6,
    __vue_is_functional_template__$6,
    __vue_module_identifier__$6,
    false,
    createInjector,
    undefined,
    undefined
  );

var DefaultChartData = /** @class */ (function () {
    function DefaultChartData(datasets, labels) {
        this.datasets = datasets;
        this.labels = labels;
    }
    return DefaultChartData;
}());

function CreateDefaultChartPointOptions() {
    return {
        radius: 0,
    };
}

// A list of colors that correspond to the DHS style guide
var DHS_DARK_BLUE = 'rgb(0, 47, 128, 1.0)';
var DHS_LIGHT_BLUE = 'rgb(0, 112, 178, 1.0)';
var DHS_RED = 'rgb(165, 0, 33, 1.0)';
var FIRE_RED = 'rgb(210, 39, 44, 1.0)';
var MEDIUM_GREEN = 'rgb(82, 184, 72, 1.0)';
var VIVID_GREEN = 'rgb(47, 163, 98, 1.0)';
var RED_ORANGE = 'rgb(210, 117, 51, 1.0)';
var ORANGE = 'rgb(255, 150, 0, 1.0)';
var GOLD = 'rgb(255, 204, 18, 1.0)';
var DHS_GREEN = 'rgb(89, 134, 0, 1.0)';
var LIGHT_PINK = 'rgb(234, 153, 145, 1.0)';
var SKY_BLUE = 'rgb(102, 204, 255, 1.0)';
var PURPLE = 'rgb(120, 59, 143, 1.0)';
var PUMPKIN = 'rgb(179, 105, 0, 1.0)';
var LIGHT_YELLOW = 'rgb(255, 255, 102, 1.0)';
var TEAL_GREEN = 'rgb(0, 186, 161, 1.0)';
var BURGANDY = 'rgb(200, 74, 113, 1.0)';
var BNBI_MAROON = 'rgb(120, 51, 69, 1.0)';
var YELLOW_GREEN = 'rgb(207, 224, 111, 1.0)';
var OCHRE_BROWN = 'rgb(199, 157, 0, 1.0)';
var LIGHT_OCHRE = 'rgb(253, 234, 145, 1.0)';
var DARK_GRAY = 'rgb(77, 77, 77, 1.0)';
var BLACK = 'rgb(0, 0, 0, 1.0))';
var COLOR_ARRAY = [
    DHS_LIGHT_BLUE,
    DHS_RED,
    MEDIUM_GREEN,
    ORANGE,
    GOLD,
    FIRE_RED,
    VIVID_GREEN,
    RED_ORANGE,
    ORANGE,
    GOLD,
    DHS_GREEN,
    LIGHT_PINK,
    SKY_BLUE,
    PURPLE,
    PUMPKIN,
    LIGHT_YELLOW,
    TEAL_GREEN,
    BURGANDY,
    BNBI_MAROON,
    YELLOW_GREEN,
    OCHRE_BROWN,
    LIGHT_OCHRE,
];
// Same colors as above just a semi-transparent version
var DHS_LIGHT_BLUE_T = 'rgba(0, 112, 178, 0.6)';
var DHS_RED_T = 'rgba(165, 0, 33, 0.6)';
var FIRE_RED_T = 'rgba(210, 39, 44, 0.6)';
var MEDIUM_GREEN_T = 'rgba(82, 184, 72, 0.6)';
var VIVID_GREEN_T = 'rgba(47, 163, 98, 0.6)';
var RED_ORANGE_T = 'rgba(210, 117, 51, 0.6)';
var ORANGE_T = 'rgba(255, 150, 0, 0.6)';
var GOLD_T = 'rgba(255, 204, 18, 0.6)';
var DHS_GREEN_T = 'rgba(89, 134, 0, 0.6)';
var LIGHT_PINK_T = 'rgba(234, 153, 145, 0.6)';
var SKY_BLUE_T = 'rgba(102, 204, 255, 0.6)';
var PURPLE_T = 'rgba(120, 59, 143, 0.6)';
var PUMPKIN_T = 'rgba(179, 105, 0, 0.6)';
var LIGHT_YELLOW_T = 'rgba(255, 255, 102, 0.6)';
var TEAL_GREEN_T = 'rgba(0, 186, 161, 0.6)';
var BURGANDY_T = 'rgba(200, 74, 113, 0.6)';
var BNBI_MAROON_T = 'rgba(120, 51, 69, 0.6)';
var YELLOW_GREEN_T = 'rgba(207, 224, 111, 0.6)';
var OCHRE_BROWN_T = 'rgba(199, 157, 0, 0.6)';
var LIGHT_OCHRE_T = 'rgba(253, 234, 145, 0.6)';
var DARK_GRAY_T = 'rgb(77, 77, 77, 0.6)';
var BLACK_T = 'rgb(0, 0, 0, 0.6))';
var COLOR_ARRAY_T = [
    DHS_LIGHT_BLUE_T,
    DHS_RED_T,
    MEDIUM_GREEN_T,
    ORANGE_T,
    GOLD_T,
    FIRE_RED_T,
    VIVID_GREEN_T,
    RED_ORANGE_T,
    ORANGE_T,
    GOLD_T,
    DHS_GREEN_T,
    LIGHT_PINK_T,
    SKY_BLUE_T,
    PURPLE_T,
    PUMPKIN_T,
    LIGHT_YELLOW_T,
    TEAL_GREEN_T,
    BURGANDY_T,
    BNBI_MAROON_T,
    YELLOW_GREEN_T,
    OCHRE_BROWN_T,
    LIGHT_OCHRE_T,
];
var PARAM_COLORS = [DHS_DARK_BLUE, VIVID_GREEN, ORANGE, BURGANDY, DHS_GREEN, PURPLE, SKY_BLUE];

var colors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHS_DARK_BLUE: DHS_DARK_BLUE,
    DHS_LIGHT_BLUE: DHS_LIGHT_BLUE,
    DHS_RED: DHS_RED,
    FIRE_RED: FIRE_RED,
    MEDIUM_GREEN: MEDIUM_GREEN,
    VIVID_GREEN: VIVID_GREEN,
    RED_ORANGE: RED_ORANGE,
    ORANGE: ORANGE,
    GOLD: GOLD,
    DHS_GREEN: DHS_GREEN,
    LIGHT_PINK: LIGHT_PINK,
    SKY_BLUE: SKY_BLUE,
    PURPLE: PURPLE,
    PUMPKIN: PUMPKIN,
    LIGHT_YELLOW: LIGHT_YELLOW,
    TEAL_GREEN: TEAL_GREEN,
    BURGANDY: BURGANDY,
    BNBI_MAROON: BNBI_MAROON,
    YELLOW_GREEN: YELLOW_GREEN,
    OCHRE_BROWN: OCHRE_BROWN,
    LIGHT_OCHRE: LIGHT_OCHRE,
    DARK_GRAY: DARK_GRAY,
    BLACK: BLACK,
    COLOR_ARRAY: COLOR_ARRAY,
    DHS_LIGHT_BLUE_T: DHS_LIGHT_BLUE_T,
    DHS_RED_T: DHS_RED_T,
    FIRE_RED_T: FIRE_RED_T,
    MEDIUM_GREEN_T: MEDIUM_GREEN_T,
    VIVID_GREEN_T: VIVID_GREEN_T,
    RED_ORANGE_T: RED_ORANGE_T,
    ORANGE_T: ORANGE_T,
    GOLD_T: GOLD_T,
    DHS_GREEN_T: DHS_GREEN_T,
    LIGHT_PINK_T: LIGHT_PINK_T,
    SKY_BLUE_T: SKY_BLUE_T,
    PURPLE_T: PURPLE_T,
    PUMPKIN_T: PUMPKIN_T,
    LIGHT_YELLOW_T: LIGHT_YELLOW_T,
    TEAL_GREEN_T: TEAL_GREEN_T,
    BURGANDY_T: BURGANDY_T,
    BNBI_MAROON_T: BNBI_MAROON_T,
    YELLOW_GREEN_T: YELLOW_GREEN_T,
    OCHRE_BROWN_T: OCHRE_BROWN_T,
    LIGHT_OCHRE_T: LIGHT_OCHRE_T,
    DARK_GRAY_T: DARK_GRAY_T,
    BLACK_T: BLACK_T,
    COLOR_ARRAY_T: COLOR_ARRAY_T,
    PARAM_COLORS: PARAM_COLORS
});

var ChartTitleDefaultSettings = {
    align: 'center',
    display: false,
    position: 'top',
    fullSize: false,
    font: {
        size: 18,
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        style: 'normal',
        weight: 'normal',
        lineHeight: 1.2,
    },
    color: DARK_GRAY,
    padding: 10.0,
    text: '',
};
function CreateDefaultTitleOptions() {
    return ChartTitleDefaultSettings;
}

var ChartTooltipOptionsDefaultSettings = {
    enabled: false,
    mode: 'point',
    intersect: false,
    backgroundColor: DARK_GRAY_T,
    padding: 10.0,
    caretSize: 0.0,
    cornerRadius: 10.0,
};
function CreateDefaultTooltipOptions() {
    return ChartTooltipOptionsDefaultSettings;
}

function CreateDefaultChartOptions() {
    var chartOptions = {
        maintainAspectRatio: false,
        responsive: true,
        events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
        animation: {
            duration: 0.0,
        },
        elements: {
            point: CreateDefaultChartPointOptions(),
        },
        plugins: {
            datalabels: {
                display: false,
            },
            title: CreateDefaultTitleOptions(),
            tooltip: CreateDefaultTooltipOptions(),
            zoom: {
                zoom: {
                    wheel: {
                        enabled: true,
                    },
                    pinch: {
                        enabled: true,
                    },
                    mode: 'xy',
                },
            },
        },
    };
    return chartOptions;
}

var EmptyChartData = {
    datasets: [],
};

var EmptyChartOptions = {};

var ConstantPointStyleProvider = /** @class */ (function () {
    function ConstantPointStyleProvider(type) {
        this.type = type;
    }
    ConstantPointStyleProvider.prototype.getNextStyle = function () {
        return this.type;
    };
    return ConstantPointStyleProvider;
}());

var CycleColorProvider = /** @class */ (function () {
    function CycleColorProvider(colorChoices) {
        this.currentColor = -1;
        this.colorChoices = colorChoices !== null && colorChoices !== void 0 ? colorChoices : COLOR_ARRAY_T;
        if (this.colorChoices.length <= 0) {
            this.colorChoices.push('rgb(1,1,1)');
        }
    }
    CycleColorProvider.prototype.getNextColor = function () {
        this.currentColor += 1;
        if (this.currentColor >= this.colorChoices.length) {
            this.currentColor = 0;
        }
        return this.colorChoices[this.currentColor];
    };
    return CycleColorProvider;
}());

// needed for iteration by CyclePointStyleProvider
var PointStyleType;
(function (PointStyleType) {
    PointStyleType["Circle"] = "circle";
    PointStyleType["Cross"] = "cross";
    PointStyleType["CrossRot"] = "crossRot";
    PointStyleType["Dash"] = "dash";
    PointStyleType["Line"] = "line";
    PointStyleType["Rect"] = "rect";
    PointStyleType["RectRounded"] = "rectRounded";
    PointStyleType["RectRot"] = "rectRot";
    PointStyleType["Star"] = "star";
    PointStyleType["Triangle"] = "triangle";
})(PointStyleType || (PointStyleType = {}));
var PointStyleType$1 = PointStyleType;

var CyclePointStyleProvider = /** @class */ (function () {
    function CyclePointStyleProvider(styles) {
        this.current = -1;
        this.styles = styles !== null && styles !== void 0 ? styles : Object.values(PointStyleType$1);
        if (this.styles.length === 0) {
            this.styles.push('circle');
        }
    }
    CyclePointStyleProvider.prototype.getNextStyle = function () {
        this.current += 1;
        if (this.current >= this.styles.length) {
            this.current = 0;
        }
        return this.styles[this.current];
    };
    return CyclePointStyleProvider;
}());

var ScatterChartDatasetDefaultSettings = {
    cubicInterpolationMode: 'default',
    pointRadius: 6.0,
    tension: 0.0,
    pointStyle: 'circle',
    hidden: false,
    showLine: true,
};
function CreateScatterChartDataset(data, label, colorProvider, pointStyleProvider, backgroundColor, borderColor) {
    var pointStyle = pointStyleProvider !== null && pointStyleProvider !== void 0 ? pointStyleProvider : new ConstantPointStyleProvider(ScatterChartDatasetDefaultSettings.pointStyle);
    var lineColor = colorProvider.getNextColor();
    var dataset = {
        data: data,
        label: label,
        backgroundColor: backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : lineColor,
        borderColor: borderColor !== null && borderColor !== void 0 ? borderColor : lineColor,
        pointStyle: pointStyle.getNextStyle(),
        cubicInterpolationMode: ScatterChartDatasetDefaultSettings.cubicInterpolationMode,
        pointRadius: ScatterChartDatasetDefaultSettings.pointRadius,
        tension: ScatterChartDatasetDefaultSettings.tension,
        hidden: ScatterChartDatasetDefaultSettings.hidden,
        showLine: ScatterChartDatasetDefaultSettings.showLine,
    };
    return dataset;
}

var ScatterPlotWrapper = /** @class */ (function (_super) {
    __extends(ScatterPlotWrapper, _super);
    function ScatterPlotWrapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Prop({ required: true })
    ], ScatterPlotWrapper.prototype, "data", void 0);
    __decorate([
        Prop({ default: 'line' })
    ], ScatterPlotWrapper.prototype, "type", void 0);
    __decorate([
        Prop({
            default: function () {
                return CreateDefaultChartOptions();
            },
        })
    ], ScatterPlotWrapper.prototype, "options", void 0);
    __decorate([
        Prop({
            default: function () {
                return [];
            },
        })
    ], ScatterPlotWrapper.prototype, "plugins", void 0);
    ScatterPlotWrapper = __decorate([
        Component({ components: { ChartJsWrapper: __vue_component__$6 } })
    ], ScatterPlotWrapper);
    return ScatterPlotWrapper;
}(Vue__default["default"]));

/* script */
const __vue_script__$5 = ScatterPlotWrapper;

/* template */
var __vue_render__$5 = function () {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("chart-js-wrapper", {
    attrs: {
      data: _vm.data,
      type: _vm.type,
      options: _vm.options,
      plugins: _vm.plugins,
    },
  })
};
var __vue_staticRenderFns__$5 = [];
__vue_render__$5._withStripped = true;

  /* style */
  const __vue_inject_styles__$5 = function (inject) {
    if (!inject) return
    inject("data-v-40c9dd6e_0", { source: ".disabled-tool-tip[data-v-40c9dd6e] {\n  cursor: no-drop;\n}\n\n/*# sourceMappingURL=ScatterPlotWrapper.vue.map */", map: {"version":3,"sources":["D:\\Repositories\\Common\\Vue\\Charting\\src\\components\\ScatterPlotWrapper.vue","ScatterPlotWrapper.vue"],"names":[],"mappings":"AAmCA;EACA,eAAA;AClCA;;AAEA,iDAAiD","file":"ScatterPlotWrapper.vue","sourcesContent":["<template>\r\n  <chart-js-wrapper :data=\"data\" :type=\"type\" :options=\"options\" :plugins=\"plugins\" />\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport Vue from 'vue';\r\nimport { Component, Prop } from 'vue-property-decorator';\r\nimport { ChartData, ChartOptions, ChartType, Plugin } from 'chart.js';\r\nimport ChartJsWrapper from './ChartJsWrapper.vue';\r\nimport { CreateDefaultChartOptions } from '../implementations';\r\n\r\n@Component({ components: { ChartJsWrapper } })\r\nexport default class ScatterPlotWrapper extends Vue {\r\n  @Prop({ required: true })\r\n  data!: ChartData;\r\n\r\n  @Prop({ default: 'line' })\r\n  type!: ChartType;\r\n\r\n  @Prop({\r\n    default: () => {\r\n      return CreateDefaultChartOptions();\r\n    },\r\n  })\r\n  options!: ChartOptions;\r\n\r\n  @Prop({\r\n    default: () => {\r\n      return [];\r\n    },\r\n  })\r\n  plugins!: Plugin[];\r\n}\r\n</script>\r\n<style scoped lang=\"scss\">\r\n.disabled-tool-tip {\r\n  cursor: no-drop;\r\n}\r\n</style>\r\n",".disabled-tool-tip {\n  cursor: no-drop;\n}\n\n/*# sourceMappingURL=ScatterPlotWrapper.vue.map */"]}, media: undefined });

  };
  /* scoped */
  const __vue_scope_id__$5 = "data-v-40c9dd6e";
  /* module identifier */
  const __vue_module_identifier__$5 = undefined;
  /* functional template */
  const __vue_is_functional_template__$5 = false;
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$5 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5,
    __vue_module_identifier__$5,
    false,
    createInjector,
    undefined,
    undefined
  );

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = ms;
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

var common$1 = setup;

var browser = createCommonjsModule(function (module, exports) {
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = common$1(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};
});

var hasFlag = (flag, argv) => {
	argv = argv || process.argv;
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const pos = argv.indexOf(prefix + flag);
	const terminatorPos = argv.indexOf('--');
	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};

const env = process.env;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false')) {
	forceColor = false;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = true;
}
if ('FORCE_COLOR' in env) {
	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(stream) {
	if (forceColor === false) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (stream && !stream.isTTY && forceColor !== true) {
		return 0;
	}

	const min = forceColor ? 1 : 0;

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors. Windows 10 build 14931 is the first release
		// that supports 16m/TrueColor.
		const osRelease = os__default["default"].release().split('.');
		if (
			Number(process.versions.node.split('.')[0]) >= 8 &&
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return min;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream);
	return translateLevel(level);
}

var supportsColor_1 = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel(process.stdout),
	stderr: getSupportLevel(process.stderr)
};

var node = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */




/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util__default["default"].deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = supportsColor_1;

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty__default["default"].isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util__default["default"].format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = common$1(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util__default["default"].inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util__default["default"].inspect(v, this.inspectOpts);
};
});

var src = createCommonjsModule(function (module) {
/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = browser;
} else {
	module.exports = node;
}
});

var _general = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.R_D_qIv = exports.R_Q_P01_check = exports.R_Q_P01_boundaries = exports.R_D_log = exports.ldexp = exports.R_powV = exports.myfmod = exports.R_isnancpp = exports.R_finite = exports.R_pow = exports.R_pow_di = exports.M_eps_sinc = exports.sqxmin_BESS_K = exports.xmax_BESS_K = exports.thresh_BESS_Y = exports.xlrg_BESS_Y = exports.xlrg_BESS_IJ = exports.exparg_BESS = exports.enten_BESS = exports.enmten_BESS = exports.rtnsig_BESS = exports.ensig_BESS = exports.nsig_BESS = exports.R_D_fexp = exports.R_nonint = exports.R_D_negInonint = exports.isEpsilonNear = exports.epsilonNear = exports.isOdd = exports.imax2 = exports.fmod = exports.R_D_nonint_check = exports.ML_ERR_return_NAN = exports.ML_ERROR = exports.mapErr = exports.ME = exports.R_D_exp = exports.R_P_bounds_01 = exports.R_D_half = exports.R_P_bounds_Inf_01 = exports.R_D_Cval = exports.R_D_Lval = exports.imin2 = exports.R_DT_val = exports.R_D_Clog = exports.R_D_val = exports.R_DT_1 = exports.R_DT_0 = exports.R_D__0 = exports.R_D__1 = exports.DBL_MIN_EXP = exports.DBL_MAX_EXP = exports.M_LOG10_2 = exports.M_SQRT_2dPI = exports.M_LN_SQRT_PId2 = exports.M_LN_SQRT_2PI = exports.M_LN_SQRT_PI = exports.M_PI_2 = exports.M_1_PI = exports.M_LN_2PI = exports.M_2PI = exports.M_1_SQRT_2PI = exports.M_LN2 = exports.DBL_MANT_DIG = exports.M_SQRT_32 = exports.frac = exports.M_SQRT2 = void 0;

const debug_R_Q_P01_boundaries = src('R_Q_P01_boundaries');
const debug_R_Q_P01_check = src('R_Q_P01_check');
exports.M_SQRT2 = 1.41421356237309504880168872421;
exports.frac = (x) => x - Math.trunc(x);
exports.M_SQRT_32 = 5.656854249492380195206754896838;
exports.DBL_MANT_DIG = 18;
exports.M_LN2 = 0.693147180559945309417232121458;
exports.M_1_SQRT_2PI = 0.398942280401432677939946059934;
exports.M_2PI = 6.283185307179586476925286766559;
exports.M_LN_2PI = 1.837877066409345483560659472811;
exports.M_1_PI = 1.0 / Math.PI;
exports.M_PI_2 = Math.PI / 2;
exports.M_LN_SQRT_PI = 0.57236494292470008;
exports.M_LN_SQRT_2PI = 0.918938533204672741780329736406;
exports.M_LN_SQRT_PId2 = 0.225791352644727432363097614947;
exports.M_SQRT_2dPI = 0.797884560802865355879892119869;
exports.M_LOG10_2 = 0.301029995663981195213738894724;
exports.DBL_MAX_EXP = Math.log2(Number.MAX_VALUE);
exports.DBL_MIN_EXP = Math.log2(Number.MIN_VALUE);
exports.R_D__1 = (logP) => {
    return logP ? 0 : 1.0;
};
exports.R_D__0 = (logP) => {
    return logP ? Number.NEGATIVE_INFINITY : 0.0;
};
exports.R_DT_0 = (lower_tail, log_p) => {
    return lower_tail ? exports.R_D__0(log_p) : exports.R_D__1(log_p);
};
exports.R_DT_1 = (lower_tail, log_p) => {
    return lower_tail ? exports.R_D__1(log_p) : exports.R_D__0(log_p);
};
exports.R_D_val = (log_p, x) => {
    return log_p ? Math.log(x) : x;
};
function R_D_Clog(log_p, p) {
    return log_p ? Math.log1p(-p) : 0.5 - p + 0.5;
}
exports.R_D_Clog = R_D_Clog;
function R_DT_val(lower_tail, log_p, x) {
    return lower_tail ? exports.R_D_val(log_p, x) : R_D_Clog(log_p, x);
}
exports.R_DT_val = R_DT_val;
function imin2(x, y) {
    return Math.trunc(Math.min(x, y));
}
exports.imin2 = imin2;
function R_D_Lval(lowerTail, p) {
    return lowerTail ? p : 1 - p;
}
exports.R_D_Lval = R_D_Lval;
function R_D_Cval(lowerTail, p) {
    return lowerTail ? 1 - p : p;
}
exports.R_D_Cval = R_D_Cval;
function R_P_bounds_Inf_01(lowerTail, log_p, x) {
    if (!Number.isFinite(x)) {
        if (x > 0) {
            return exports.R_DT_1(lowerTail, log_p);
        }
        return exports.R_DT_0(lowerTail, log_p);
    }
    return undefined;
}
exports.R_P_bounds_Inf_01 = R_P_bounds_Inf_01;
function R_D_half(log_p) {
    return log_p ? -exports.M_LN2 : 0.5;
}
exports.R_D_half = R_D_half;
function R_P_bounds_01(lower_tail, log_p, x, x_min, x_max) {
    if (x <= x_min)
        return exports.R_DT_0(lower_tail, log_p);
    if (x >= x_max)
        return exports.R_DT_1(lower_tail, log_p);
    return undefined;
}
exports.R_P_bounds_01 = R_P_bounds_01;
exports.R_D_exp = (log_p, x) => {
    return log_p ? x : Math.exp(x);
};
var ME;
(function (ME) {
    ME[ME["ME_NONE"] = 0] = "ME_NONE";
    ME[ME["ME_DOMAIN"] = 1] = "ME_DOMAIN";
    ME[ME["ME_RANGE"] = 2] = "ME_RANGE";
    ME[ME["ME_NOCONV"] = 4] = "ME_NOCONV";
    ME[ME["ME_PRECISION"] = 8] = "ME_PRECISION";
    ME[ME["ME_UNDERFLOW"] = 16] = "ME_UNDERFLOW";
})(ME = exports.ME || (exports.ME = {}));
exports.mapErr = new Map([
    [ME.ME_NONE, 'No error'],
    [ME.ME_DOMAIN, "argument out of domain in '%s'"],
    [ME.ME_RANGE, "argument out of domain in '%s'"],
    [ME.ME_NOCONV, "convergence failed in '%s'"],
    [ME.ME_PRECISION, "full precision may not have been achieved in '%s'"],
    [ME.ME_UNDERFLOW, "underflow occurred in '%s'"]
]);
exports.ML_ERROR = (x, s, printer) => {
    const str = exports.mapErr.get(x);
    if (str) {
        printer(str, s);
    }
};
function ML_ERR_return_NAN(printer) {
    exports.ML_ERROR(ME.ME_DOMAIN, '', printer);
    return Number.NaN;
}
exports.ML_ERR_return_NAN = ML_ERR_return_NAN;
function R_D_nonint_check(log, x, printer) {
    if (R_nonint(x)) {
        printer('non-integer x = %d', x);
        return exports.R_D__0(log);
    }
    return undefined;
}
exports.R_D_nonint_check = R_D_nonint_check;
function fmod(x, y) {
    return x - Math.trunc(x / y) * y;
}
exports.fmod = fmod;
function imax2(x, y) {
    return Math.trunc(Math.max(x, y));
}
exports.imax2 = imax2;
function isOdd(k) {
    return Math.floor(k) % 2 === 1;
}
exports.isOdd = isOdd;
function epsilonNear(x, target) {
    if (Number.isNaN(x))
        return x;
    if (!isFinite(x))
        return x;
    if (Number.isNaN(target))
        return x;
    if (!isFinite(target))
        return x;
    let diff = x - target;
    if (diff > Number.EPSILON || diff < -Number.EPSILON) {
        return x;
    }
    return target;
}
exports.epsilonNear = epsilonNear;
function isEpsilonNear(x, target) {
    if (isFinite(x) && isFinite(target))
        return epsilonNear(x, target) === target;
    return false;
}
exports.isEpsilonNear = isEpsilonNear;
function R_D_negInonint(x) {
    return x < 0.0 || R_nonint(x);
}
exports.R_D_negInonint = R_D_negInonint;
function R_nonint(x) {
    return !Number.isInteger(x);
}
exports.R_nonint = R_nonint;
function R_D_fexp(give_log, f, x) {
    return give_log ? -0.5 * Math.log(f) + x : Math.exp(x) / Math.sqrt(f);
}
exports.R_D_fexp = R_D_fexp;
exports.nsig_BESS = 16;
exports.ensig_BESS = 1e16;
exports.rtnsig_BESS = 1e-4;
exports.enmten_BESS = 8.9e-308;
exports.enten_BESS = 1e308;
exports.exparg_BESS = 709;
exports.xlrg_BESS_IJ = 1e5;
exports.xlrg_BESS_Y = 1e8;
exports.thresh_BESS_Y = 16;
exports.xmax_BESS_K = 705.342;
exports.sqxmin_BESS_K = 1.49e-154;
exports.M_eps_sinc = 2.149e-8;
function R_pow_di(x, n) {
    let pow = 1.0;
    if (Number.isNaN(x))
        return x;
    if (n !== 0) {
        if (!Number.isFinite(x))
            return R_pow(x, n);
        if (n < 0) {
            n = -n;
            x = 1 / x;
        }
        while (true) {
            if (n & 1)
                pow *= x;
            if ((n >>= 1))
                x *= x;
            else
                break;
        }
    }
    return pow;
}
exports.R_pow_di = R_pow_di;
function R_pow(x, y) {
    if (y === 2.0)
        return x * x;
    if (x === 1 || y === 0)
        return 1;
    if (x === 0) {
        if (y > 0)
            return 0;
        else if (y < 0)
            return Number.POSITIVE_INFINITY;
        else
            return y;
    }
    if (Number.isFinite(x) && Number.isFinite(y)) {
        return Math.pow(x, y);
    }
    if (Number.isNaN(x) || Number.isNaN(y))
        return x + y;
    if (!Number.isFinite(x)) {
        if (x > 0)
            return y < 0 ? 0 : Number.POSITIVE_INFINITY;
        else {
            if (Number.isFinite(y) && y === Math.floor(y))
                return y < 0 ? 0 : myfmod(y, 2) ? x : -x;
        }
    }
    if (!Number.isFinite(y)) {
        if (x >= 0) {
            if (y > 0)
                return x >= 1 ? Number.POSITIVE_INFINITY : 0;
            else
                return x < 1 ? Number.POSITIVE_INFINITY : 0;
        }
    }
    return NaN;
}
exports.R_pow = R_pow;
exports.R_finite = (x) => !Number.isFinite(x);
exports.R_isnancpp = (x) => Number.isNaN(x);
function myfmod(x1, x2) {
    let q = x1 / x2;
    return x1 - Math.floor(q) * x2;
}
exports.myfmod = myfmod;
function R_powV(x, y) {
    if (x === 1 || y === 0)
        return 1;
    if (x === 0) {
        if (y > 0)
            return 0;
        return Number.POSITIVE_INFINITY;
    }
    if (Number.isFinite(x) && Number.isFinite(y))
        return Math.pow(x, y);
    if (Number.isNaN(x) || Number.isNaN(y)) {
        return x + y;
    }
    if (!Number.isFinite(x)) {
        if (x > 0)
            return y < 0 ? 0 : Number.POSITIVE_INFINITY;
        else {
            if (Number.isFinite(y) && y === Math.floor(y))
                return y < 0 ? 0 : myfmod(y, 2) ? x : -x;
        }
    }
    if (!Number.isFinite(y)) {
        if (x >= 0) {
            if (y > 0)
                return x >= 1 ? Number.POSITIVE_INFINITY : 0;
            else
                return x < 1 ? Number.POSITIVE_INFINITY : 0;
        }
    }
    return NaN;
}
exports.R_powV = R_powV;
function ldexp(x, y) {
    if (Number.isNaN(x) || Number.isNaN(y)) {
        return x + y;
    }
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
        return Number.POSITIVE_INFINITY;
    }
    return x * Math.pow(2, y);
}
exports.ldexp = ldexp;
function R_D_log(log_p, p) {
    return log_p ? p : Math.log(p);
}
exports.R_D_log = R_D_log;
function R_Q_P01_boundaries(lower_tail, log_p, p, _LEFT_, _RIGHT_) {
    if (log_p) {
        if (p > 0) {
            return ML_ERR_return_NAN(debug_R_Q_P01_boundaries);
        }
        if (p === 0)
            return lower_tail ? _RIGHT_ : _LEFT_;
        if (p === Number.NEGATIVE_INFINITY)
            return lower_tail ? _LEFT_ : _RIGHT_;
    }
    else {
        if (p < 0 || p > 1) {
            return ML_ERR_return_NAN(debug_R_Q_P01_boundaries);
        }
        if (p === 0)
            return lower_tail ? _LEFT_ : _RIGHT_;
        if (p === 1)
            return lower_tail ? _RIGHT_ : _LEFT_;
    }
    return undefined;
}
exports.R_Q_P01_boundaries = R_Q_P01_boundaries;
function R_Q_P01_check(logP, p) {
    if ((logP && p > 0) || (!logP && (p < 0 || p > 1))) {
        return ML_ERR_return_NAN(debug_R_Q_P01_check);
    }
    return undefined;
}
exports.R_Q_P01_check = R_Q_P01_check;
function R_D_qIv(logP, p) {
    return logP ? Math.exp(p) : p;
}
exports.R_D_qIv = R_D_qIv;

});

var chebyshev$1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.chebyshev_eval = exports.chebyshev_init = void 0;


const { abs: fabs } = Math;
const printer = src('chebyshev_eval');
function chebyshev_init(dos, nos, eta) {
    let retCode = 0;
    let err;
    if (nos < 1)
        return 0;
    err = 0.0;
    for (let ii = 1; ii <= nos; ii++) {
        retCode = nos - ii;
        err += fabs(dos[retCode]);
        if (err > eta) {
            return retCode;
        }
    }
    return retCode;
}
exports.chebyshev_init = chebyshev_init;
function chebyshev_eval(x, a, n) {
    let b0;
    let b1;
    let b2;
    let twox;
    let i;
    if (n < 1 || n > 1000) {
        return _general.ML_ERR_return_NAN(printer);
    }
    if (x < -1.1 || x > 1.1) {
        return _general.ML_ERR_return_NAN(printer);
    }
    twox = x * 2;
    b2 = b1 = 0;
    b0 = 0;
    for (i = 1; i <= n; i++) {
        b2 = b1;
        b1 = b0;
        b0 = twox * b1 - b2 + a[n - i];
    }
    return (b0 - b2) * 0.5;
}
exports.chebyshev_eval = chebyshev_eval;

});

var rFunc = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Welch_Satterthwaite = exports.summary = exports.mult = exports.div = exports.sum = exports.any = exports.numberPrecision = exports.each = exports.map = exports.multiplexer = exports.possibleScalar = exports.asArray = exports.multiplex = exports.arrayrify = exports.flatten = exports.selector = exports.seq = exports.isOdd = void 0;
const { abs, sign, floor, trunc, max } = Math;
const { isNaN } = Number;
const { isArray } = Array;

const printer_seq = src("seq");
const precision9 = numberPrecision(9);
function isOdd(n) {
    if (isFinite(n)) {
        return floor(n / 2) * 2 < n;
    }
    throw new Error(`Not a finite Number: ${n}`);
}
exports.isOdd = isOdd;
exports.seq = (adjust = 0) => (adjustMin = adjust) => (start, end, step = 1) => {
    if (end === undefined) {
        if (start <= 0 || start === undefined) {
            return [];
        }
        end = 1;
    }
    let s = start + adjust;
    let e = end + adjust;
    let cursor = s;
    if (end < start) {
        e = start + adjustMin;
        s = end + adjustMin;
        cursor = e;
    }
    step = abs(step) * sign(end - start);
    printer_seq("step:%d", step);
    const rc = [];
    do {
        rc.push(cursor);
        cursor += step;
    } while (precision9(cursor) >= s && precision9(cursor) <= e && step !== 0);
    return precision9(rc);
};
function selector(...rest) {
    const flat = flatten(rest);
    return (val, idx) => {
        return flat.indexOf(idx) >= 0;
    };
}
exports.selector = selector;
function flatten(...rest) {
    let rc = [];
    for (const itm of rest) {
        if (isArray(itm)) {
            let rc2 = flatten(...itm);
            rc.push(...rc2);
            continue;
        }
        rc.push(itm);
    }
    return rc;
}
exports.flatten = flatten;
function arrayrify(fn) {
    return function (x, ...rest) {
        const fp = Array.isArray(x) ? x : [x];
        const result = fp.map(p => fn(p, ...rest));
        return result.length === 1 ? result[0] : result;
    };
}
exports.arrayrify = arrayrify;
function multiplex(fn) {
    return function (...rest) {
        return multiplexer(...rest)(fn);
    };
}
exports.multiplex = multiplex;
function asArray(fn) {
    return function (...rest) {
        const ans = fn(...rest);
        return Array.isArray(ans) ? ans : [ans];
    };
}
exports.asArray = asArray;
function possibleScalar(x) {
    return x.length === 1 ? x[0] : x;
}
exports.possibleScalar = possibleScalar;
function coerceToArray(o) {
    if (o === null || o === undefined) {
        throw new TypeError('Illegal argument excepton: input needs to NOT be "null" or "undefined".');
    }
    if (typeof o === "number") {
        return [{ key: 0, val: o }];
    }
    if (isArray(o)) {
        return o.map((x, idx) => ({ key: idx, val: x }));
    }
    if (typeof o === "string") {
        return o.split("").map((x, idx) => ({ key: idx, val: x }));
    }
    if (typeof o === "object") {
        const names = Object.getOwnPropertyNames(o);
        if (names.length === 0) {
            throw new Error("Input argument is an Object with no properties");
        }
        return names.map(name => ({ key: name, val: o[name] }));
    }
    throw new Error("unreachable code");
}
function multiplexer(...rest) {
    const analyzed = [];
    for (let k = 0; k < rest.length; k++) {
        const arg = rest[k];
        if (arg === null) {
            analyzed.push([arg]);
            continue;
        }
        if (["undefined", "boolean", "number"].indexOf(typeof arg) >= 0) {
            analyzed.push([arg]);
            continue;
        }
        if (typeof arg === "string") {
            analyzed.push(arg.split(""));
            continue;
        }
        if (Array.isArray(arg)) {
            analyzed.push(arg);
            continue;
        }
        if (arg instanceof Object) {
            throw new Error("Sorry, looping over properties not yet supported");
        }
        if (arg instanceof Function) {
            throw new Error("Sorry function arguments are not yet supported");
        }
    }
    const _max = max(...analyzed.map(a => a.length));
    return function (fn) {
        const rc = [];
        for (let k = 0; k < _max; k++) {
            const result = [];
            for (let j = 0; j < analyzed.length; j++) {
                const arr = analyzed[j];
                const idx = k % arr.length;
                result.push(arr[idx]);
            }
            rc.push(fn(...result));
        }
        return possibleScalar(rc);
    };
}
exports.multiplexer = multiplexer;
function iter(wantMap = true) {
    return function (xx) {
        const fx = coerceToArray(xx);
        return function (fn) {
            return wantMap
                ? possibleScalar(fx.map(o => fn(o.val, o.key)))
                : fx.forEach(o => fn(o.val, o.key));
        };
    };
}
exports.map = iter();
exports.each = iter(false);
function numberPrecision(prec = 6) {
    function convert(x) {
        if (isNaN(x)) {
            return NaN;
        }
        return Number.parseFloat(x.toPrecision(prec));
    }
    return arrayrify(convert);
}
exports.numberPrecision = numberPrecision;
function any(x) {
    return function (fn) {
        if (fn instanceof Function) {
            return x.find(fn) !== undefined;
        }
        return x.find(d => d === fn) !== undefined;
    };
}
exports.any = any;
function sum(x) {
    let rc = 0;
    for (let i = 0; i < x.length; i++) {
        if (isArray(x[i])) {
            rc += sum(x[i]);
            continue;
        }
        if (typeof x[i] === "string") {
            const trial = Number.parseFloat(x[i]);
            if (Number.isFinite(trial)) {
                rc += trial;
                continue;
            }
            throw Error(`${x[i]} is not a number or can be coerced to a number`);
        }
        if (typeof x[i] === "number" && Number.isFinite(x[i])) {
            rc += x[i];
            continue;
        }
        throw new Error(`${x[i]} is not a number`);
    }
    return rc;
}
exports.sum = sum;
exports.div = multiplex((a, b) => a / b);
exports.mult = multiplex((a, b) => a * b);
function summary(x) {
    if (!Array.isArray(x)) {
        throw new Error(`Illigal argument, not an array`);
    }
    if (x.length === 0) {
        throw new Error(`argument Array is empty`);
    }
    if (x.findIndex(v => isNaN(v)) >= 0) {
        throw new Error(`argument Array has NaNs`);
    }
    const N = x.length;
    const mu = sum(x) / N;
    let relX2 = 0;
    for (let i = 0; i < x.length; i++) {
        relX2 += (x[i] - mu) * (x[i] - mu);
    }
    const sampleVariance = relX2 / (N - 1);
    const populationVariance = (sampleVariance * (N - 1)) / N;
    const sampleSD = Math.sqrt(sampleVariance);
    const populationSD = Math.sqrt(populationVariance);
    const o = x.sort((a, b) => a - b);
    const min = o[0];
    const max = o[N - 1];
    const { q1, median, q3 } = (function () {
        const i = [4, 2, 4 / 3].map(v => (N - 1) / v);
        const q = i.map(index => {
            const f1 = 1 - (index - floor(index));
            const f2 = 1 - f1;
            return o[trunc(index)] * f1 + o[trunc(index) + 1] * f2;
        });
        return {
            q1: q[0],
            median: q[1],
            q3: q[2]
        };
    })();
    return {
        N,
        mu,
        population: {
            variance: populationVariance,
            sd: populationSD
        },
        sample: {
            variance: sampleVariance,
            sd: sampleSD
        },
        relX: "depricated",
        relX2: "depricated",
        stats: {
            min,
            "1st Qu.": q1,
            median,
            "3rd Qu.": q3,
            max
        }
    };
}
exports.summary = summary;
function Welch_Satterthwaite(s, n) {
    const elts = flatten(exports.map(s)((_s, i) => {
        return (_s * _s) / n[i];
    }));
    const dom = elts.map((e, i) => (e * e) / (n[i] - 1));
    return Math.pow(sum(elts), 2) / sum(dom);
}
exports.Welch_Satterthwaite = Welch_Satterthwaite;

});

var cospi_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.atanpi = exports.tanpi = exports.cospi = void 0;


const { abs: fabs, PI: M_PI } = Math;
const { NaN: ML_NAN, isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer_cospi = src('cospi');
function cospi(x) {
    if (ISNAN(x))
        return x;
    if (!R_FINITE(x)) {
        _general.ML_ERROR(_general.ME.ME_DOMAIN, '', printer_cospi);
        return ML_NAN;
    }
    x = _general.fmod(fabs(x), 2);
    if (_general.fmod(x, 1) === 0.5)
        return 0;
    if (x === 1)
        return -1;
    if (x === 0)
        return 1;
    return Math.cos(M_PI * x);
}
exports.cospi = cospi;
const printer_tanpi = src('tanpi');
function tanpi(x) {
    if (ISNAN(x))
        return x;
    if (!R_FINITE(x)) {
        _general.ML_ERROR(_general.ME.ME_DOMAIN, '', printer_tanpi);
        return ML_NAN;
    }
    x = _general.fmod(x, 1);
    if (x <= -0.5) {
        x++;
    }
    else if (x > 0.5) {
        x--;
    }
    return x === 0 ? 0 : x === 0.5 ? ML_NAN : Math.tan(M_PI * x);
}
exports.tanpi = tanpi;
function atanpi(x) {
    return Math.atan(x) / Math.PI;
}
exports.atanpi = atanpi;

});

var sinpi_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.sinpi = void 0;


const { PI: M_PI } = Math;
const { NaN: ML_NAN, isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer_sinpi = src('sinpi');
function sinpi(x) {
    if (ISNAN(x))
        return x;
    if (!R_FINITE(x)) {
        _general.ML_ERROR(_general.ME.ME_DOMAIN, 'sinpi not finite', printer_sinpi);
        return ML_NAN;
    }
    x = _general.fmod(x, 2);
    if (x <= -1)
        x += 2;
    else if (x > 1)
        x -= 2;
    if (x === 0 || x === 1)
        return 0;
    if (x === 0.5)
        return 1;
    if (x === -0.5)
        return -1;
    return Math.sin(M_PI * x);
}
exports.sinpi = sinpi;

});

var tanpi_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.atanpi = exports.tanpi = void 0;


const { NaN: ML_NAN, isNaN: ISNAN, isFinite: R_FINITE } = Number;
const { PI: M_PI } = Math;
const printer_tanpi = src('tanpi');
function tanpi(x) {
    if (ISNAN(x))
        return x;
    if (!R_FINITE(x)) {
        _general.ML_ERROR(_general.ME.ME_DOMAIN, '', printer_tanpi);
        return ML_NAN;
    }
    x = _general.fmod(x, 1);
    if (x <= -0.5) {
        x++;
    }
    else if (x > 0.5) {
        x--;
    }
    return x === 0 ? 0 : x === 0.5 ? ML_NAN : Math.tan(M_PI * x);
}
exports.tanpi = tanpi;
function atanpi(x) {
    return Math.atan(x) / Math.PI;
}
exports.atanpi = atanpi;

});

var trigonometry = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.atanpi = exports.tanpi = exports.sinpi = exports.cospi = void 0;

Object.defineProperty(exports, "cospi", { enumerable: true, get: function () { return cospi_1.cospi; } });

Object.defineProperty(exports, "sinpi", { enumerable: true, get: function () { return sinpi_1.sinpi; } });

Object.defineProperty(exports, "tanpi", { enumerable: true, get: function () { return tanpi_1.tanpi; } });
Object.defineProperty(exports, "atanpi", { enumerable: true, get: function () { return tanpi_1.atanpi; } });

});

var lgammacor_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.lgammacor = void 0;



const printer = src('lgammacor');
const algmcs = [
    +.1666389480451863247205729650822e+0,
    -.1384948176067563840732986059135e-4,
    +.9810825646924729426157171547487e-8,
    -.1809129475572494194263306266719e-10,
    +.6221098041892605227126015543416e-13,
    -.3399615005417721944303330599666e-15,
    +.2683181998482698748957538846666e-17,
    -.2868042435334643284144622399999e-19,
    +.3962837061046434803679306666666e-21,
    -.6831888753985766870111999999999e-23,
    +.1429227355942498147573333333333e-24,
    -.3547598158101070547199999999999e-26,
    +.1025680058010470912000000000000e-27,
    -.3401102254316748799999999999999e-29,
    +.1276642195630062933333333333333e-30
];
const nalgm = 5;
const xbig = 94906265.62425156;
const xmax = 3.745194030963158e306;
function lgammacor(x) {
    let tmp;
    if (x < 10)
        return _general.ML_ERR_return_NAN(printer);
    else if (x >= xmax) {
        _general.ML_ERROR(_general.ME.ME_UNDERFLOW, 'lgammacor', printer);
    }
    else if (x < xbig) {
        tmp = 10 / x;
        return chebyshev$1.chebyshev_eval(tmp * tmp * 2 - 1, algmcs, nalgm) / x;
    }
    return 1 / (x * 12);
}
exports.lgammacor = lgammacor;

});

var gamma_fn_1 = gamma_fn;

var lgammafn_sign_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.lgammafn_sign = void 0;





const { isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF } = Number;
const { log, abs: fabs, floor, trunc } = Math;
const printer_sign = src('lgammafn_sign');
const xmax = 2.5327372760800758e305;
const dxrel = 1.490116119384765625e-8;
function lgammafn_sign(x, sgn) {
    let ans;
    let y;
    let sinpiy;
    if (sgn)
        sgn[0] = 1;
    if (ISNAN(x))
        return x;
    if (sgn && x < 0 && _general.fmod(floor(-x), 2) === 0) {
        sgn[0] = -1;
    }
    if (x <= 0 && x === trunc(x)) {
        _general.ML_ERROR(_general.ME.ME_RANGE, 'lgamma', printer_sign);
        return ML_POSINF;
    }
    y = fabs(x);
    if (y < 1e-306)
        return -log(y);
    if (y <= 10)
        return log(fabs(gamma_fn_1.gammafn(x)));
    if (y > xmax) {
        _general.ML_ERROR(_general.ME.ME_RANGE, 'lgamma', printer_sign);
        return ML_POSINF;
    }
    if (x > 0) {
        if (x > 1e17)
            return x * (log(x) - 1);
        else if (x > 4934720)
            return _general.M_LN_SQRT_2PI + (x - 0.5) * log(x) - x;
        else
            return _general.M_LN_SQRT_2PI + (x - 0.5) * log(x) - x + lgammacor_1.lgammacor(x);
    }
    sinpiy = fabs(trigonometry.sinpi(y));
    if (sinpiy === 0) {
        printer_sign(' ** should NEVER happen! *** [lgamma.c: Neg.int, y=%d]', y);
        return _general.ML_ERR_return_NAN(printer_sign);
    }
    ans = _general.M_LN_SQRT_PId2 + (x - 0.5) * log(y) - x - log(sinpiy) - lgammacor_1.lgammacor(y);
    if (fabs((x - Math.trunc(x - 0.5)) * ans / x) < dxrel) {
        _general.ML_ERROR(_general.ME.ME_PRECISION, 'lgamma', printer_sign);
    }
    return ans;
}
exports.lgammafn_sign = lgammafn_sign;

});

var lgamma_fn = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.lgammafn = void 0;


function lgammafn(x) {
    return rFunc.map(x)(fx => {
        return lgammafn_sign_1.lgammafn_sign(fx);
    });
}
exports.lgammafn = lgammafn;

});

var stirlerror = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.stirlerr = void 0;


const { trunc, log } = Math;
const sferr_halves = [
    0.0,
    0.1534264097200273452913848,
    0.0810614667953272582196702,
    0.0548141210519176538961390,
    0.0413406959554092940938221,
    0.03316287351993628748511048,
    0.02767792568499833914878929,
    0.02374616365629749597132920,
    0.02079067210376509311152277,
    0.01848845053267318523077934,
    0.01664469118982119216319487,
    0.01513497322191737887351255,
    0.01387612882307074799874573,
    0.01281046524292022692424986,
    0.01189670994589177009505572,
    0.01110455975820691732662991,
    0.010411265261972096497478567,
    0.009799416126158803298389475,
    0.009255462182712732917728637,
    0.008768700134139385462952823,
    0.008330563433362871256469318,
    0.007934114564314020547248100,
    0.007573675487951840794972024,
    0.007244554301320383179543912,
    0.006942840107209529865664152,
    0.006665247032707682442354394,
    0.006408994188004207068439631,
    0.006171712263039457647532867,
    0.005951370112758847735624416,
    0.005746216513010115682023589,
    0.005554733551962801371038690
];
const S0 = 0.083333333333333333333;
const S1 = 0.00277777777777777777778;
const S2 = 0.00079365079365079365079365;
const S3 = 0.000595238095238095238095238;
const S4 = 0.0008417508417508417508417508;
function stirlerr(n) {
    let nn;
    if (n <= 15.0) {
        nn = n + n;
        if (nn === trunc(nn))
            return (sferr_halves[trunc(nn)]);
        return (lgamma_fn.lgammafn(n + 1.) - (n + 0.5) * log(n) + n - _general.M_LN_SQRT_2PI);
    }
    nn = n * n;
    if (n > 500)
        return ((S0 - S1 / nn) / n);
    if (n > 80)
        return ((S0 - (S1 - S2 / nn) / nn) / n);
    if (n > 35)
        return ((S0 - (S1 - (S2 - S3 / nn) / nn) / nn) / n);
    return ((S0 - (S1 - (S2 - (S3 - S4 / nn) / nn) / nn) / nn) / n);
}
exports.stirlerr = stirlerr;

});

var stirling = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.stirlerr = void 0;

Object.defineProperty(exports, "stirlerr", { enumerable: true, get: function () { return stirlerror.stirlerr; } });

});

var gamma_fn = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.gammafn = void 0;






const printer = src('gammafn');
const { isNaN: ISNAN, NaN: ML_NAN, POSITIVE_INFINITY: ML_POSINF, NEGATIVE_INFINITY: ML_NEGINF } = Number;
const { PI: M_PI, abs: fabs, round, trunc, exp, log } = Math;
const M_LN_SQRT_2PI = Math.log(Math.sqrt(2 * Math.PI));
const gamcs = [
    +0.8571195590989331421920062399942e-2,
    +0.4415381324841006757191315771652e-2,
    +0.5685043681599363378632664588789e-1,
    -0.4219835396418560501012500186624e-2,
    +0.1326808181212460220584006796352e-2,
    -0.1893024529798880432523947023886e-3,
    +0.3606925327441245256578082217225e-4,
    -0.6056761904460864218485548290365e-5,
    +0.1055829546302283344731823509093e-5,
    -0.1811967365542384048291855891166e-6,
    +0.3117724964715322277790254593169e-7,
    -0.5354219639019687140874081024347e-8,
    +0.919327551985958894688778682594e-9,
    -0.1577941280288339761767423273953e-9,
    +0.2707980622934954543266540433089e-10,
    -0.4646818653825730144081661058933e-11,
    +0.7973350192007419656460767175359e-12,
    -0.1368078209830916025799499172309e-12,
    +0.2347319486563800657233471771688e-13,
    -0.4027432614949066932766570534699e-14,
    +0.6910051747372100912138336975257e-15,
    -0.1185584500221992907052387126192e-15,
    +0.2034148542496373955201026051932e-16,
    -0.3490054341717405849274012949108e-17,
    +0.5987993856485305567135051066026e-18,
    -0.1027378057872228074490069778431e-18,
    +0.1762702816060529824942759660748e-19,
    -0.3024320653735306260958772112042e-20,
    +0.5188914660218397839717833550506e-21,
    -0.8902770842456576692449251601066e-22,
    +0.1527474068493342602274596891306e-22,
    -0.2620731256187362900257328332799e-23,
    +0.4496464047830538670331046570666e-24,
    -0.7714712731336877911703901525333e-25,
    +0.1323635453126044036486572714666e-25,
    -0.2270999412942928816702313813333e-26,
    +0.3896418998003991449320816639999e-27,
    -0.6685198115125953327792127999999e-28,
    +0.1146998663140024384347613866666e-28,
    -0.1967938586345134677295103999999e-29,
    +0.3376448816585338090334890666666e-30,
    -0.5793070335782135784625493333333e-31
];
const { isArray } = Array;
function gammafn(x) {
    const fx = isArray(x) ? x : [x];
    const result = fx.map(fx => {
        return _gammafn(fx);
    });
    return result.length === 1 ? result[0] : result;
}
exports.gammafn = gammafn;
function _gammafn(x) {
    let i;
    let n;
    let y;
    let sinpiy;
    let value;
    const ngam = 22;
    const xmin = -170.5674972726612;
    const xmax = 171.61447887182298;
    const xsml = 2.2474362225598545e-308;
    const dxrel = 1.490116119384765696e-8;
    if (ISNAN(x))
        return x;
    if (x === 0 || (x < 0 && x === round(x))) {
        _general.ML_ERROR(_general.ME.ME_DOMAIN, 'gammafn', printer);
        return ML_NAN;
    }
    y = fabs(x);
    if (y <= 10) {
        n = x >> 0;
        if (x < 0)
            --n;
        y = x - n;
        --n;
        value = chebyshev$1.chebyshev_eval(y * 2 - 1, gamcs, ngam) + 0.9375;
        if (n === 0)
            return value;
        if (n < 0) {
            if (x < -0.5 && fabs(x - trunc(x - 0.5) / x) < dxrel) {
                _general.ML_ERROR(_general.ME.ME_PRECISION, 'gammafn', printer);
            }
            if (y < xsml) {
                _general.ML_ERROR(_general.ME.ME_RANGE, 'gammafn', printer);
                if (x > 0)
                    return ML_POSINF;
                else
                    return ML_NEGINF;
            }
            n = -n;
            for (i = 0; i < n; i++) {
                value /= x + i;
            }
            return value;
        }
        else {
            for (i = 1; i <= n; i++) {
                value *= y + i;
            }
            return value;
        }
    }
    else {
        if (x > xmax) {
            _general.ML_ERROR(_general.ME.ME_RANGE, 'gammafn', printer);
            return ML_POSINF;
        }
        if (x < xmin) {
            _general.ML_ERROR(_general.ME.ME_UNDERFLOW, 'gammafn', printer);
            return 0;
        }
        if (y <= 50 && y === trunc(y)) {
            value = 1;
            for (i = 2; i < y; i++)
                value *= i;
        }
        else {
            value = exp((y - 0.5) * log(y) -
                y +
                M_LN_SQRT_2PI +
                (2 * y === trunc(2) * y ? stirling.stirlerr(y) : lgammacor_1.lgammacor(y)));
        }
        if (x > 0)
            return value;
        if (fabs((x - trunc(x - 0.5)) / x) < dxrel) {
            _general.ML_ERROR(_general.ME.ME_PRECISION, 'gammafn', printer);
        }
        sinpiy = trigonometry.sinpi(y);
        if (sinpiy === 0) {
            _general.ML_ERROR(_general.ME.ME_RANGE, 'gammafn', printer);
            return ML_POSINF;
        }
        return -M_PI / (y * sinpiy * value);
    }
}

});

var lbeta_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.internal_lbeta = exports.lbeta = void 0;






const { log, log1p } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF, NEGATIVE_INFINITY: ML_NEGINF } = Number;
const printer = src('lbeta');
function lbeta(_a, _b) {
    return rFunc.multiplexer(_a, _b)((a, b) => internal_lbeta(a, b));
}
exports.lbeta = lbeta;
function internal_lbeta(a, b) {
    let corr;
    let p;
    let q;
    if (ISNAN(a) || ISNAN(b))
        return a + b;
    p = q = a;
    if (b < p)
        p = b;
    if (b > q)
        q = b;
    if (p < 0)
        return _general.ML_ERR_return_NAN(printer);
    else if (p === 0) {
        return ML_POSINF;
    }
    else if (!R_FINITE(q)) {
        return ML_NEGINF;
    }
    if (p >= 10) {
        corr = lgammacor_1.lgammacor(p) + lgammacor_1.lgammacor(q) - lgammacor_1.lgammacor(p + q);
        return (log(q) * -0.5 +
            _general.M_LN_SQRT_2PI +
            corr +
            (p - 0.5) * log(p / (p + q)) +
            q * log1p(-p / (p + q)));
    }
    else if (q >= 10) {
        corr = lgammacor_1.lgammacor(q) - lgammacor_1.lgammacor(p + q);
        return (lgamma_fn.lgammafn(p) +
            corr +
            p -
            p * log(p + q) +
            (q - 0.5) * log1p(-p / (p + q)));
    }
    else {
        return log(gamma_fn_1.gammafn(p) * (gamma_fn_1.gammafn(q) / gamma_fn_1.gammafn(p + q)));
    }
}
exports.internal_lbeta = internal_lbeta;

});

var beta_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.internal_beta = exports.beta = void 0;





const xmax = 171.61447887182298;
const lnsml = -708.39641853226412;
const { isNaN: ISNAN, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer_beta = src('beta');
function beta(_a, _b) {
    return rFunc.multiplexer(_a, _b)((a, b) => internal_beta(a, b));
}
exports.beta = beta;
function internal_beta(a, b) {
    if (ISNAN(a) || ISNAN(b))
        return a + b;
    if (a < 0 || b < 0)
        return _general.ML_ERR_return_NAN(printer_beta);
    else if (a === 0 || b === 0)
        return ML_POSINF;
    else if (!R_FINITE(a) || !R_FINITE(b))
        return 0;
    if (a + b < xmax) {
        return 1 / gamma_fn_1.gammafn(a + b) * gamma_fn_1.gammafn(a) * gamma_fn_1.gammafn(b);
    }
    else {
        let val = lbeta_1.internal_lbeta(a, b);
        if (val < lnsml) {
            _general.ML_ERROR(_general.ME.ME_UNDERFLOW, 'beta', printer_beta);
        }
        return Math.exp(val);
    }
}
exports.internal_beta = internal_beta;

});

var bd0_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.bd0 = void 0;
const { isFinite: R_FINITE, MIN_VALUE: DBL_MIN, NaN: NaN$1 } = Number;
const { abs: fabs, log } = Math;
function bd0(x, np) {
    let ej;
    let s;
    let s1;
    let v;
    let j;
    if (!R_FINITE(x) || !R_FINITE(np) || np === 0.0) {
        return NaN$1;
    }
    if (fabs(x - np) < 0.1 * (x + np)) {
        v = (x - np) / (x + np);
        s = (x - np) * v;
        if (fabs(s) < DBL_MIN)
            return s;
        ej = 2 * x * v;
        v = v * v;
        for (j = 1; j < 1000; j++) {
            ej *= v;
            s1 = s + ej / ((j << 1) + 1);
            if (s1 === s)
                return s1;
            s = s1;
        }
    }
    return x * log(x / np) + np - x;
}
exports.bd0 = bd0;

});

var deviance = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(bd0_1, exports);

});

var dbinom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dbinom = exports.dbinom_raw = void 0;





const { log, log1p, round: R_forceint } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer = src('dbinom');
function dbinom_raw(x, n, p, q, give_log) {
    let lf;
    let lc;
    if (p === 0)
        return x === 0 ? _general.R_D__1(give_log) : _general.R_D__0(give_log);
    if (q === 0)
        return x === n ? _general.R_D__1(give_log) : _general.R_D__0(give_log);
    if (x === 0) {
        if (n === 0)
            return _general.R_D__1(give_log);
        let lc = p < 0.1 ? -deviance.bd0(n, n * q) - n * p : n * log(q);
        return _general.R_D_exp(give_log, lc);
    }
    if (x === n) {
        lc = q < 0.1 ? -deviance.bd0(n, n * p) - n * q : n * log(p);
        return _general.R_D_exp(give_log, lc);
    }
    if (x < 0 || x > n)
        return _general.R_D__0(give_log);
    lc =
        stirling.stirlerr(n) -
            stirling.stirlerr(x) -
            stirling.stirlerr(n - x) -
            deviance.bd0(x, n * p) -
            deviance.bd0(n - x, n * q);
    lf = _general.M_LN_2PI + log(x) + log1p(-x / n);
    return _general.R_D_exp(give_log, lc - 0.5 * lf);
}
exports.dbinom_raw = dbinom_raw;
function dbinom(xx, n, p, logX = false) {
    return rFunc.map(xx)(x => {
        if (ISNAN(x) || ISNAN(n) || ISNAN(p))
            return x + n + p;
        if (p < 0 || p > 1 || _general.R_D_negInonint(n))
            return _general.ML_ERR_return_NAN(printer);
        _general.R_D_nonint_check(logX, x, printer);
        if (x < 0 || !R_FINITE(x))
            return _general.R_D__0(logX);
        n = R_forceint(n);
        x = R_forceint(x);
        return dbinom_raw(x, n, p, 1 - p, logX);
    });
}
exports.dbinom = dbinom;

});

var dbeta_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dbeta = void 0;





const { log, log1p } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer = src('dbeta');
function dbeta(_x, _a, _b, _asLog) {
    return rFunc.multiplexer(_x, _a, _b, _asLog)((x, a, b, asLog) => {
        if (ISNAN(x) || ISNAN(a) || ISNAN(b))
            return x + a + b;
        if (a < 0 || b < 0)
            return _general.ML_ERR_return_NAN(printer);
        if (x < 0 || x > 1)
            return _general.R_D__0(asLog);
        if (a === 0 || b === 0 || !R_FINITE(a) || !R_FINITE(b)) {
            if (a === 0 && b === 0) {
                if (x === 0 || x === 1)
                    return ML_POSINF;
                else
                    return _general.R_D__0(asLog);
            }
            if (a === 0 || a / b === 0) {
                if (x === 0)
                    return ML_POSINF;
                else
                    return _general.R_D__0(asLog);
            }
            if (b === 0 || b / a === 0) {
                if (x === 1)
                    return ML_POSINF;
                else
                    return _general.R_D__0(asLog);
            }
            if (x === 0.5)
                return ML_POSINF;
            else
                return _general.R_D__0(asLog);
        }
        if (x === 0) {
            if (a > 1)
                return _general.R_D__0(asLog);
            if (a < 1)
                return ML_POSINF;
            return _general.R_D_val(asLog, b);
        }
        if (x === 1) {
            if (b > 1)
                return _general.R_D__0(asLog);
            if (b < 1)
                return ML_POSINF;
            return _general.R_D_val(asLog, a);
        }
        let lval;
        if (a <= 2 || b <= 2)
            lval = (a - 1) * log(x) + (b - 1) * log1p(-x) - lbeta_1.internal_lbeta(a, b);
        else {
            lval = log(a + b - 1) + dbinom_1.dbinom_raw(a - 1, a + b - 2, x, 1 - x, true);
        }
        return _general.R_D_exp(asLog, lval);
    });
}
exports.dbeta = dbeta;

});

var dpois_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dpois = exports.dpois_raw = void 0;






const { round: R_forceint, log, PI } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, MIN_VALUE: DBL_MIN } = Number;
const M_2PI = 2 * PI;
const printer = src('dpois');
function dpois_raw(x, lambda, give_log) {
    if (lambda === 0)
        return x === 0 ? _general.R_D__1(give_log) : _general.R_D__0(give_log);
    if (!R_FINITE(lambda))
        return _general.R_D__0(give_log);
    if (x < 0)
        return _general.R_D__0(give_log);
    if (x <= lambda * DBL_MIN)
        return _general.R_D_exp(give_log, -lambda);
    if (lambda < x * DBL_MIN)
        return _general.R_D_exp(give_log, -lambda + x * log(lambda) - lgamma_fn.lgammafn(x + 1));
    return _general.R_D_fexp(give_log, M_2PI * x, -stirling.stirlerr(x) - deviance.bd0(x, lambda));
}
exports.dpois_raw = dpois_raw;
function dpois(_x, lambda, give_log = false) {
    return rFunc.map(_x)(x => {
        if (ISNAN(x) || ISNAN(lambda)) {
            return x + lambda;
        }
        if (lambda < 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        let rc = _general.R_D_nonint_check(give_log, x, printer);
        if (rc !== undefined) {
            return rc;
        }
        if (x < 0 || !R_FINITE(x)) {
            return _general.R_D__0(give_log);
        }
        x = R_forceint(x);
        return dpois_raw(x, lambda, give_log);
    });
}
exports.dpois = dpois;

});

var dnbeta_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dnbeta = void 0;





const { log: ln, sqrt, ceil } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer = src('dnbeta');
function dnbeta(_x, _shape1, _shape2, _ncp, _asLog) {
    return rFunc.multiplexer(_x, _shape1, _shape2, _ncp, _asLog)(function (x, shape1, shape2, ncp, asLog) {
        return _dnbeta(x, shape1, shape2, ncp, asLog);
    });
}
exports.dnbeta = dnbeta;
function _dnbeta(x, a, b, ncp, give_log) {
    const eps = 1e-15;
    let kMax;
    let k;
    let ncp2;
    let dx2;
    let d;
    let D;
    let term;
    let sum;
    let p_k;
    let q;
    if (ISNAN(x) || ISNAN(a) || ISNAN(b) || ISNAN(ncp))
        return x + a + b + ncp;
    if (ncp < 0 || a <= 0 || b <= 0) {
        return _general.ML_ERR_return_NAN(printer);
    }
    if (!R_FINITE(a) || !R_FINITE(b) || !R_FINITE(ncp)) {
        return _general.ML_ERR_return_NAN(printer);
    }
    if (x < 0 || x > 1) {
        return _general.R_D__0(give_log);
    }
    if (ncp === 0) {
        return dbeta_1.dbeta(x, a, b, give_log);
    }
    ncp2 = 0.5 * ncp;
    dx2 = ncp2 * x;
    d = (dx2 - a - 1) / 2;
    D = d * d + dx2 * (a + b) - a;
    if (D <= 0) {
        kMax = 0;
    }
    else {
        D = ceil(d + sqrt(D));
        kMax = D > 0 ? D : 0;
    }
    term = dbeta_1.dbeta(x, a + kMax, b, true);
    p_k = dpois_1.dpois_raw(kMax, ncp2, true);
    if (x === 0 || !R_FINITE(term) || !R_FINITE(p_k)) {
        return _general.R_D_exp(give_log, p_k + term);
    }
    p_k += term;
    sum = term = 1;
    k = kMax;
    while (k > 0 && term > sum * eps) {
        k--;
        q = (k + 1) * (k + a) / (k + a + b) / dx2;
        term *= q;
        sum += term;
    }
    term = 1;
    k = kMax;
    do {
        q = dx2 * (k + a + b) / (k + a) / (k + 1);
        k++;
        term *= q;
        sum += term;
    } while (term > sum * eps);
    return _general.R_D_exp(give_log, p_k + ln(sum));
}

});

var NumberW_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberW = void 0;
class NumberW {
    constructor(v = 0) {
        this._val = v;
    }
    get val() {
        return this._val;
    }
    set val(a) {
        if (Number.isNaN(a)) {
            throw new Error(`trying to set NaN, old value:${this._val}`);
        }
        this._val = a;
    }
}
exports.NumberW = NumberW;

});

var toms708$1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Toms708 = void 0;


const { trunc, log, abs, min, pow } = Math;
const printer_bratio = src('Toms708.bratio');
class Toms708 {
    static alnrel(a) {
        const p3 = -0.178874546012214e-1;
        const p2 = 0.405303492862024;
        const p1 = -0.129418923021993e1;
        const q3 = -0.845104217945565e-1;
        const q2 = 0.747811014037616;
        const q1 = -0.162752256355323e1;
        let t = 0.0;
        let w = 0.0;
        let x = 0.0;
        let t2 = 0.0;
        if (Math.abs(a) > 0.375) {
            x = 1 + a;
            return log(x);
        }
        t = a / (a + 2.0);
        t2 = t * t;
        w =
            (((p3 * t2 + p2) * t2 + p1) * t2 + 1.0) /
                (((q3 * t2 + q2) * t2 + q1) * t2 + 1.0);
        return 2.0 * t * w;
    }
    static algdiv(a, b) {
        const c5 = -0.165322962780713e-2;
        const c4 = 0.837308034031215e-3;
        const c3 = -0.59520293135187e-3;
        const c2 = 0.79365066682539e-3;
        const c1 = -0.277777777760991e-2;
        const c0 = 0.833333333333333e-1;
        let s11 = 0.0;
        let c = 0.0;
        let d = 0.0;
        let h = 0.0;
        let t = 0.0;
        let u = 0.0;
        let v = 0.0;
        let w = 0.0;
        let x = 0.0;
        let s3 = 0.0;
        let s5 = 0.0;
        let s7 = 0.0;
        let x2 = 0.0;
        let s9 = 0.0;
        if (a <= b) {
            h = a / b;
            c = h / (1.0 + h);
            x = 1.0 / (1.0 + h);
            d = b + (a - 0.5);
        }
        else {
            h = b / a;
            c = 1.0 / (1.0 + h);
            x = h / (1.0 + h);
            d = a + (b - 0.5);
        }
        x2 = x * x;
        s3 = 1.0 + x + x2;
        s5 = 1.0 + x + x2 * s3;
        s7 = 1.0 + x + x2 * s5;
        s9 = 1.0 + x + x2 * s7;
        s11 = 1.0 + x + x2 * s9;
        t = Math.pow(1.0 / b, 2);
        w =
            ((((c5 * s11 * t + c4 * s9) * t + c3 * s7) * t + c2 * s5) * t + c1 * s3) *
                t +
                c0;
        w *= c / b;
        u = d * Toms708.alnrel(a / b);
        v = a * (log(b) - 1.0);
        if (u <= v)
            return w - u - v;
        return w - v - u;
    }
    static apser(a, b, x, eps) {
        const g = 0.577215664901533;
        let j = 0.0;
        let bx = 0.0;
        let c = 0.0;
        let s = 0.0;
        let t = 0.0;
        let tol = 0.0;
        let aj = 0.0;
        bx = b * x;
        t = x - bx;
        if (b * eps > 2e-2) {
            c = log(bx) + g + t;
        }
        else {
            c = log(x) + Toms708.psi(b) + g + t;
        }
        tol = 5.0 * eps * Math.abs(c);
        j = 1.0;
        s = 0.0;
        do {
            j++;
            t *= x - bx / j;
            aj = t / j;
            s += aj;
        } while (Math.abs(aj) > tol);
        return -(a * (c + s));
    }
    static basym(a, b, lambda, eps) {
        let a0 = new Array(21).fill(0);
        let b0 = new Array(21).fill(0);
        let c = new Array(21).fill(0);
        let d = new Array(21).fill(0);
        let num = 20;
        const e0 = 1.12837916709551;
        const e1 = 0.353553390593274;
        let h;
        let r0;
        let r1;
        let w0;
        if (a <= b) {
            h = a / b;
            r0 = 1.0 / (1.0 + h);
            r1 = (b - a) / b;
            w0 = 1.0 / Math.sqrt(a * (1.0 + h));
        }
        else {
            h = b / a;
            r0 = 1.0 / (1.0 + h);
            r1 = (b - a) / a;
            w0 = 1.0 / Math.sqrt(b * (1.0 + h));
        }
        let f = a * Toms708.rlog1(-lambda / a) + b * Toms708.rlog1(lambda / b);
        let t = Math.exp(-f);
        if (t === 0.0)
            return 0;
        let z0 = Math.sqrt(f);
        let z = 0.5 * (z0 / e1);
        let z2 = f + f;
        a0[0] = 2.0 / 3.0 * r1;
        c[0] = -0.5 * a0[0];
        d[0] = -c[0];
        let j0 = 0.5 / e0 * Toms708.erfc1(1, z0);
        let j1 = e1;
        let sum = j0 + d[0] * w0 * j1;
        let s = 1.0;
        let h2 = h * h;
        let hn = 1.0;
        let w = w0;
        let znm1 = z;
        let zn = z2;
        for (let n = 2; n <= num; n += 2) {
            hn = h2 * hn;
            a0[n] = 2.0 * r0 * (1.0 + h * hn) / (n + 2.0);
            let np1 = n + 1;
            s = s + hn;
            a0[np1] = 2.0 * r1 * s / (n + 3.0);
            for (let i = n; i <= np1; i++) {
                let r = -0.5 * (i + 1.0);
                b0[1] = r * a0[1];
                for (let m = 2; m <= i; m++) {
                    let bsum = 0.0;
                    let mm1 = m - 1;
                    for (let j = 1; j <= mm1; j++) {
                        let mmj = m - j;
                        bsum = bsum + (j * r - mmj) * a0[j] * b0[mmj];
                    }
                    b0[m] = r * a0[m] + bsum / m;
                }
                c[i] = b0[i] / (i + 1.0);
                let dsum = 0.0;
                let im1 = i - 1;
                for (let j = 1; j <= im1; j++) {
                    let imj = i - j;
                    dsum = dsum + d[imj] * c[j];
                }
                d[i] = -(dsum + c[i]);
            }
            j0 = e1 * znm1 + (n - 1.0) * j0;
            j1 = e1 * zn + n * j1;
            znm1 = z2 * znm1;
            zn = z2 * zn;
            w = w0 * w;
            let t0 = d[n] * w * j0;
            w = w0 * w;
            let t1 = d[np1] * w * j1;
            sum = sum + (t0 + t1);
            if (Math.abs(t0) + Math.abs(t1) <= eps * sum)
                break;
        }
        let u = Math.exp(-Toms708.bcorr(a, b));
        return e0 * t * u * sum;
    }
    static bcorr(a0, b0) {
        const c5 = -0.165322962780713e-2;
        const c4 = 0.837308034031215e-3;
        const c3 = -0.59520293135187e-3;
        const c2 = 0.79365066682539e-3;
        const c1 = -0.277777777760991e-2;
        const c0 = 0.833333333333333e-1;
        let s11 = 0.0;
        let a = 0.0;
        let b = 0.0;
        let c = 0.0;
        let h = 0.0;
        let t = 0.0;
        let w = 0.0;
        let x = 0.0;
        let s3 = 0.0;
        let s5 = 0.0;
        let s7 = 0.0;
        let x2 = 0.0;
        let s9 = 0.0;
        a = Math.min(a0, b0);
        b = Math.max(a0, b0);
        h = a / b;
        c = h / (1.0 + h);
        x = 1.0 / (1.0 + h);
        x2 = x * x;
        s3 = 1.0 + (x + x2);
        s5 = 1.0 + (x + x2 * s3);
        s7 = 1.0 + (x + x2 * s5);
        s9 = 1.0 + (x + x2 * s7);
        s11 = 1.0 + (x + x2 * s9);
        t = Math.pow(1.0 / b, 2);
        w =
            ((((c5 * s11 * t + c4 * s9) * t + c3 * s7) * t + c2 * s5) * t + c1 * s3) *
                t +
                c0;
        w = w * (c / b);
        t = Math.pow(1.0 / a, 2);
        return (((((c5 * t + c4) * t + c3) * t + c2) * t + c1) * t + c0) / a + w;
    }
    static beta_cdf_values(nData, a, b, x, fx) {
        const nMax = 42;
        const aVec = [
            0.5,
            0.5,
            0.5,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            2.0,
            2.0,
            2.0,
            2.0,
            2.0,
            2.0,
            2.0,
            2.0,
            2.0,
            5.5,
            10.0,
            10.0,
            10.0,
            10.0,
            20.0,
            20.0,
            20.0,
            20.0,
            20.0,
            30.0,
            30.0,
            40.0,
            0.1e1,
            0.1e1,
            0.1e1,
            0.1e1,
            0.1e1,
            0.1e1,
            0.1e1,
            0.1e1,
            0.2e1,
            0.3e1,
            0.4e1,
            0.5e1
        ];
        const bVec = [
            0.5,
            0.5,
            0.5,
            0.5,
            0.5,
            0.5,
            0.5,
            1.0,
            2.0,
            2.0,
            2.0,
            2.0,
            2.0,
            2.0,
            2.0,
            2.0,
            2.0,
            5.0,
            0.5,
            5.0,
            5.0,
            10.0,
            5.0,
            10.0,
            10.0,
            20.0,
            20.0,
            10.0,
            10.0,
            20.0,
            0.5,
            0.5,
            0.5,
            0.5,
            0.2e1,
            0.3e1,
            0.4e1,
            0.5e1,
            0.2e1,
            0.2e1,
            0.2e1,
            0.2e1
        ];
        const fxVec = [
            0.6376856085851985e-1,
            0.2048327646991335,
            0.1e1,
            0.0,
            0.5012562893380045e-2,
            0.513167019494862e-1,
            0.2928932188134525,
            0.5,
            0.28e-1,
            0.104,
            0.216,
            0.352,
            0.5,
            0.648,
            0.784,
            0.896,
            0.972,
            0.4361908850559777,
            0.1516409096347099,
            0.8978271484375e-1,
            0.1e1,
            0.5,
            0.4598773297575791,
            0.2146816102371739,
            0.9507364826957875,
            0.5,
            0.8979413687105918,
            0.2241297491808366,
            0.7586405487192086,
            0.7001783247477069,
            0.513167019494862e-1,
            0.1055728090000841,
            0.1633399734659245,
            0.2254033307585166,
            0.36,
            0.488,
            0.5904,
            0.67232,
            0.216,
            0.837e-1,
            0.3078e-1,
            0.10935e-1
        ];
        const xVec = [
            0.01,
            0.1,
            1.0,
            0.0,
            0.01,
            0.1,
            0.5,
            0.5,
            0.1,
            0.2,
            0.3,
            0.4,
            0.5,
            0.6,
            0.7,
            0.8,
            0.9,
            0.5,
            0.9,
            0.5,
            1.0,
            0.5,
            0.8,
            0.6,
            0.8,
            0.5,
            0.6,
            0.7,
            0.8,
            0.7,
            0.1,
            0.2,
            0.3,
            0.4,
            0.2,
            0.2,
            0.2,
            0.2,
            0.3,
            0.3,
            0.3,
            0.3
        ];
        if (nData.val < 0)
            nData.val = 0;
        nData.val++;
        if (nData.val > nMax) {
            nData.val = 0;
            a.val = b.val = x.val = fx.val = 0.0;
        }
        else {
            a.val = aVec[nData.val - 1];
            b.val = bVec[nData.val - 1];
            x.val = xVec[nData.val - 1];
            fx.val = fxVec[nData.val - 1];
        }
    }
    static betaln(a0, b0) {
        const e = 0.918938533204673;
        let a = 0.0;
        let b = 0.0;
        let c = 0.0;
        let h = 0.0;
        let i = 0;
        let n = 0;
        let u = 0.0;
        let v = 0.0;
        let w = 0.0;
        let z = 0.0;
        a = Math.min(a0, b0);
        b = Math.max(a0, b0);
        if (a < 1) {
            if (b < 8.0)
                return Toms708.gamln(a) + Toms708.algdiv(a, b);
            else
                return Toms708.gamln(a) + Toms708.gamln(b) - Toms708.gamln(a + b);
        }
        else if (a >= 1 && a < 8) {
            if (a < 2 && b < 2) {
                return Toms708.gamln(a) + Toms708.gamln(b) - Toms708.gsumln(a, b);
            }
            else if (b > 2) {
                w = 0.0;
                if (b < 8.0) {
                    n = trunc(b - 1.0);
                    z = 1.0;
                    for (i = 1; i <= n; i++) {
                        b--;
                        z *= b / (a + b);
                    }
                    return (w +
                        log(z) +
                        (Toms708.gamln(a) + Toms708.gamln(b) - Toms708.gsumln(a, b)));
                }
                else
                    return Toms708.gamln(a) + Toms708.algdiv(a, b);
            }
            else if (a > 2) {
                if (b > 1000.0) {
                    n = trunc(a - 1.0);
                    w = 1.0;
                    for (i = 1; i <= n; i++) {
                        a--;
                        w = w * (a / (1.0 + a / b));
                    }
                    return (log(w) - n * log(b) + (Toms708.gamln(a) + Toms708.algdiv(a, b)));
                }
                n = trunc(a - 1.0);
                w = 1.0;
                for (i = 1; i <= n; i++) {
                    a--;
                    h = a / b;
                    w *= h / (1.0 + h);
                }
                w = log(w);
                if (b < 8.0) {
                    n = trunc(b - 1.0);
                    z = 1.0;
                    for (i = 1; i <= n; i++) {
                        b--;
                        z *= b / (a + b);
                    }
                    return (w +
                        log(z) +
                        (Toms708.gamln(a) + Toms708.gamln(b) - Toms708.gsumln(a, b)));
                }
                else
                    return w + Toms708.gamln(a) + Toms708.algdiv(a, b);
            }
        }
        w = Toms708.bcorr(a, b);
        h = a / b;
        c = h / (1.0 + h);
        u = -((a - 0.5) * log(c));
        v = b * Toms708.alnrel(h);
        if (u > v)
            return -0.5 * log(b) + e + w - u - v;
        else
            return -0.5 * log(b) + e + w - v - u;
    }
    static bfrac(a, b, x, y, lambda, eps) {
        let n = 0.0;
        let yp1 = 0.0;
        let alpha = 0.0;
        let c = 0.0;
        let e = 0.0;
        let p = 0.0;
        let r = 0.0;
        let s = 0.0;
        let t = 0.0;
        let w = 0.0;
        let c0 = 0.0;
        let c1 = 0.0;
        let anp1 = 0.0;
        let bnp1 = 0.0;
        let r0 = 0.0;
        let beta = 0.0;
        let an = 0.0;
        let bn = 0.0;
        let dResult = Toms708.brcomp(a, b, x, y);
        if (dResult === 0.0)
            return 0;
        c = 1.0 + lambda;
        c0 = b / a;
        c1 = 1.0 + 1.0 / a;
        yp1 = y + 1.0;
        n = 0.0;
        p = 1.0;
        s = a + 1.0;
        an = 0.0;
        bn = 1.0;
        anp1 = 1.0;
        bnp1 = c / c1;
        r = c1 / c;
        while (true) {
            n++;
            t = n / a;
            w = n * (b - n) * x;
            e = a / s;
            alpha = p * (p + c0) * e * e * (w * x);
            e = (1.0 + t) / (c1 + t + t);
            beta = n + w / s + e * (c + n * yp1);
            p = 1.0 + t;
            s = s + 2.0;
            t = alpha * an + beta * anp1;
            an = anp1;
            anp1 = t;
            t = alpha * bn + beta * bnp1;
            bn = bnp1;
            bnp1 = t;
            r0 = r;
            r = anp1 / bnp1;
            if (Math.abs(r - r0) <= eps * r)
                break;
            an = an / bnp1;
            bn = bn / bnp1;
            anp1 = r;
            bnp1 = 1.0;
        }
        dResult *= r;
        return dResult;
    }
    static bgrat(a, b, x, y, w, eps, ierr) {
        let j = 0.0;
        let l = 0.0;
        let lnx = 0.0;
        let nu = 0.0;
        let n2 = 0.0;
        let c = new Array(30);
        let d = new Array(30);
        let bm1 = 0.0;
        let nm1 = 0;
        let i = 0;
        let n = 0;
        let q = 0.0;
        let r = 0.0;
        let s = 0.0;
        let t = 0.0;
        let u = 0.0;
        let v = 0.0;
        let z = 0.0;
        let sum = 0.0;
        let bp2n = 0.0;
        let t2 = 0.0;
        let coef = 0.0;
        let dj = 0.0;
        let cn = 0.0;
        bm1 = b - 0.5 - 0.5;
        nu = a + 0.5 * bm1;
        if (y <= 0.375) {
            lnx = Toms708.alnrel(-y);
        }
        else {
            lnx = log(x);
        }
        z = -(nu * lnx);
        if (b * z !== 0.0) {
            r = b * (1.0 + Toms708.gam1(b)) * Math.exp(b * log(z));
            r *= Math.exp(a * lnx) * Math.exp(0.5 * bm1 * lnx);
            u = Toms708.algdiv(b, a) + b * log(nu);
            u = r * Math.exp(-u);
            if (u === 0.0) {
                ierr.val = 1;
                return;
            }
            let p1 = new NumberW_1.NumberW(0);
            let q1 = new NumberW_1.NumberW(0);
            Toms708.grat1(b, z, r, p1, q1, eps);
            q = q1.val;
            v = 0.25 * Math.pow(1.0 / nu, 2);
            t2 = 0.25 * lnx * lnx;
            l = w.val / u;
            j = q / r;
            sum = j;
            t = 1.0;
            cn = 1.0;
            n2 = 0.0;
            for (n = 1; n <= 30; n++) {
                bp2n = b + n2;
                j = (bp2n * (bp2n + 1.0) * j + (z + bp2n + 1.0) * t) * v;
                n2 = n2 + 2.0;
                t *= t2;
                cn /= n2 * (n2 + 1.0);
                c[n - 1] = cn;
                s = 0.0;
                if (n !== 1) {
                    nm1 = n - 1;
                    coef = b - n;
                    for (i = 1; i <= nm1; i++) {
                        s += coef * c[i - 1] * d[n - i - 1];
                        coef += b;
                    }
                }
                d[n - 1] = bm1 * cn + s / n;
                dj = d[n - 1] * j;
                sum += dj;
                if (sum <= 0.0) {
                    ierr.val = 1;
                    return;
                }
                if (Math.abs(dj) <= eps * (sum + l)) {
                    break;
                }
            }
            ierr.val = 0;
            w.val += u * sum;
            return;
        }
        else {
            ierr.val = 1;
            return;
        }
    }
    static brcomp(a, b, x, y) {
        const Const = 0.398942280401433;
        if (x === 0.0 || y === 0.0)
            return 0;
        let b0;
        let a0 = Math.min(a, b);
        let lnx;
        let lny;
        let c;
        if (a0 < 8.0) {
            if (x <= 0.375) {
                lnx = log(x);
                lny = Toms708.alnrel(-x);
            }
            else {
                if (y <= 0.375) {
                    lnx = Toms708.alnrel(-y);
                    lny = log(y);
                }
                else {
                    lnx = log(x);
                    lny = log(y);
                }
                let z = a * lnx + b * lny;
                if (a0 >= 1.0) {
                    z -= Toms708.betaln(a, b);
                    return Math.exp(z);
                }
                b0 = Math.max(a, b);
                if (b0 < 8.0) {
                    if (b0 <= 1.0) {
                        let dResult = Math.exp(z);
                        if (dResult === 0.0)
                            return 0;
                        let apb = a + b;
                        if (apb <= 1.0) {
                            z = 1.0 + Toms708.gam1(apb);
                        }
                        else {
                            let u = a + b - 1.0;
                            z = (1.0 + Toms708.gam1(u)) / apb;
                        }
                        c = (1.0 + Toms708.gam1(a)) * (1.0 + Toms708.gam1(b)) / z;
                        dResult *= a0 * c / (1.0 + a0 / b0);
                        return dResult;
                    }
                }
                else {
                    let u = Toms708.gamln1(a0);
                    let n = b0 - 1.0;
                    if (n >= 1) {
                        c = 1.0;
                        for (let i = 1; i <= n; i++) {
                            b0--;
                            c *= b0 / (a0 + b0);
                        }
                        u = log(c) + u;
                    }
                    z -= u;
                    b0--;
                    let apb = a0 + b0;
                    let t;
                    if (apb <= 1.0) {
                        t = 1.0 + Toms708.gam1(apb);
                    }
                    else {
                        u = a0 + b0 - 1.0;
                        t = (1.0 + Toms708.gam1(u)) / apb;
                    }
                    return a0 * Math.exp(z) * (1.0 + Toms708.gam1(b0)) / t;
                }
                let u = Toms708.gamln1(a0) + Toms708.algdiv(a0, b0);
                return a0 * Math.exp(z - u);
            }
        }
        let x0;
        let y0;
        let lambda;
        let e;
        let h;
        let u;
        let v;
        if (a <= b) {
            h = a / b;
            x0 = h / (1.0 + h);
            y0 = 1.0 / (1.0 + h);
            lambda = a - (a + b) * x;
        }
        else {
            h = b / a;
            x0 = 1.0 / (1.0 + h);
            y0 = h / (1.0 + h);
            lambda = (a + b) * y - b;
        }
        e = -lambda / a;
        if (Math.abs(e) <= 0.6) {
            u = Toms708.rlog1(e);
        }
        else {
            u = e - log(x / x0);
        }
        e = lambda / b;
        if (Math.abs(e) > 0.6) {
            v = Toms708.rlog1(e);
        }
        else {
            v = e - log(y / y0);
        }
        let z = Math.exp(-(a * u + b * v));
        return Const * Math.sqrt(b * x0) * z * Math.exp(-Toms708.bcorr(a, b));
    }
    static brcmp1(mu, a, b, x, y) {
        const invSqrtPi = 0.398942280401433;
        let c;
        let u;
        let apb;
        let a0 = Math.min(a, b);
        if (a0 < 8.0) {
            let lnx;
            let lny;
            if (x <= 0.375) {
                lnx = log(x);
                lny = Toms708.alnrel(-x);
            }
            else {
                if (y <= 0.375) {
                    lnx = Toms708.alnrel(-y);
                    lny = log(y);
                }
                else {
                    lnx = log(x);
                    lny = log(y);
                }
            }
            let z = a * lnx + b * lny;
            if (a0 <= 1.0) {
                z -= Toms708.betaln(a, b);
                return Toms708.esum(mu, z);
            }
            let b0 = Math.max(a, b);
            if (b0 >= 8.0) {
                u = Toms708.gamln1(a0) + Toms708.algdiv(a0, b0);
                return a0 * Toms708.esum(mu, z - u);
            }
            if (b0 <= 1.0) {
                let dResult = Toms708.esum(mu, z);
                if (dResult === 0.0)
                    return 0;
                apb = a + b;
                if (apb <= 1.0) {
                    z = 1.0 + Toms708.gam1(apb);
                }
                else {
                    u = a + b - 1.0;
                    z = (1.0 + Toms708.gam1(u)) / apb;
                }
                c = (1.0 + Toms708.gam1(a)) * (1.0 + Toms708.gam1(b)) / z;
                dResult *= a0 * c / (1.0 + a0 / b0);
                return dResult;
            }
            u = Toms708.gamln1(a0);
            let n = trunc(b0 - 1.0);
            if (n >= 1) {
                c = 1.0;
                for (let i = 1; i <= n; i++) {
                    b0 -= 1.0;
                    c = c * (b0 / (a0 + b0));
                }
                u = log(c) + u;
            }
            z -= u;
            b0 -= 1.0;
            apb = a0 + b0;
            let t;
            if (apb <= 1.0) {
                t = 1.0 + Toms708.gam1(apb);
            }
            else {
                u = a0 + b0 - 1.0;
                t = (1.0 + Toms708.gam1(u)) / apb;
            }
            return a0 * Toms708.esum(mu, z) * (1.0 + Toms708.gam1(b0)) / t;
        }
        let h;
        let x0;
        let y0;
        let lambda;
        if (a <= b) {
            h = a / b;
            x0 = h / (1.0 + h);
            y0 = 1.0 / (1.0 + h);
            lambda = a - (a + b) * x;
        }
        else {
            h = b / a;
            x0 = 1.0 / (1.0 + h);
            y0 = h / (1.0 + h);
            lambda = (a + b) * y - b;
        }
        let e = -lambda / a;
        if (Math.abs(e) <= 0.6) {
            u = Toms708.rlog1(e);
        }
        else {
            u = e - log(x / x0);
        }
        e = lambda / b;
        let v;
        if (Math.abs(e) <= 0.6) {
            v = Toms708.rlog1(e);
        }
        else {
            v = e - log(y / y0);
        }
        let z = Toms708.esum(mu, -(a * u + b * v));
        return invSqrtPi * Math.sqrt(b * x0) * z * Math.exp(-Toms708.bcorr(a, b));
    }
    static bpser(a, b, x, eps) {
        let n = 0.0;
        let apb = 0.0;
        let c = 0.0;
        let i = 0;
        let m = 0;
        let t = 0.0;
        let u = 0.0;
        let w = 0.0;
        let z = 0.0;
        let tol = 0.0;
        let sum = 0.0;
        let a0 = 0.0;
        let b0 = 0.0;
        let dResult = 0;
        if (x === 0.0) {
            return 0;
        }
        a0 = Math.min(a, b);
        if (a0 >= 1.0) {
            z = a * log(x) - Toms708.betaln(a, b);
            dResult = Math.exp(z) / a;
        }
        else {
            b0 = Math.max(a, b);
            if (b0 < 8.0) {
                if (b0 <= 1.0) {
                    dResult = Math.pow(x, a);
                    if (dResult === 0.0) {
                        return 0;
                    }
                    apb = a + b;
                    if (apb <= 1.0) {
                        z = 1.0 + Toms708.gam1(apb);
                    }
                    else {
                        u = a + b - 1.0;
                        z = (1.0 + Toms708.gam1(u)) / apb;
                    }
                    c = (1.0 + Toms708.gam1(a)) * (1.0 + Toms708.gam1(b)) / z;
                    dResult *= c * (b / apb);
                }
                else {
                    u = Toms708.gamln1(a0);
                    m = trunc(b0 - 1.0);
                    if (m >= 1) {
                        c = 1.0;
                        for (i = 1; i <= m; i++) {
                            b0--;
                            c *= b0 / (a0 + b0);
                        }
                        u = log(c) + u;
                    }
                    z = a * log(x) - u;
                    b0--;
                    apb = a0 + b0;
                    if (apb <= 1.0) {
                        t = 1.0 + Toms708.gam1(apb);
                    }
                    else {
                        u = a0 + b0 - 1.0;
                        t = (1.0 + Toms708.gam1(u)) / apb;
                    }
                    dResult = Math.exp(z) * (a0 / a) * (1.0 + Toms708.gam1(b0)) / t;
                }
            }
            else {
                u = Toms708.gamln1(a0) + Toms708.algdiv(a0, b0);
                z = a * log(x) - u;
                dResult = a0 / a * Math.exp(z);
            }
        }
        if (dResult === 0.0 || a <= 0.1 * eps) {
            return dResult;
        }
        sum = 0.0;
        n = 0.0;
        c = 1.0;
        tol = eps / a;
        do {
            n++;
            c *= (0.5 + (0.5 - b / n)) * x;
            w = c / (a + n);
            sum += w;
        } while (Math.abs(w) > tol);
        dResult *= 1.0 + a * sum;
        return dResult;
    }
    static bratio(a, b, x, y, w, w1, ierr) {
        let lambda = 0.0;
        let ind = 0;
        let n = 0;
        let t = 0.0;
        let eps = 0.0;
        let z = 0.0;
        let a0 = 0.0;
        let b0 = 0.0;
        let x0 = 0.0;
        let y0 = 0.0;
        eps = Toms708.spmpar(1);
        printer_bratio('eps is: %d', eps);
        w.val = 0.0;
        w1.val = 0.0;
        if (a < 0.0 || b < 0.0) {
            ierr.val = 1;
            return;
        }
        if (a === 0.0 && b === 0.0) {
            ierr.val = 2;
            return;
        }
        if (x < 0.0 || x > 1.0) {
            ierr.val = 3;
            return;
        }
        if (y < 0.0 || y > 1.0) {
            ierr.val = 4;
            return;
        }
        z = x + y - 0.5 - 0.5;
        if (abs(z) > 3.0 * eps) {
            ierr.val = 5;
            return;
        }
        ierr.val = 0;
        if (x === 0.0) {
            if (a === 0.0) {
                ierr.val = 6;
                return;
            }
            else {
                w.val = 0.0;
                w1.val = 1.0;
                return;
            }
        }
        if (y === 0.0) {
            if (b === 0.0) {
                ierr.val = 7;
                return;
            }
            else {
                w.val = 1.0;
                w1.val = 0.0;
                return;
            }
        }
        if (a === 0.0) {
            w.val = 1.0;
            w1.val = 0.0;
            return;
        }
        if (b === 0.0) {
            w.val = 0.0;
            w1.val = 1.0;
            return;
        }
        eps = Math.max(eps, 1e-15);
        if (Math.max(a, b) < 1.0e-3 * eps) {
            w.val = b / (a + b);
            w1.val = a / (a + b);
            return;
        }
        ind = 0;
        a0 = a;
        b0 = b;
        x0 = x;
        y0 = y;
        if (min(a0, b0) <= 1.0) {
            if (x <= 0.5) {
                ind = 1;
                a0 = b;
                b0 = a;
                x0 = y;
                y0 = x;
            }
            if (b0 < min(eps, eps * a0)) {
                w.val = Toms708.fpser(a0, b0, x0, eps);
                w1.val = 0.5 + (0.5 - w.val);
                if (ind === 0) {
                    return;
                }
                else {
                    t = w.val;
                    w.val = w1.val;
                    w1.val = t;
                    return;
                }
            }
            if (a0 < min(eps, eps * b0) && b0 * x0 <= 1.0) {
                w1.val = Toms708.apser(a0, b0, x0, eps);
                w.val = 0.5 + (0.5 - w1.val);
                if (ind === 0) {
                    return;
                }
                else {
                    t = w.val;
                    w.val = w1.val;
                    w1.val = t;
                    return;
                }
            }
            if (Math.max(a0, b0) <= 1.0) {
                if (a0 >= Math.min(0.2, b0) || Math.pow(x0, a0) <= 0.9) {
                    w.val = Toms708.bpser(a0, b0, x0, eps);
                    w1.val = 0.5 + (0.5 - w.val);
                    if (ind === 0) {
                        return;
                    }
                    else {
                        t = w.val;
                        w.val = w1.val;
                        w1.val = t;
                        return;
                    }
                }
                if (x0 >= 0.3) {
                    w1.val = Toms708.bpser(b0, a0, y0, eps);
                    w.val = 0.5 + (0.5 - w1.val);
                    if (ind === 0) {
                        return;
                    }
                    else {
                        t = w.val;
                        w.val = w1.val;
                        w1.val = t;
                        return;
                    }
                }
                n = 20;
                w1.val = Toms708.bup(b0, a0, y0, x0, n, eps);
                b0 += n;
                let ierr1 = new NumberW_1.NumberW(0);
                Toms708.bgrat(b0, a0, y0, x0, w1, 15.0 * eps, ierr1);
                w.val = 0.5 + (0.5 - w1.val);
                if (ind === 0) {
                    return;
                }
                else {
                    t = w.val;
                    w.val = w1.val;
                    w1.val = t;
                    return;
                }
            }
            if (b0 <= 1.0) {
                w.val = Toms708.bpser(a0, b0, x0, eps);
                w1.val = 0.5 + (0.5 - w.val);
                if (ind === 0) {
                    return;
                }
                else {
                    t = w.val;
                    w.val = w1.val;
                    w1.val = t;
                    return;
                }
            }
            if (x0 >= 0.3) {
                w1.val = Toms708.bpser(b0, a0, y0, eps);
                w.val = 0.5 + (0.5 - w1.val);
                if (ind === 0) {
                    return;
                }
                else {
                    t = w.val;
                    w.val = w1.val;
                    w1.val = t;
                    return;
                }
            }
            if (x0 < 0.1) {
                if (pow(x0 * b0, a0) <= 0.7) {
                    w.val = Toms708.bpser(a0, b0, x0, eps);
                    w1.val = 0.5 + (0.5 - w.val);
                    if (ind === 0) {
                        return;
                    }
                    else {
                        t = w.val;
                        w.val = w1.val;
                        w1.val = t;
                        return;
                    }
                }
            }
            if (b0 > 15.0) {
                let ierr1 = new NumberW_1.NumberW(0);
                Toms708.bgrat(b0, a0, y0, x0, w1, 15.0 * eps, ierr1);
                w.val = 0.5 + (0.5 - w1.val);
                if (ind === 0) {
                    return;
                }
                else {
                    t = w.val;
                    w.val = w1.val;
                    w1.val = t;
                    return;
                }
            }
            n = 20;
            w1.val = Toms708.bup(b0, a0, y0, x0, n, eps);
            b0 += n;
            let ierr1 = new NumberW_1.NumberW(0);
            Toms708.bgrat(b0, a0, y0, x0, w1, 15.0 * eps, ierr1);
            w.val = 0.5 + (0.5 - w1.val);
            if (ind === 0) {
                return;
            }
            else {
                t = w.val;
                w.val = w1.val;
                w1.val = t;
                return;
            }
        }
        if (a <= b) {
            lambda = a - (a + b) * x;
        }
        else {
            lambda = (a + b) * y - b;
        }
        if (lambda < 0.0) {
            ind = 1;
            a0 = b;
            b0 = a;
            x0 = y;
            y0 = x;
            lambda = abs(lambda);
        }
        if (b0 < 40.0 && b0 * x0 <= 0.7) {
            w.val = Toms708.bpser(a0, b0, x0, eps);
            w1.val = 0.5 + (0.5 - w.val);
            if (ind === 0) {
                return;
            }
            else {
                t = w.val;
                w.val = w1.val;
                w1.val = t;
                return;
            }
        }
        if (b0 < 40.0) {
            n = Math.trunc(b0);
            b0 -= n;
            if (b0 === 0.0) {
                n--;
                b0 = 1.0;
            }
            w.val = Toms708.bup(b0, a0, y0, x0, n, eps);
            if (x0 <= 0.7) {
                w.val += Toms708.bpser(a0, b0, x0, eps);
                w1.val = 0.5 + (0.5 - w.val);
                if (ind === 0) {
                    return;
                }
                else {
                    t = w.val;
                    w.val = w1.val;
                    w1.val = t;
                    return;
                }
            }
            if (a0 <= 15.0) {
                n = 20;
                w.val += Toms708.bup(a0, b0, x0, y0, n, eps);
                a0 += n;
            }
            let ierr1 = new NumberW_1.NumberW(0);
            Toms708.bgrat(a0, b0, x0, y0, w, 15.0 * eps, ierr1);
            w1.val = 0.5 + (0.5 - w.val);
            if (ind === 0) {
                return;
            }
            else {
                t = w.val;
                w.val = w1.val;
                w1.val = t;
                return;
            }
        }
        if (a0 <= b0) {
            if (a0 <= 100.0) {
                w.val = Toms708.bfrac(a0, b0, x0, y0, lambda, 15.0 * eps);
                w1.val = 0.5 + (0.5 - w.val);
                if (ind === 0) {
                    return;
                }
                else {
                    t = w.val;
                    w.val = w1.val;
                    w1.val = t;
                    return;
                }
            }
            if (lambda > 0.03 * a0) {
                w.val = Toms708.bfrac(a0, b0, x0, y0, lambda, 15.0 * eps);
                w1.val = 0.5 + (0.5 - w.val);
                if (ind === 0) {
                    return;
                }
                else {
                    t = w.val;
                    w.val = w1.val;
                    w1.val = t;
                    return;
                }
            }
            w.val = Toms708.basym(a0, b0, lambda, 100.0 * eps);
            w1.val = 0.5 + (0.5 - w.val);
            if (ind === 0) {
                return;
            }
            else {
                t = w.val;
                w.val = w1.val;
                w1.val = t;
                return;
            }
        }
        else {
            if (b0 <= 100.0 || lambda > 0.03 * b0) {
                w.val = Toms708.bfrac(a0, b0, x0, y0, lambda, 15.0 * eps);
                w1.val = 0.5 + (0.5 - w.val);
                if (ind === 0) {
                    return;
                }
                else {
                    t = w.val;
                    w.val = w1.val;
                    w1.val = t;
                    return;
                }
            }
            w.val = Toms708.basym(a0, b0, lambda, 100.0 * eps);
            w1.val = 0.5 + (0.5 - w.val);
            if (ind === 0) {
                return;
            }
            else {
                t = w.val;
                w.val = w1.val;
                w1.val = t;
                return;
            }
        }
    }
    static bup(a, b, x, y, n, eps) {
        let dResult;
        let mu = 0;
        let d = 1.0;
        let t = 0;
        let r = 0;
        let w = 0;
        let k;
        let l;
        let apb = a + b;
        let ap1 = a + 1.0;
        if (n !== 1 && a > 1.0) {
            if (apb >= 1.1 * ap1) {
                mu = trunc(Math.abs(Toms708.exparg(1)));
                k = trunc(Toms708.exparg(0));
                if (k < mu) {
                    mu = k;
                }
                t = mu;
                d = Math.exp(-t);
            }
        }
        dResult = Toms708.brcmp1(mu, a, b, x, y) / a;
        if (n === 1 || dResult === 0.0) {
            return dResult;
        }
        let nm1 = n - 1;
        w = d;
        k = 0;
        if (b <= 1.0) {
            let kp1 = k + 1;
            for (let i = kp1; i <= nm1; i++) {
                l = i - 1;
                d = (apb + l) / (ap1 + l) * x * d;
                w += d;
                if (d <= eps * w)
                    break;
            }
            return dResult * w;
        }
        if (y > 1.0e-4) {
            r = (b - 1.0) * x / y - a;
            if (r < 1.0) {
                let kp1 = k + 1;
                for (let i = kp1; i <= nm1; i++) {
                    l = i - 1;
                    d = (apb + l) / (ap1 + l) * x * d;
                    w += d;
                    if (d <= eps * w)
                        break;
                }
                return dResult * w;
            }
            k = nm1;
            t = nm1;
            if (r < t) {
                k = trunc(r);
            }
        }
        else {
            k = nm1;
        }
        for (let i = 1; i <= k; i++) {
            l = i - 1;
            d = (apb + l) / (ap1 + l) * x * d;
            w += d;
        }
        if (k === nm1) {
            return dResult * w;
        }
        let kp1 = k + 1;
        for (let i = kp1; i <= nm1; i++) {
            l = i - 1;
            d = (apb + l) / (ap1 + l) * x * d;
            w += d;
            if (d <= eps * w)
                break;
        }
        return dResult * w;
    }
    static erf(x) {
        const c = 0.564189583547756;
        const a = [
            0.77105849500132e-4,
            -0.133733772997339e-2,
            0.323076579225834e-1,
            0.479137145607681e-1,
            0.128379167095513
        ];
        const b = [0.301048631703895e-2, 0.538971687740286e-1, 0.375795757275549];
        const p = [
            -1.36864857382717e-7,
            5.64195517478974e-1,
            7.21175825088309,
            4.31622272220567e1,
            1.5298928504694e2,
            3.39320816734344e2,
            4.51918953711873e2,
            3.00459261020162e2
        ];
        const q = [
            1.0,
            1.27827273196294e1,
            7.70001529352295e1,
            2.77585444743988e2,
            6.38980264465631e2,
            9.3135409485061e2,
            7.90950925327898e2,
            3.00459260956983e2
        ];
        const r = [
            2.10144126479064,
            2.62370141675169e1,
            2.13688200555087e1,
            4.6580782871847,
            2.82094791773523e-1
        ];
        const s = [
            9.4153775055546e1,
            1.8711481179959e2,
            9.90191814623914e1,
            1.80124575948747e1
        ];
        let ax = 0.0;
        let bot = 0.0;
        let t = 0.0;
        let top = 0.0;
        let x2 = 0.0;
        ax = Math.abs(x);
        if (ax <= 0.5) {
            t = x * x;
            top = (((a[0] * t + a[1]) * t + a[2]) * t + a[3]) * t + a[4] + 1.0;
            bot = ((b[0] * t + b[1]) * t + b[2]) * t + 1.0;
            return x * (top / bot);
        }
        else {
            if (ax <= 4.0) {
                top =
                    ((((((p[0] * ax + p[1]) * ax + p[2]) * ax + p[3]) * ax + p[4]) * ax +
                        p[5]) *
                        ax +
                        p[6]) *
                        ax +
                        p[7];
                bot =
                    ((((((q[0] * ax + q[1]) * ax + q[2]) * ax + q[3]) * ax + q[4]) * ax +
                        q[5]) *
                        ax +
                        q[6]) *
                        ax +
                        q[7];
                return x < 0
                    ? -(0.5 + (0.5 - Math.exp(-x * x) * top / bot))
                    : 0.5 + (0.5 - Math.exp(-x * x) * top / bot);
            }
            else {
                if (ax < 5.8) {
                    x2 = x * x;
                    t = 1.0 / x2;
                    top = (((r[0] * t + r[1]) * t + r[2]) * t + r[3]) * t + r[4];
                    bot = (((s[0] * t + s[2]) * t + s[3]) * t + s[3]) * t + 1.0;
                    let dResult = (c - top / (x2 * bot)) / ax;
                    dResult = 0.5 + (0.5 - Math.exp(-x2) * dResult);
                    return x < 0 ? -dResult : dResult;
                }
                else {
                    return Toms708.sign(1.0, x);
                }
            }
        }
    }
    static erfc1(ind, x) {
        const c = 0.564189583547756;
        const a = [
            0.77105849500132e-4,
            -0.133733772997339e-2,
            0.323076579225834e-1,
            0.479137145607681e-1,
            0.128379167095513
        ];
        const b = [0.301048631703895e-2, 0.538971687740286e-1, 0.375795757275549];
        const p = [
            -1.36864857382717e-7,
            5.64195517478974e-1,
            7.21175825088309,
            4.31622272220567e1,
            1.5298928504694e2,
            3.39320816734344e2,
            4.51918953711873e2,
            3.00459261020162e2
        ];
        const q = [
            1.0,
            1.27827273196294e1,
            7.70001529352295e1,
            2.77585444743988e2,
            6.38980264465631e2,
            9.3135409485061e2,
            7.90950925327898e2,
            3.00459260956983e2
        ];
        const r = [
            2.10144126479064,
            2.62370141675169e1,
            2.13688200555087e1,
            4.6580782871847,
            2.82094791773523e-1
        ];
        const s = [
            9.4153775055546e1,
            1.8711481179959e2,
            9.90191814623914e1,
            1.80124575948747e1
        ];
        let dResult = 0.0;
        let w = 0.0;
        let ax = 0.0;
        let e = 0.0;
        let bot = 0.0;
        let t = 0.0;
        let top = 0.0;
        ax = Math.abs(x);
        if (ax < 0.5) {
            t = x * x;
            top = (((a[0] * t + a[1]) * t + a[2]) * t + a[3]) * t + a[4] + 1.0;
            bot = ((b[0] * t + b[1]) * t + b[2]) * t + 1.0;
            dResult = 0.5 + (0.5 - x * (top / bot));
            if (ind !== 0)
                dResult *= Math.exp(t);
            return dResult;
        }
        else if (ax <= 4 && ax >= 0.5) {
            top =
                ((((((p[0] * ax + p[1]) * ax + p[2]) * ax + p[3]) * ax + p[4]) * ax +
                    p[5]) *
                    ax +
                    p[6]) *
                    ax +
                    p[7];
            bot =
                ((((((q[0] * ax + q[2]) * ax + q[2]) * ax + q[3]) * ax + q[5]) * ax +
                    q[5]) *
                    ax +
                    q[6]) *
                    ax +
                    q[7];
            dResult = top / bot;
        }
        else {
            if (x <= -5.6) {
                if (ind !== 0)
                    return 2.0 * Math.exp(x * x);
                else
                    return 2.0;
            }
            if (ind !== 0) {
                t = Math.pow(1.0 / x, 2);
                top = (((r[0] * t + r[1]) * t + r[2]) * t + r[3]) * t + r[4];
                bot = (((s[0] * t + s[2]) * t + s[3]) * t + s[3]) * t + 1.0;
                dResult = (c - t * top / bot) / ax;
            }
            else {
                if (x > 100.0 || x * x > -Toms708.exparg(1)) {
                    return 0;
                }
            }
        }
        if (ind !== 0) {
            if (x < 0.0)
                dResult = 2.0 * Math.exp(x * x) - dResult;
            return dResult;
        }
        w = x * x;
        t = w;
        e = w - t;
        dResult *= (0.5 + (0.5 - e)) * Math.exp(-t);
        if (x < 0.0)
            dResult = 2.0 - dResult;
        return dResult;
    }
    static esum(mu, x) {
        let w = 0.0;
        if (x <= 0.0) {
            if (mu < 0) {
                w = mu;
                return Math.exp(w) * Math.exp(x);
            }
            w = mu + x;
            if (w > 0.0) {
                w = mu;
                return Math.exp(w) * Math.exp(x);
            }
            return Math.exp(w);
        }
        if (mu > 0) {
            w = mu;
            return Math.exp(w) * Math.exp(x);
        }
        w = mu + x;
        if (w < 0.0) {
            w = mu;
            return Math.exp(w) * Math.exp(x);
        }
        return Math.exp(w);
    }
    static erf_values(nData, x, fx) {
        const nmax = 21;
        const bvec = [
            0.0,
            0.112462916,
            0.2227025892,
            0.3286267595,
            0.428392355,
            0.5204998778,
            0.6038560908,
            0.6778011938,
            0.7421009647,
            0.7969082124,
            0.8427007929,
            0.8802050696,
            0.9103139782,
            0.9340079449,
            0.9522851198,
            0.9661051465,
            0.9763483833,
            0.9837904586,
            0.9890905016,
            0.9927904292,
            0.995322265
        ];
        let xvec = [
            0.0,
            0.1,
            0.2,
            0.3,
            0.4,
            0.5,
            0.6,
            0.7,
            0.8,
            0.9,
            1.0,
            1.1,
            1.2,
            1.3,
            1.4,
            1.5,
            1.6,
            1.7,
            1.8,
            1.9,
            2.0
        ];
        if (nData.val < 0)
            nData.val = 0;
        nData.val++;
        if (nmax < nData.val) {
            nData.val = 0;
            x.val = 0.0;
            fx.val = 0.0;
        }
        else {
            x.val = xvec[nData.val - 1];
            fx.val = bvec[nData.val - 1];
        }
    }
    static exparg(l) {
        let lnb = 0.0;
        let m = 0;
        let b = Toms708.ipmpar(4);
        switch (b) {
            case 2:
                lnb = 0.69314718055995;
                break;
            case 8:
                lnb = 2.0794415416798;
                break;
            case 16:
                lnb = 2.7725887222398;
                break;
            default:
                lnb = log(b);
                break;
        }
        if (l !== 0) {
            m = Toms708.ipmpar(6);
            return 0.99999 * m * lnb;
        }
        else {
            m = Toms708.ipmpar(7);
            return 0.99999 * m * lnb;
        }
    }
    static fpser(a, b, x, eps) {
        let c = 0.0;
        let s = 0.0;
        let t = 0.0;
        let tol = 0.0;
        let an = 0.0;
        let dResult = 1.0;
        if (a > 1.0e-3 * eps) {
            dResult = 0.0;
            t = a * log(x);
            if (t < Toms708.exparg(1)) {
                return dResult;
            }
            dResult = Math.exp(t);
        }
        dResult = b / a * dResult;
        tol = eps / a;
        an = a + 1.0;
        t = x;
        s = t / an;
        do {
            an = an + 1.0;
            t = x * t;
            c = t / an;
            s = s + c;
        } while (Math.abs(c) > tol);
        return dResult * (1.0 + a * s);
    }
    static gam1(a) {
        const p = [
            0.577215664901533,
            -0.409078193005776,
            -0.230975380857675,
            0.597275330452234e-1,
            0.76696818164949e-2,
            -0.514889771323592e-2,
            0.589597428611429e-3
        ];
        const q = [
            0.1e1,
            0.427569613095214,
            0.158451672430138,
            0.261132021441447e-1,
            0.423244297896961e-2
        ];
        const r = [
            -0.422784335098468,
            -0.771330383816272,
            -0.244757765222226,
            0.118378989872749,
            0.930357293360349e-3,
            -0.118290993445146e-1,
            0.223047661158249e-2,
            0.266505979058923e-3,
            -0.132674909766242e-3
        ];
        const s2 = 0.559398236957378e-1;
        const s1 = 0.273076135303957;
        let d = 0.0;
        let bot = 0.0;
        let t = 0.0;
        let w = 0.0;
        let top = 0.0;
        t = a;
        d = a - 0.5;
        if (d > 0.0) {
            t = d - 0.5;
        }
        if (t === 0) {
            return 0;
        }
        else if (t > 0) {
            top =
                (((((p[6] * t + p[5]) * t + p[4]) * t + p[3]) * t + p[2]) * t + p[1]) *
                    t +
                    p[0];
            bot = (((q[4] * t + q[3]) * t + q[2]) * t + q[1]) * t + 1.0;
            w = top / bot;
            if (d <= 0.0) {
                return a * w;
            }
            else {
                return t / a * (w - 0.5 - 0.5);
            }
        }
        else {
            top =
                (((((((r[8] * t + r[7]) * t + r[6]) * t + r[5]) * t + r[4]) * t +
                    r[3]) *
                    t +
                    r[2]) *
                    t +
                    r[1]) *
                    t +
                    r[0];
            bot = (s2 * t + s1) * t + 1.0;
            w = top / bot;
            if (d <= 0.0) {
                return a * (w + 0.5 + 0.5);
            }
            else {
                return t * w / a;
            }
        }
    }
    static grat1(a, x, r, p, q, eps) {
        let j = 0.0;
        let l = 0.0;
        let am0 = 0.0;
        let an0 = 0.0;
        let a2n = 0.0;
        let b2n = 0.0;
        let cma = 0.0;
        let c = 0.0;
        let g = 0.0;
        let h = 0.0;
        let t = 0.0;
        let w = 0.0;
        let z = 0.0;
        let tol = 0.0;
        let sum = 0.0;
        let a2nm1 = 0.0;
        let b2nm1 = 0.0;
        let an = 0.0;
        if (a * x === 0.0) {
            if (x <= a) {
                p.val = 0.0;
                q.val = 1.0;
                return;
            }
            else {
                p.val = 1.0;
                q.val = 0.0;
                return;
            }
        }
        if (a === 0.5) {
            if (x < 0.25) {
                p.val = Toms708.erf(Math.sqrt(x));
                q.val = 0.5 + (0.5 - p.val);
                return;
            }
            else {
                q.val = Toms708.erfc1(0, Math.sqrt(x));
                p.val = 0.5 + (0.5 - q.val);
                return;
            }
        }
        if (x < 1.1) {
            an = 3.0;
            c = x;
            sum = x / (a + 3.0);
            tol = 0.1 * eps / (a + 1.0);
            do {
                an++;
                c = -c * (x / an);
                t = c / (a + an);
                sum = sum + t;
            } while (Math.abs(t) > tol);
            j = a * x * ((sum / 6.0 - 0.5 / (a + 2.0)) * x + 1.0 / (a + 1.0));
            z = a * log(x);
            h = Toms708.gam1(a);
            g = 1.0 + h;
            if (x < 0.25) {
                if (z > -0.13394) {
                    l = Toms708.rexp(z);
                    w = 0.5 + (0.5 + l);
                    q.val = (w * j - l) * g - h;
                    if (q.val < 0.0) {
                        p.val = 1.0;
                        q.val = 0.0;
                        return;
                    }
                    p.val = 0.5 + (0.5 - q.val);
                    return;
                }
                else {
                    w = Math.exp(z);
                    p.val = w * g * (0.5 + (0.5 - j));
                    q.val = 0.5 + (0.5 - p.val);
                    return;
                }
            }
            else {
                w = Math.exp(z);
                p.val = w * g * (0.5 + (0.5 - j));
                q.val = 0.5 + (0.5 - p.val);
                return;
            }
        }
        else {
            a2nm1 = 1.0;
            a2n = 1.0;
            b2nm1 = x;
            b2n = x + (1.0 - a);
            c = 1.0;
            do {
                a2nm1 = x * a2n + c * a2nm1;
                b2nm1 = x * b2n + c * b2nm1;
                am0 = a2nm1 / b2nm1;
                c++;
                cma = c - a;
                a2n = a2nm1 + cma * a2n;
                b2n = b2nm1 + cma * b2n;
                an0 = a2n / b2n;
            } while (Math.abs(an0 - am0) >= eps * an0);
            q.val = r * an0;
            p.val = 0.5 + (0.5 - q.val);
            return;
        }
    }
    static ipmpar(i) {
        const imach = [2, 31, 2147483647, 2, 24, -125, 128, 53, -1021, 1024];
        return imach[i - 1];
    }
    static gamma_inc_values(nData, a, x, fx) {
        let nMax = 20;
        const aVec = [
            0.1,
            0.1,
            0.1,
            0.5,
            0.5,
            0.5,
            0.1e1,
            0.1e1,
            0.1e1,
            0.11e1,
            0.11e1,
            0.11e1,
            0.2e1,
            0.2e1,
            0.2e1,
            0.6e1,
            0.6e1,
            0.11e2,
            0.26e2,
            0.41e2
        ];
        const fxVec = [
            0.7382350532339351,
            0.9083579897300343,
            0.9886559833621947,
            0.3014646416966613,
            0.7793286380801532,
            0.9918490284064973,
            0.9516258196404043e-1,
            0.6321205588285577,
            0.9932620530009145,
            0.7205974576054322e-1,
            0.5891809618706485,
            0.9915368159845525,
            0.01018582711118352,
            0.4421745996289254,
            0.9927049442755639,
            0.4202103819530612e-1,
            0.9796589705830716,
            0.9226039842296429,
            0.4470785799755852,
            0.7444549220718699
        ];
        const xVec = [
            0.3e-1,
            0.3,
            0.15e1,
            0.75e-1,
            0.75,
            0.35e1,
            0.1,
            0.1e1,
            0.5e1,
            0.1,
            0.1e1,
            0.5e1,
            0.15,
            0.15e1,
            0.7e1,
            0.25e1,
            0.12e2,
            0.16e2,
            0.25e2,
            0.45e2
        ];
        if (nData.val < 0)
            nData.val = 0;
        nData.val++;
        if (nMax < nData.val) {
            nData.val = 0;
            a.val = 0.0;
            x.val = 0.0;
            fx.val = 0.0;
        }
        else {
            a.val = aVec[nData.val - 1];
            x.val = xVec[nData.val - 1];
            fx.val = fxVec[nData.val - 1];
        }
    }
    static gamma_log_values(nData, x, fx) {
        const nmax = 18;
        const bvec = [
            1.524064183,
            0.7966780066,
            0.3982337117,
            0.1520599127,
            0.0,
            -0.04987246543,
            -0.08537410945,
            -0.1081747934,
            -0.119612895,
            -0.120782204,
            -0.1125917658,
            -0.09580771625,
            -0.07108385116,
            -0.0389842838,
            0.0,
            12.80182743,
            39.33988571,
            71.25704193
        ];
        const xvec = [
            0.2,
            0.4,
            0.6,
            0.8,
            1.0,
            1.1,
            1.2,
            1.3,
            1.4,
            1.5,
            1.6,
            1.7,
            1.8,
            1.9,
            2.0,
            10.0,
            20.0,
            30.0
        ];
        if (nData.val < 0)
            nData.val = 0;
        nData.val++;
        if (nmax < nData.val) {
            nData.val = 0;
            x.val = 0.0;
            fx.val = 0.0;
        }
        else {
            x.val = xvec[nData.val - 1];
            fx.val = bvec[nData.val - 1];
        }
    }
    static gamln(a) {
        const d = 0.418938533204673;
        const c5 = -0.165322962780713e-2;
        const c4 = 0.837308034031215e-3;
        const c3 = -0.59520293135187e-3;
        const c2 = 0.79365066682539e-3;
        const c1 = -0.277777777760991e-2;
        const c0 = 0.833333333333333e-1;
        let i = 0;
        let n = 0;
        let t = 0.0;
        let w = 0.0;
        if (a <= 0.8)
            return Toms708.gamln1(a) - log(a);
        if (a <= 2.25) {
            t = a - 0.5 - 0.5;
            return Toms708.gamln1(t);
        }
        if (a < 10.0) {
            n = trunc(a - 1.25);
            t = a;
            w = 1.0;
            for (i = 1; i <= n; i++) {
                t--;
                w *= t;
            }
            return Toms708.gamln1(t - 1.0) + log(w);
        }
        t = Math.pow(1.0 / a, 2);
        w = (((((c5 * t + c4) * t + c3) * t + c2) * t + c1) * t + c0) / a;
        return d + w + (a - 0.5) * (log(a) - 1.0);
    }
    static gamln1(a) {
        const p6 = -0.271935708322958e-2;
        const p5 = -0.673562214325671e-1;
        const p4 = -0.402055799310489;
        const p3 = -0.780427615533591;
        const p2 = -0.168860593646662;
        const p1 = 0.844203922187225;
        const p0 = 0.577215664901533;
        const q6 = 0.667465618796164e-3;
        const q5 = 0.325038868253937e-1;
        const q4 = 0.361951990101499;
        const q3 = 0.156875193295039e1;
        const q2 = 0.312755088914843e1;
        const q1 = 0.288743195473681e1;
        const r5 = 0.497958207639485e-3;
        const r4 = 0.17050248402265e-1;
        const r3 = 0.156513060486551;
        const r2 = 0.565221050691933;
        const r1 = 0.848044614534529;
        const r0 = 0.422784335098467;
        const s5 = 0.116165475989616e-3;
        const s4 = 0.713309612391e-2;
        const s3 = 0.10155218743983;
        const s2 = 0.548042109832463;
        const s1 = 0.124313399877507e1;
        let w = 0.0;
        let x = 0.0;
        if (a < 0.6) {
            w =
                ((((((p6 * a + p5) * a + p4) * a + p3) * a + p2) * a + p1) * a + p0) /
                    ((((((q6 * a + q5) * a + q4) * a + q3) * a + q2) * a + q1) * a + 1.0);
            return -a * w;
        }
        x = a - 0.5 - 0.5;
        w =
            (((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x + r0) /
                (((((s5 * x + s4) * x + s3) * x + s2) * x + s1) * x + 1.0);
        return x * w;
    }
    static gsumln(a, b) {
        let x = a + b - 2;
        if (x <= 0.25)
            return Toms708.gamln1(1.0 + x);
        if (x <= 1.25)
            return Toms708.gamln1(x) + Toms708.alnrel(x);
        return Toms708.gamln1(x - 1.0) + log(x * (1.0 + x));
    }
    static psi(xx) {
        const piov4 = 0.785398163397448;
        const dx0 = 1.461632144968362341262659542325721325;
        const p1 = [
            0.89538502298197e-2,
            0.477762828042627e1,
            0.142441585084029e3,
            0.118645200713425e4,
            0.363351846806499e4,
            0.413810161269013e4,
            0.130560269827897e4
        ];
        const q1 = [
            0.448452573429826e2,
            0.520752771467162e3,
            0.22100079924783e4,
            0.364127349079381e4,
            0.1908310765963e4,
            0.691091682714533e-5
        ];
        const p2 = [
            -0.212940445131011e1,
            -0.701677227766759e1,
            -0.448616543918019e1,
            -0.648157123766197
        ];
        const q2 = [
            0.322703493791143e2,
            0.892920700481861e2,
            0.546117738103215e2,
            0.777788548522962e1
        ];
        let nq = 0;
        let xsmall = 0.0;
        let xmax1 = 0.0;
        let den = 0.0;
        let i = 0;
        let aug = 0.0;
        let m = 0;
        let n = 0;
        let sgn = 0.0;
        let w = 0.0;
        let x = 0.0;
        let z = 0.0;
        let upper = 0.0;
        let xmx0 = 0.0;
        xmax1 = Toms708.ipmpar(3);
        xmax1 = Math.min(xmax1, 1.0 / Toms708.spmpar(1));
        xsmall = 1e-9;
        x = xx;
        aug = 0.0;
        if (x < 0.5) {
            if (Math.abs(x) <= xsmall) {
                if (x === 0.0)
                    return 0;
                aug = -1 / x;
            }
            else {
                w = -x;
                sgn = piov4;
                if (w <= 0.0) {
                    w = -w;
                    sgn = -sgn;
                }
                if (w >= xmax1)
                    return 0;
                nq = trunc(w);
                w = w - nq;
                nq = trunc(w * 4.0);
                w = 4.0 * (w - nq * 0.25);
                n = nq / 2;
                if (n + n !== nq) {
                    w = 1.0 - w;
                }
                z = piov4 * w;
                m = n / 2;
                if (m + m !== n) {
                    sgn = -sgn;
                }
                n = (nq + 1) / 2;
                m = n / 2;
                m = m + m;
                if (m === n) {
                    if (z === 0.0)
                        return 0;
                    aug = sgn * (Math.cos(z) / Math.sin(z) * 4.0);
                }
                else {
                    aug = sgn * (Math.sin(z) / Math.cos(z) * 4.0);
                }
            }
            x = 1 - x;
        }
        if (x <= 3.0) {
            den = x;
            upper = p1[1] * x;
            for (i = 0; i < 5; i++) {
                den = (den + q1[i]) * x;
                upper = (upper + p1[i + 1]) * x;
            }
            den = (upper + p1[6]) / (den + q1[5]);
            xmx0 = x - dx0;
            return den * xmx0 + aug;
        }
        if (x < xmax1) {
            w = 1.0 / (x * x);
            den = w;
            upper = p2[0] * w;
            for (i = 0; i < 3; i++) {
                den = (den + q2[i]) * w;
                upper = (upper + p2[i + 1]) * w;
            }
            aug = upper / (den + q2[3]) - 0.5 / x + aug;
        }
        return aug + log(x);
    }
    static psi_values(n, x, fx) {
        const nmax = 11;
        const fxvec = [
            -0.5772156649,
            -0.4237549404,
            -0.2890398966,
            -0.1691908889,
            -0.0613845446,
            -0.036489974,
            0.1260474528,
            0.2085478749,
            0.2849914333,
            0.3561841612,
            0.4227843351
        ];
        const xvec = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0];
        if (n.val < 0)
            n.val = 0;
        n.val++;
        if (nmax < n.val) {
            n.val = 0;
            x.val = 0.0;
            fx.val = 0.0;
        }
        else {
            x.val = xvec[n.val - 1];
            fx.val = fxvec[n.val - 1];
        }
    }
    static r4_epsilon() {
        let r = 1.0;
        let rTest = 1.0 + r / 2.0;
        while (1.0 < rTest) {
            r = r / 2.0;
            rTest = 1.0 + r / 2.0;
        }
        return r;
    }
    static rexp(x) {
        const q4 = 0.595130811860248e-3;
        const q3 = -0.119041179760821e-1;
        const q2 = 0.107141568980644;
        const q1 = -0.499999999085958;
        const p2 = 0.238082361044469e-1;
        const p1 = 0.914041914819518e-9;
        let w = 0.0;
        if (Math.abs(x) <= 0.15) {
            return (x *
                (((p2 * x + p1) * x + 1.0) / (((q4 * x + q3) * x + q2) * x + q1) * x +
                    1.0));
        }
        else {
            w = Math.exp(x);
            if (x <= 0.0) {
                return w - 0.5 - 0.5;
            }
            else {
                return w * (0.5 + (0.5 - 1.0 / w));
            }
        }
    }
    static rlog1(x) {
        const a = 0.566749439387324e-1;
        const b = 0.456512608815524e-1;
        const p2 = 0.620886815375787e-2;
        const p1 = -0.224696413112536;
        const p0 = 0.333333333333333;
        const q2 = 0.354508718369557;
        const q1 = -0.127408923933623e1;
        let h = 0.0;
        let r = 0.0;
        let t = 0.0;
        let w = 0.0;
        let w1 = 0.0;
        if (x < -0.39 || x > 0.57) {
            w = x + 0.5 + 0.5;
            return x - log(w);
        }
        if (x < -0.18) {
            h = x + 0.3;
            h = h / 0.7;
            w1 = a - h * 0.3;
        }
        else if (x > 0.18) {
            h = 0.75 * x - 0.25;
            w1 = b + h / 3.0;
        }
        else {
            h = x;
            w1 = 0.0;
        }
        r = h / (h + 2.0);
        t = r * r;
        w = ((p2 * t + p1) * t + p0) / ((q2 * t + q1) * t + 1.0);
        return 2.0 * t * (1.0 / (1.0 - r) - r * w) + w1;
    }
    static sign(a1, a2) {
        return a2 >= 0 ? Math.abs(a1) : -Math.abs(a1);
    }
    static spmpar(i) {
        let emin = 0;
        let emax = 0;
        let binv = 0.0;
        let bm1 = 0.0;
        let ibeta = 0;
        let b = 0.0;
        let m = 0;
        let one = 0.0;
        let w = 0.0;
        let z = 0.0;
        if (i > 1) {
            if (i > 2) {
                ibeta = Toms708.ipmpar(4);
                m = Toms708.ipmpar(5);
                emax = Toms708.ipmpar(7);
                b = ibeta;
                bm1 = ibeta - 1;
                one = 1.0;
                z = Math.pow(b, m - 1);
                w = ((z - one) * b + bm1) / (b * z);
                z = Math.pow(b, emax - 2);
                return w * z * b * b;
            }
            else {
                b = Toms708.ipmpar(4);
                emin = Toms708.ipmpar(6);
                one = 1.0;
                binv = one / b;
                w = Math.pow(b, emin + 2);
                return w * binv * binv * binv;
            }
        }
        b = Toms708.ipmpar(4);
        m = Toms708.ipmpar(5);
        return Math.pow(b, 1 - m);
    }
}
exports.Toms708 = Toms708;

});

var toms708 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberW = exports.Toms708 = void 0;

Object.defineProperty(exports, "Toms708", { enumerable: true, get: function () { return toms708$1.Toms708; } });

Object.defineProperty(exports, "NumberW", { enumerable: true, get: function () { return NumberW_1.NumberW; } });

});

var pbeta_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pbeta = exports.pbeta_raw = void 0;




const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const { LN2: M_LN2, log } = Math;
const printer_pbeta_raw = src('pbeta_raw');
function pbeta_raw(x, a, b, lower_tail, log_p) {
    if (a === 0 || b === 0 || !R_FINITE(a) || !R_FINITE(b)) {
        if (a === 0 && b === 0)
            return log_p ? -M_LN2 : 0.5;
        if (a === 0 || a / b === 0)
            return _general.R_DT_1(lower_tail, log_p);
        if (b === 0 || b / a === 0)
            return _general.R_DT_0(lower_tail, log_p);
        if (x < 0.5)
            return _general.R_DT_0(lower_tail, log_p);
        else
            return _general.R_DT_1(lower_tail, log_p);
    }
    let x1 = 0.5 - x + 0.5;
    let w = new toms708.NumberW(0);
    let wc = new toms708.NumberW(0);
    let ierr = new toms708.NumberW(0);
    printer_pbeta_raw('before Toms708.bratio, a=%d, b=%d, x=%d, w=%d,wc=%d, ierr=%d', a, b, x, w.val, wc.val, ierr.val);
    toms708.Toms708.bratio(a, b, x, x1, w, wc, ierr);
    printer_pbeta_raw('after Toms708.bratio, a=%d, b=%d, x=%d, w=%d,wc=%d, ierr=%d', a, b, x, w.val, wc.val, ierr.val);
    if (ierr.val && ierr.val !== 11 && ierr.val !== 14)
        printer_pbeta_raw('pbeta_raw(%d, a=%d, b=%d, ..) -> bratio() gave error code %d', x, a, b, ierr);
    if (log_p) {
        w.val = log(w.val);
        wc.val = log(wc.val);
    }
    return lower_tail ? w.val : wc.val;
}
exports.pbeta_raw = pbeta_raw;
const printer_pbeta = src('pbeta');
function pbeta(q, a, b, lowerTail = true, logP = false) {
    return rFunc.map(q)(x => {
        printer_pbeta('pbeta(q=%d, a=%d, b=%d, l.t=%s, ln=%s)', x, a, b, lowerTail, logP);
        if (ISNAN(x) || ISNAN(a) || ISNAN(b))
            return NaN;
        if (a < 0 || b < 0)
            return _general.ML_ERR_return_NAN(printer_pbeta);
        if (x <= 0)
            return _general.R_DT_0(lowerTail, logP);
        if (x >= 1)
            return _general.R_DT_1(lowerTail, logP);
        return pbeta_raw(x, a, b, lowerTail, logP);
    });
}
exports.pbeta = pbeta;

});

var pnbeta_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pnbeta = exports.pnbeta2 = void 0;




const { log1p, floor, max: fmax2, sqrt, log, exp } = Math;
const { isNaN: ISNAN } = Number;
const printer = src('pnbeta_raw');
function pnbeta_raw(x, o_x, a, b, ncp) {
    const errmax = 1.0e-9;
    const itrmax = 10000;
    let a0;
    let lbeta;
    let c;
    let errbd;
    let x0;
    let temp = new toms708.NumberW(0);
    let tmp_c = new toms708.NumberW(0);
    let ierr = new toms708.NumberW(0);
    let ans;
    let ax;
    let gx;
    let q;
    let sumq;
    if (ncp < 0 || a <= 0 || b <= 0) {
        return _general.ML_ERR_return_NAN(printer);
    }
    if (x < 0 || o_x > 1 || (x === 0 && o_x === 1))
        return 0;
    if (x > 1 || o_x < 0 || (x === 1 && o_x === 0))
        return 1;
    c = ncp / 2;
    x0 = floor(fmax2(c - 7 * sqrt(c), 0));
    a0 = a + x0;
    lbeta = lgamma_fn.lgammafn(a0) + lgamma_fn.lgammafn(b) - lgamma_fn.lgammafn(a0 + b);
    toms708.Toms708.bratio(a0, b, x, o_x, temp, tmp_c, ierr);
    gx = exp(a0 * log(x) + b * (x < 0.5 ? log1p(-x) : log(o_x)) - lbeta - log(a0));
    if (a0 > a)
        q = exp(-c + x0 * log(c) - lgamma_fn.lgammafn(x0 + 1));
    else
        q = exp(-c);
    sumq = 1 - q;
    ans = ax = q * temp.val;
    let j = floor(x0);
    do {
        j++;
        temp.val -= gx;
        gx *= x * (a + b + j - 1) / (a + j);
        q *= c / j;
        sumq -= q;
        ax = temp.val * q;
        ans += ax;
        errbd = (temp.val - gx) * sumq;
    } while (errbd > errmax && j < itrmax + x0);
    if (errbd > errmax)
        _general.ML_ERROR(_general.ME.ME_PRECISION, 'pnbeta', printer);
    if (j >= itrmax + x0)
        _general.ML_ERROR(_general.ME.ME_NOCONV, 'pnbeta', printer);
    return ans;
}
const printer_pnbeta2 = src('pnbeta2');
function pnbeta2(x, o_x, a, b, ncp, lower_tail, log_p) {
    let ans = pnbeta_raw(x, o_x, a, b, ncp);
    if (lower_tail) {
        return log_p ? log(ans) : ans;
    }
    else {
        if (ans > 1 - 1e-10)
            _general.ML_ERROR(_general.ME.ME_PRECISION, 'pnbeta', printer_pnbeta2);
        if (ans > 1.0)
            ans = 1.0;
        return log_p ? log1p(-ans) : 1 - ans;
    }
}
exports.pnbeta2 = pnbeta2;
function pnbeta(_x, a, b, ncp, lower_tail, log_p) {
    const fa = Array.isArray(_x) ? _x : [_x];
    const result = fa.map(x => {
        if (ISNAN(x) || ISNAN(a) || ISNAN(b) || ISNAN(ncp))
            return x + a + b + ncp;
        let rc = _general.R_P_bounds_01(lower_tail, log_p, x, 0, 1);
        if (rc !== undefined) {
            return rc;
        }
        return pnbeta2(x, 1 - x, a, b, ncp, lower_tail, log_p);
    });
    return result.length === 1 ? result[0] : result;
}
exports.pnbeta = pnbeta;

});

var expm1_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.R_D_LExp = exports.R_Log1_Exp = exports.R_DT_Clog = exports.R_DT_log = exports.R_DT_CIv = exports.R_DT_qIv = void 0;

const { exp, expm1, log, log1p } = Math;
function R_DT_qIv(lower_tail, log_p, p) {
    return log_p ? (lower_tail ? exp(p) : -expm1(p)) : _general.R_D_Lval(lower_tail, p);
}
exports.R_DT_qIv = R_DT_qIv;
function R_DT_CIv(lower_tail, log_p, p) {
    return log_p ? (lower_tail ? -expm1(p) : exp(p)) : _general.R_D_Cval(lower_tail, p);
}
exports.R_DT_CIv = R_DT_CIv;
function R_D_LExp(log_p, x) {
    return log_p ? R_Log1_Exp(x) : log1p(-x);
}
exports.R_D_LExp = R_D_LExp;
function R_Log1_Exp(x) {
    if (x > -_general.M_LN2) {
        return log(-expm1(x));
    }
    return log1p(-exp(x));
}
exports.R_Log1_Exp = R_Log1_Exp;
function R_DT_Clog(lower_tail, log_p, p) {
    return lower_tail
        ? R_D_LExp(log_p, p)
        : _general.R_D_log(log_p, p);
}
exports.R_DT_Clog = R_DT_Clog;
function R_DT_log(lower_tail, log_p, p) {
    return lower_tail ? _general.R_D_log(log_p, p) : R_D_LExp(log_p, p);
}
exports.R_DT_log = R_DT_log;

});

var qbeta_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qbeta_raw = exports.qbeta = void 0;





const { expm1, log1p, sqrt, min: fmin2, exp, abs: fabs, log, pow, max: fmax2 } = Math;
const { isNaN: ISNAN, MIN_VALUE: DBL_MIN, EPSILON: DBL_EPSILON, POSITIVE_INFINITY: ML_POSINF, NEGATIVE_INFINITY: ML_NEGINF, isFinite: R_FINITE, NaN: ML_NAN } = Number;
const USE_LOG_X_CUTOFF = -5;
const n_NEWTON_FREE = 4;
const MLOGICAL_NA = -1;
const printer_qbeta = src('qbeta');
function qbeta(pp, shape1, shape2, lower_tail, log_p) {
    const fa = Array.isArray(pp) ? pp : [pp];
    const result = fa.map(p => {
        if (ISNAN(shape1) || ISNAN(shape2) || ISNAN(p))
            return shape1 + shape2 + p;
        if (shape1 < 0 || shape2 < 0) {
            return _general.ML_ERR_return_NAN(printer_qbeta);
        }
        let qbet = [0, 0];
        qbeta_raw(p, shape1, shape2, lower_tail, log_p, MLOGICAL_NA, USE_LOG_X_CUTOFF, n_NEWTON_FREE, qbet);
        return qbet[0];
    });
    return result.length === 1 ? result[0] : result;
}
exports.qbeta = qbeta;
const DBL_very_MIN = DBL_MIN / 4;
const DBL_log_v_MIN = _general.M_LN2 * (_general.DBL_MIN_EXP - 2);
const DBL_1__eps = 1 - DBL_EPSILON;
const fpu = 3e-308;
const acu_min = 1e-300;
const p_lo = fpu;
const p_hi = 1 - 2.22e-16;
const const1 = 2.30753;
const const2 = 0.27061;
const const3 = 0.99229;
const const4 = 0.04481;
function return_q_0(give_log_q, qb) {
    if (give_log_q) {
        qb[0] = ML_NEGINF;
        qb[1] = 0;
    }
    else {
        qb[0] = 0;
        qb[1] = 1;
    }
    return;
}
function return_q_1(give_log_q, qb) {
    if (give_log_q) {
        qb[0] = 0;
        qb[1] = ML_NEGINF;
    }
    else {
        qb[0] = 1;
        qb[1] = 0;
    }
    return;
}
function return_q_half(give_log_q, qb) {
    if (give_log_q) {
        qb[0] = qb[1] = -_general.M_LN2;
    }
    else {
        qb[0] = qb[1] = 0.5;
    }
    return;
}
const printer_qbeta_raw = src('qbeta_raw');
const R_ifDEBUG_printf = printer_qbeta_raw;
function qbeta_raw(alpha, p, q, lower_tail, log_p, swap_01, log_q_cut, n_N, qb) {
    let swap_choose = swap_01 === MLOGICAL_NA;
    let swap_tail;
    let log_;
    let give_log_q = log_q_cut === ML_POSINF;
    let use_log_x = give_log_q;
    let warned = false;
    let add_N_step = true;
    let i_pb;
    let i_inn;
    let a;
    let la;
    let logbeta;
    let g;
    let h;
    let pp;
    let p_;
    let qq;
    let r;
    let s;
    let t;
    let w;
    let y = -1;
    let u = 0;
    let xinbta = 0;
    let u_n = 0;
    if (alpha === _general.R_DT_0(lower_tail, log_p)) {
        return return_q_0(give_log_q, qb);
    }
    if (alpha === _general.R_DT_1(lower_tail, log_p)) {
        return return_q_1(give_log_q, qb);
    }
    if ((log_p && alpha > 0) || (!log_p && (alpha < 0 || alpha > 1))) {
        printer_qbeta_raw('qbeta(alpha=%d, %d, %d, .., log_p=%d): %s%s', alpha, p, q, log_p, 'alpha not in ', log_p ? '[-Inf, 0]' : '[0,1]');
        _general.ML_ERROR(_general.ME.ME_DOMAIN, '', printer_qbeta_raw);
        qb[0] = qb[1] = ML_NAN;
        return;
    }
    if (p === 0 || q === 0 || !R_FINITE(p) || !R_FINITE(q)) {
        printer_qbeta_raw('qbeta(%d, %d, %d, lower_t=%d, log_p=%d): (p,q)-boundary: trivial', alpha, p, q, lower_tail, log_p);
        if (p === 0 && q === 0) {
            if (alpha < _general.R_D_half(log_p)) {
                return_q_0(give_log_q, qb);
            }
            if (alpha > _general.R_D_half(log_p)) {
                return_q_1(give_log_q, qb);
            }
            return_q_half(give_log_q, qb);
        }
    }
    p_ = expm1_1.R_DT_qIv(lower_tail, log_p, alpha);
    logbeta = lbeta_1.lbeta(p, q);
    swap_tail = swap_choose ? p_ > 0.5 : swap_01;
    if (swap_tail) {
        a = expm1_1.R_DT_CIv(lower_tail, log_p, alpha);
        la = expm1_1.R_DT_Clog(lower_tail, log_p, alpha);
        pp = q;
        qq = p;
    }
    else {
        a = p_;
        la = expm1_1.R_DT_log(lower_tail, log_p, alpha);
        pp = p;
        qq = q;
    }
    let acu = fmax2(acu_min, pow(10, -13 - 2.5 / (pp * pp) - 0.5 / (a * a)));
    let tx = 0;
    let u0 = (la + log(pp) + logbeta) / pp;
    let log_eps_c = _general.M_LN2 * (1 - _general.DBL_MANT_DIG);
    r = pp * (1 - qq) / (pp + 1);
    t = 0.2;
    printer_qbeta_raw('qbeta(%d, %d, %d, lower_t=%d, log_p=%d):%s   swap_tail=%d, la=%d, u0=%d (bnd: %d (%d)) ', alpha, p, q, lower_tail, log_p, log_p && (p_ === 0 || p_ === 1) ? (p_ === 0 ? ' p_=0' : ' p_=1') : '', swap_tail, la, u0, (t * log_eps_c - log(fabs(pp * (1 - qq) * (2 - qq) / (2 * (pp + 2))))) / 2, t * log_eps_c - log(fabs(r)));
    let goto_L_Newton = false;
    let goto_L_return = false;
    let goto_L_converged = false;
    if (_general.M_LN2 * _general.DBL_MIN_EXP < u0 &&
        u0 < -0.01 &&
        u0 <
            (t * log_eps_c - log(fabs(pp * (1 - qq) * (2 - qq) / (2 * (pp + 2))))) / 2) {
        r = r * exp(u0);
        if (r > -1) {
            u = u0 - log1p(r) / pp;
            printer_qbeta_raw('u1-u0=%d --> choosing u = u1', u - u0);
        }
        else {
            u = u0;
            printer_qbeta_raw('cannot cheaply improve u0');
        }
        tx = xinbta = exp(u);
        use_log_x = true;
        goto_L_Newton = true;
    }
    if (!goto_L_Newton) {
        r = sqrt(-2 * la);
        y = r - (const1 + const2 * r) / (1 + (const3 + const4 * r) * r);
        if (pp > 1 && qq > 1) {
            r = (y * y - 3) / 6;
            s = 1 / (pp + pp - 1);
            t = 1 / (qq + qq - 1);
            h = 2 / (s + t);
            w = y * sqrt(h + r) / h - (t - s) * (r + 5.0 / 6.0 - 2.0 / (3 * h));
            printer_qbeta_raw('p,q > 1 => w=%d', w);
            if (w > 300) {
                t = w + w + log(qq) - log(pp);
                u =
                    t <= 18 ? -log1p(exp(t)) : -t - exp(-t);
                xinbta = exp(u);
            }
            else {
                xinbta = pp / (pp + qq * exp(w + w));
                u = -log1p(qq / pp * exp(w + w));
            }
        }
        else {
            r = qq + qq;
            t = 1 / (3 * sqrt(qq));
            t = r * _general.R_pow_di(1 + t * (-t + y), 3);
            s = 4 * pp + r - 2;
            R_ifDEBUG_printf('min(p,q) <= 1: t=%g', t);
            if (t === 0 || (t < 0 && s >= t)) {
                let l1ma;
                if (swap_tail)
                    l1ma = expm1_1.R_DT_log(lower_tail, log_p, alpha);
                else
                    l1ma = expm1_1.R_DT_Clog(lower_tail, log_p, alpha);
                R_ifDEBUG_printf(' t <= 0 : log1p(-a)=%.15g, better l1ma=%.15g\n', log1p(-a), l1ma);
                let xx = (l1ma + log(qq) + logbeta) / qq;
                if (xx <= 0) {
                    xinbta = -expm1(xx);
                    u = expm1_1.R_Log1_Exp(xx);
                }
                else {
                    R_ifDEBUG_printf(' xx=%g > 0: xinbta:= 1-e^xx < 0\n', xx);
                    xinbta = 0;
                    u = ML_NEGINF;
                }
            }
            else {
                t = s / t;
                R_ifDEBUG_printf(' t > 0 or s < t < 0:  new t = %g ( > 1 ?)\n', t);
                if (t <= 1) {
                    u = (la + log(pp) + logbeta) / pp;
                    xinbta = exp(u);
                }
                else {
                    xinbta = 1 - 2 / (t + 1);
                    u = log1p(-2 / (t + 1));
                }
            }
        }
        if (swap_choose &&
            ((swap_tail && u >= -exp(log_q_cut)) ||
                (!swap_tail && u >= -exp(4 * log_q_cut) && pp / qq < 1000))) {
            swap_tail = !swap_tail;
            R_ifDEBUG_printf(' u = %g (e^u = xinbta = %.16g) ==> ', u, xinbta);
            if (swap_tail) {
                a = expm1_1.R_DT_CIv(lower_tail, log_p, alpha);
                la = expm1_1.R_DT_Clog(lower_tail, log_p, alpha);
                pp = q;
                qq = p;
            }
            else {
                a = p_;
                la = expm1_1.R_DT_log(lower_tail, log_p, alpha);
                pp = p;
                qq = q;
            }
            R_ifDEBUG_printf('"%s\'; la = %g\n', swap_tail ? 'swap now' : 'swap back', la);
            u = expm1_1.R_Log1_Exp(u);
            xinbta = exp(u);
        }
        if (!use_log_x)
            use_log_x = u < log_q_cut;
        let bad_u = !R_FINITE(u);
        let bad_init = bad_u || xinbta > p_hi;
        R_ifDEBUG_printf(' -> u = %g, e^u = xinbta = %.16g, (Newton acu=%g%s)\n', u, xinbta, acu, bad_u ? ', ** bad u **' : use_log_x ? ', on u = log(x) scale' : '');
        u_n = 1;
        tx = xinbta;
        if (bad_u || u < log_q_cut) {
            w = pbeta_1.pbeta_raw(DBL_very_MIN, pp, qq, true, log_p);
            if (w > (log_p ? la : a)) {
                R_ifDEBUG_printf(' quantile is left of smallest positive number; "convergence"\n');
                if (log_p || fabs(w - a) < fabs(0 - a)) {
                    tx = DBL_very_MIN;
                    u_n = DBL_log_v_MIN;
                }
                else {
                    tx = 0;
                    u_n = ML_NEGINF;
                }
                use_log_x = log_p;
                add_N_step = false;
                goto_L_return = true;
            }
            else {
                R_ifDEBUG_printf(' pbeta(smallest pos.) = %g <= %g  --> continuing\n', w, log_p ? la : a);
                if (u < DBL_log_v_MIN) {
                    u = DBL_log_v_MIN;
                    xinbta = DBL_very_MIN;
                }
            }
        }
        if (bad_init && !(use_log_x && tx > 0)) {
            if (u === ML_NEGINF) {
                R_ifDEBUG_printf('  u = -Inf;');
                u = _general.M_LN2 * _general.DBL_MIN_EXP;
                xinbta = DBL_MIN;
            }
            else {
                R_ifDEBUG_printf(' bad_init: u=%g, xinbta=%g;', u, xinbta);
                xinbta =
                    xinbta > 1.1
                        ? 0.5
                        : xinbta < p_lo ? exp(u) : p_hi;
                if (bad_u)
                    u = log(xinbta);
            }
            R_ifDEBUG_printf(' -> (partly)new u=%g, xinbta=%g\n', u, xinbta);
        }
    }
    if (!goto_L_return) {
        r = 1 - pp;
        t = 1 - qq;
        let wprev = 0;
        let prev = 1;
        let adj = 1;
        if (use_log_x) {
            for (i_pb = 0; i_pb < 1000; i_pb++) {
                y = pbeta_1.pbeta_raw(xinbta, pp, qq, true, true);
                w =
                    y === ML_NEGINF
                        ? 0
                        : (y - la) * exp(y - u + logbeta + r * u + t * expm1_1.R_Log1_Exp(u));
                if (!R_FINITE(w))
                    break;
                if (i_pb >= n_N && w * wprev <= 0)
                    prev = fmax2(fabs(adj), fpu);
                R_ifDEBUG_printf('N(i=%2d): u=%#20.16g, pb(e^u)=%#12.6g, w=%#15.9g, %s prev=%11g,', i_pb, u, y, w, w * wprev <= 0 ? 'new' : 'old', prev);
                g = 1;
                for (i_inn = 0; i_inn < 1000; i_inn++) {
                    adj = g * w;
                    if (i_pb < n_N || fabs(adj) < prev) {
                        u_n = u - adj;
                        if (u_n <= 0) {
                            if (prev <= acu || fabs(w) <= acu) {
                                R_ifDEBUG_printf(' it{in}=%d, -adj=%g, %s <= acu  ==> convergence\n', i_inn, -adj, prev <= acu ? 'prev' : '|w|');
                                goto_L_converged = true;
                                break;
                            }
                            break;
                        }
                    }
                    g /= 3;
                }
                if (goto_L_converged) {
                    break;
                }
                let D = fmin2(fabs(adj), fabs(u_n - u));
                R_ifDEBUG_printf(' it{in}=%d, delta(u)=%9.3g, D/|.|=%.3g\n', i_inn, u_n - u, D / fabs(u_n + u));
                if (D <= 4e-16 * fabs(u_n + u)) {
                    goto_L_converged = true;
                    break;
                }
                u = u_n;
                xinbta = exp(u);
                wprev = w;
            }
        }
        else {
            for (i_pb = 0; i_pb < 1000; i_pb++) {
                y = pbeta_1.pbeta_raw(xinbta, pp, qq, true, log_p);
                if (!R_FINITE(y) && !(log_p && y === ML_NEGINF)) {
                    _general.ML_ERROR(_general.ME.ME_DOMAIN, '', printer_qbeta_raw);
                    qb[0] = qb[1] = ML_NAN;
                    return;
                }
                w = log_p
                    ? (y - la) * exp(y + logbeta + r * log(xinbta) + t * log1p(-xinbta))
                    : (y - a) * exp(logbeta + r * log(xinbta) + t * log1p(-xinbta));
                if (i_pb >= n_N && w * wprev <= 0)
                    prev = fmax2(fabs(adj), fpu);
                R_ifDEBUG_printf('N(i=%2d): x0=%d, pb(x0)=%d, w=%d, %s prev=%d,', i_pb, xinbta, y, w, w * wprev <= 0 ? 'new' : 'old', prev);
                g = 1;
                for (i_inn = 0; i_inn < 1000; i_inn++) {
                    adj = g * w;
                    if (i_pb < n_N || fabs(adj) < prev) {
                        tx = xinbta - adj;
                        if (0 <= tx && tx <= 1) {
                            if (prev <= acu || fabs(w) <= acu) {
                                R_ifDEBUG_printf(' it{in}=%d, delta(x)=%g, %s <= acu  ==> convergence\n', i_inn, -adj, prev <= acu ? 'prev' : '|w|');
                                goto_L_converged = true;
                                break;
                            }
                            if (tx !== 0 && tx !== 1)
                                break;
                        }
                    }
                    g /= 3;
                }
                if (goto_L_converged) {
                    break;
                }
                R_ifDEBUG_printf(' it{in}=%d, delta(x)=%g\n', i_inn, tx - xinbta);
                if (fabs(tx - xinbta) <= 4e-16 * (tx + xinbta)) {
                    goto_L_converged = true;
                    break;
                }
                xinbta = tx;
                if (tx === 0)
                    break;
                wprev = w;
            }
        }
        if (!goto_L_converged) {
            warned = true;
            _general.ML_ERROR(_general.ME.ME_PRECISION, 'qbeta', printer_qbeta_raw);
        }
        log_ = log_p || use_log_x;
        R_ifDEBUG_printf(' %s: Final delta(y) = %g%s\n', warned ? '_NO_ convergence' : 'converged', y - (log_ ? la : a), log_ ? ' (log_)' : '');
        if ((log_ && y === ML_NEGINF) || (!log_ && y === 0)) {
            w = pbeta_1.pbeta_raw(DBL_very_MIN, pp, qq, true, log_);
            if (log_ || fabs(w - a) <= fabs(y - a)) {
                tx = DBL_very_MIN;
                u_n = DBL_log_v_MIN;
            }
            add_N_step = false;
        }
        else if (!warned && (log_ ? fabs(y - la) > 3 : fabs(y - a) > 1e-4)) {
            if (!(log_ &&
                y === ML_NEGINF &&
                pbeta_1.pbeta_raw(DBL_1__eps, pp, qq, true, true) >
                    la + 2))
                printer_qbeta_raw('qbeta(a, *) =: x0 with |pbeta(x0,* %s) - alpha| = %d is not accurate', log_ ? ', log_' : '', fabs(y - (log_ ? la : a)));
        }
    }
    if (give_log_q) {
        if (!use_log_x)
            printer_qbeta_raw('qbeta() L_return, u_n=%d;  give_log_q=TRUE but use_log_x=FALSE -- please report!', u_n);
        let r = expm1_1.R_Log1_Exp(u_n);
        if (swap_tail) {
            qb[0] = r;
            qb[1] = u_n;
        }
        else {
            qb[0] = u_n;
            qb[1] = r;
        }
    }
    else {
        if (use_log_x) {
            if (add_N_step) {
                xinbta = exp(u_n);
                y = pbeta_1.pbeta_raw(xinbta, pp, qq, true, log_p);
                w = log_p
                    ? (y - la) * exp(y + logbeta + r * log(xinbta) + t * log1p(-xinbta))
                    : (y - a) * exp(logbeta + r * log(xinbta) + t * log1p(-xinbta));
                tx = xinbta - w;
                R_ifDEBUG_printf('Final Newton correction(non-log scale): xinbta=%.16g, y=%g, w=%g. => new tx=%.16g\n', xinbta, y, w, tx);
            }
            else {
                if (swap_tail) {
                    qb[0] = -expm1(u_n);
                    qb[1] = exp(u_n);
                }
                else {
                    qb[0] = exp(u_n);
                    qb[1] = -expm1(u_n);
                }
                return;
            }
        }
        if (swap_tail) {
            qb[0] = 1 - tx;
            qb[1] = tx;
        }
        else {
            qb[0] = tx;
            qb[1] = 1 - tx;
        }
    }
    return;
}
exports.qbeta_raw = qbeta_raw;

});

var qnbeta_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qnbeta = void 0;





const { isNaN: ISNAN, isFinite: R_FINITE, MIN_VALUE: DBL_MIN, EPSILON: DBL_EPSILON } = Number;
const { min: fmin2 } = Math;
const printer_qnbeta = src('qnbeta');
function qnbeta(_p, a, b, ncp, lower_tail, log_p) {
    const accu = 1e-15;
    const Eps = 1e-14;
    return rFunc.map(_p)(p => {
        let ux;
        let lx;
        let nx;
        let pp;
        if (ISNAN(p) || ISNAN(a) || ISNAN(b) || ISNAN(ncp))
            return p + a + b + ncp;
        if (!R_FINITE(a))
            return _general.ML_ERR_return_NAN(printer_qnbeta);
        if (ncp < 0 || a <= 0 || b <= 0)
            return _general.ML_ERR_return_NAN(printer_qnbeta);
        let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, 0, 1);
        if (rc !== undefined) {
            return rc;
        }
        p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
        if (p > 1 - DBL_EPSILON)
            return 1.0;
        pp = fmin2(1 - DBL_EPSILON, p * (1 + Eps));
        for (ux = 0.5; ux < 1 - DBL_EPSILON && pnbeta_1.pnbeta(ux, a, b, ncp, true, false) < pp; ux = 0.5 * (1 + ux))
            ;
        pp = p * (1 - Eps);
        for (lx = 0.5; lx > DBL_MIN && pnbeta_1.pnbeta(lx, a, b, ncp, true, false) > pp; lx *= 0.5)
            ;
        do {
            nx = 0.5 * (lx + ux);
            if (pnbeta_1.pnbeta(nx, a, b, ncp, true, false) > p)
                ux = nx;
            else
                lx = nx;
        } while ((ux - lx) / nx > accu);
        return 0.5 * (ux + lx);
    });
}
exports.qnbeta = qnbeta;

});

var sexp = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.exp_rand = void 0;
function exp_rand(unif_rand) {
    const q = [
        0.6931471805599453,
        0.9333736875190459,
        0.9888777961838675,
        0.9984959252914960,
        0.9998292811061389,
        0.9999833164100727,
        0.9999985691438767,
        0.9999998906925558,
        0.9999999924734159,
        0.9999999995283275,
        0.9999999999728814,
        0.9999999999985598,
        0.9999999999999289,
        0.9999999999999968,
        0.9999999999999999,
        1.0000000000000000
    ];
    let a = 0.;
    let u = unif_rand();
    while (u <= 0. || u >= 1.)
        u = unif_rand();
    while (true) {
        u += u;
        if (u > 1.)
            break;
        a += q[0];
    }
    u -= 1.;
    if (u <= q[0])
        return a + u;
    let i = 0;
    let ustar = unif_rand();
    let umin = ustar;
    do {
        ustar = unif_rand();
        if (umin > ustar)
            umin = ustar;
        i++;
    } while (u > q[i]);
    return a + umin * q[0];
}
exports.exp_rand = exp_rand;

});

var rgamma_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports._rgamma = exports.rgamma = void 0;



const { expm1, abs: fabs, sqrt, log, exp } = Math;
const { isFinite: R_FINITE } = Number;
function rgamma(n = 1, a = 1, scale = 1, rng) {
    const result = new Array(n).fill(0).map(() => _rgamma(a, scale, rng));
    return result.length === 1 ? result[0] : result;
}
exports.rgamma = rgamma;
const printer_rgamma = src('_rgamma');
function _rgamma(a = 1, scale = 1, rng) {
    const sqrt32 = 5.656854;
    const exp_m1 = 0.36787944117144232159;
    const q1 = 0.04166669;
    const q2 = 0.02083148;
    const q3 = 0.00801191;
    const q4 = 0.00144121;
    const q5 = -7.388e-5;
    const q6 = 2.4511e-4;
    const q7 = 2.424e-4;
    const a1 = 0.3333333;
    const a2 = -0.250003;
    const a3 = 0.2000062;
    const a4 = -0.1662921;
    const a5 = 0.1423657;
    const a6 = -0.1367177;
    const a7 = 0.1233795;
    let aa = 0;
    let aaa = 0;
    let s = 0;
    let s2 = 0;
    let d = 0;
    let q0 = 0;
    let b = 0;
    let si = 0;
    let c = 0;
    let e = 0;
    let p = 0;
    let q = 0;
    let r = 0;
    let t = 0;
    let u = 0;
    let v = 0;
    let w = 0;
    let x = 0;
    let ret_val = 0;
    if (!R_FINITE(a) || !R_FINITE(scale) || a < 0.0 || scale <= 0.0) {
        if (scale === 0)
            return 0;
        return _general.ML_ERR_return_NAN(printer_rgamma);
    }
    if (a < 1) {
        if (a === 0)
            return 0;
        e = 1.0 + exp_m1 * a;
        while (true) {
            p = e * rng.unif_rand();
            if (p >= 1.0) {
                x = -log((e - p) / a);
                if (sexp.exp_rand(rng.unif_rand) >= (1.0 - a) * log(x))
                    break;
            }
            else {
                x = exp(log(p) / a);
                if (sexp.exp_rand(rng.unif_rand) >= x)
                    break;
            }
        }
        return scale * x;
    }
    if (a !== aa) {
        aa = a;
        s2 = a - 0.5;
        s = sqrt(s2);
        d = sqrt32 - s * 12.0;
    }
    t = rng.norm_rand();
    x = s + 0.5 * t;
    ret_val = x * x;
    if (t >= 0.0)
        return scale * ret_val;
    u = rng.unif_rand();
    if (d * u <= t * t * t)
        return scale * ret_val;
    if (a !== aaa) {
        aaa = a;
        r = 1.0 / a;
        q0 =
            ((((((q7 * r + q6) * r + q5) * r + q4) * r + q3) * r + q2) * r + q1) * r;
        if (a <= 3.686) {
            b = 0.463 + s + 0.178 * s2;
            si = 1.235;
            c = 0.195 / s - 0.079 + 0.16 * s;
        }
        else if (a <= 13.022) {
            b = 1.654 + 0.0076 * s2;
            si = 1.68 / s + 0.275;
            c = 0.062 / s + 0.024;
        }
        else {
            b = 1.77;
            si = 0.75;
            c = 0.1515 / s;
        }
    }
    if (x > 0.0) {
        v = t / (s + s);
        if (fabs(v) <= 0.25)
            q =
                q0 +
                    0.5 *
                        t *
                        t *
                        ((((((a7 * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1) *
                        v;
        else
            q = q0 - s * t + 0.25 * t * t + (s2 + s2) * log(1.0 + v);
        if (log(1.0 - u) <= q)
            return scale * ret_val;
    }
    while (true) {
        e = sexp.exp_rand(rng.unif_rand);
        u = rng.unif_rand();
        u = u + u - 1.0;
        if (u < 0.0)
            t = b - si * e;
        else
            t = b + si * e;
        if (t >= -0.71874483771719) {
            v = t / (s + s);
            if (fabs(v) <= 0.25)
                q =
                    q0 +
                        0.5 *
                            t *
                            t *
                            ((((((a7 * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v +
                                a1) *
                            v;
            else
                q = q0 - s * t + 0.25 * t * t + (s2 + s2) * log(1.0 + v);
            if (q > 0.0) {
                w = expm1(q);
                if (c * fabs(u) <= w * exp(e - 0.5 * t * t))
                    break;
            }
        }
    }
    x = s + 0.5 * t;
    return scale * x * x;
}
exports._rgamma = _rgamma;

});

var rchisq_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rchisq = void 0;




const { isFinite: R_FINITE } = Number;
const printer = src('rchisq');
const sequence = rFunc.seq()();
function rchisq(n, df, rng) {
    return rFunc.map(sequence(n))(() => {
        if (!R_FINITE(df) || df < 0.0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        return rgamma_1.rgamma(1, df / 2.0, 2.0, rng);
    });
}
exports.rchisq = rchisq;

});

var fsign_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.fsign = void 0;
const { abs: fabs } = Math;
const { isNaN: ISNAN } = Number;
function fsign(x, signal) {
    if (ISNAN(x))
        return x;
    return signal ? fabs(x) : -fabs(x);
}
exports.fsign = fsign;

});

var rpois_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rpois = void 0;





const { trunc, log, abs: fabs, pow, exp, floor, sqrt } = Math;
const { isFinite: R_FINITE } = Number;
const sequence = rFunc.seq()();
const a0 = -0.5;
const a1 = 0.3333333;
const a2 = -0.2500068;
const a3 = 0.2000118;
const a4 = -0.1661269;
const a5 = 0.1421878;
const a6 = -0.1384794;
const a7 = 0.125006;
const one_7 = 0.1428571428571428571;
const one_12 = 0.0833333333333333333;
const one_24 = 0.0416666666666666667;
function rpois(N, mu, rng) {
    return rFunc.map(sequence(N))(() => _rpois(mu, rng));
}
exports.rpois = rpois;
const printer_rpois = src('_rpois');
function _rpois(mu, rng) {
    const fact = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880];
    let l = 0;
    let m = 0;
    let pp = new Array(36);
    let b1 = 0;
    let b2 = 0;
    let c = 0;
    let c0 = 0;
    let c1 = 0;
    let c2 = 0;
    let c3 = 0;
    let p0 = 0;
    let p = 0;
    let q = 0;
    let s = 0;
    let d = 0;
    let omega = 0;
    let big_l = 0;
    let muprev = 0;
    let muprev2 = 0;
    let del;
    let difmuk = 0;
    let E = 0;
    let fk = 0;
    let fx;
    let fy;
    let g;
    let px;
    let py;
    let t = 0;
    let u = 0;
    let v;
    let x;
    let pois = -1;
    let k;
    let kflag = 0;
    let big_mu;
    let new_big_mu = false;
    if (!R_FINITE(mu) || mu < 0) {
        return _general.ML_ERR_return_NAN(printer_rpois);
    }
    if (mu <= 0)
        return 0;
    big_mu = mu >= 10;
    if (big_mu) {
        new_big_mu = false;
    }
    if (!(big_mu && mu === muprev)) {
        if (big_mu) {
            new_big_mu = true;
            muprev = mu;
            s = sqrt(mu);
            d = 6 * mu * mu;
            big_l = floor(mu - 1.1484);
        }
        else {
            if (mu !== muprev) {
                muprev = mu;
                m = _general.imax2(1, trunc(mu));
                l = 0;
                q = p0 = p = exp(-mu);
            }
            while (true) {
                u = rng.unif_rand();
                if (u <= p0)
                    return 0;
                if (l !== 0) {
                    for (k = u <= 0.458 ? 1 : _general.imin2(l, m); k <= l; k++)
                        if (u <= pp[k])
                            return k;
                    if (l === 35)
                        continue;
                }
                l++;
                for (k = l; k <= 35; k++) {
                    p *= mu / k;
                    q += p;
                    pp[k] = q;
                    if (u <= q) {
                        l = k;
                        return k;
                    }
                }
                l = 35;
            }
        }
    }
    g =
        mu + s * rng.norm_rand();
    if (g >= 0) {
        pois = floor(g);
        if (pois >= big_l)
            return pois;
        fk = pois;
        difmuk = mu - fk;
        u = rng.unif_rand();
        if (d * u >= difmuk * difmuk * difmuk)
            return pois;
    }
    if (new_big_mu || mu !== muprev2) {
        muprev2 = mu;
        omega = _general.M_1_SQRT_2PI / s;
        b1 = one_24 / mu;
        b2 = 0.3 * b1 * b1;
        c3 = one_7 * b1 * b2;
        c2 = b2 - 15 * c3;
        c1 = b1 - 6 * b2 + 45 * c3;
        c0 = 1 - b1 + 3 * b2 - 15 * c3;
        c = 0.1069 / mu;
    }
    let gotoStepF = false;
    let once = true;
    while (true) {
        if (once) {
            once = false;
            if (g >= 0) {
                kflag = 0;
                gotoStepF = true;
            }
        }
        if (!gotoStepF) {
            E = sexp.exp_rand(rng.unif_rand);
            u = 2 * rng.unif_rand() - 1;
            t = 1.8 + fsign_1.fsign(E, u >= 0);
        }
        if (t > -0.6744 || gotoStepF) {
            if (!gotoStepF) {
                pois = floor(mu + s * t);
                fk = pois;
                difmuk = mu - fk;
                kflag = 1;
            }
            gotoStepF = false;
            if (pois < 10) {
                px = -mu;
                py = pow(mu, pois) / fact[trunc(pois)];
            }
            else {
                del = one_12 / fk;
                del = del * (1 - 4.8 * del * del);
                v = difmuk / fk;
                if (fabs(v) <= 0.25)
                    px =
                        fk *
                            v *
                            v *
                            (((((((a7 * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v +
                                a1) *
                                v +
                                a0) -
                            del;
                else
                    px = fk * log(1 + v) - difmuk - del;
                py = _general.M_1_SQRT_2PI / sqrt(fk);
            }
            x = (0.5 - difmuk) / s;
            x *= x;
            fx = -0.5 * x;
            fy = omega * (((c3 * x + c2) * x + c1) * x + c0);
            if (kflag > 0) {
                if (c * fabs(u) <= py * exp(px + E) - fy * exp(fx + E)) {
                    break;
                }
            }
            else if (fy - u * fy <= py * exp(px - fx)) {
                break;
            }
        }
    }
    return pois;
}

});

var rnchisq_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rnchisq = void 0;





const printer = src('rnchisq');
const { isFinite: R_FINITE } = Number;
function rnchisq(n, df, lambda, rng) {
    const result = new Array(n).fill(0).map(() => {
        if (!R_FINITE(df) || !R_FINITE(lambda) || df < 0 || lambda < 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (lambda === 0) {
            return df === 0 ? 0 : rgamma_1.rgamma(1, df / 2, 2, rng);
        }
        else {
            let r = rpois_1.rpois(1, lambda / 2, rng);
            if (r > 0)
                r = rchisq_1.rchisq(1, 2 * r, rng);
            if (df > 0)
                r += rgamma_1.rgamma(1, df / 2, 2, rng);
            return r;
        }
    });
    return result.length === 1 ? result[0] : result;
}
exports.rnchisq = rnchisq;

});

var fixup_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixup = exports.i2_32m1 = void 0;
exports.i2_32m1 = 2.328306437080797e-10;
function fixup(x) {
    if (x <= 0.0)
        return 0.5 * exports.i2_32m1;
    if (1.0 - x <= 0.0)
        return 1.0 - 0.5 * exports.i2_32m1;
    return x;
}
exports.fixup = fixup;

});

var irng = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.IRNG = exports.segFnCache = void 0;

exports.segFnCache = rFunc.seq();
class IRNG {
    constructor(_seed) {
        this.notify = new Set();
        this.emit = this.emit.bind(this);
        this.register = this.register.bind(this);
        this.unif_rand = this.unif_rand.bind(this);
        this.internal_unif_rand = this.internal_unif_rand.bind(this);
        this.init = this.init.bind(this);
        this._setup();
        this.init(_seed);
    }
    get name() {
        return this._name;
    }
    get kind() {
        return this._kind;
    }
    init(_seed) {
        this.emit('INIT');
    }
    unif_rand(n = 1) {
        n = (!n || n < 0) ? 1 : n;
        return rFunc.map(exports.segFnCache()(n))(() => this.internal_unif_rand());
    }
    register(event, handler) {
        this.notify.add({ event, handler });
    }
    emit(event) {
        this.notify.forEach(r => {
            if (r.event === event) {
                r.handler();
            }
        });
    }
}
exports.IRNG = IRNG;

});

var irngType = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.IRNGType = void 0;
(function (IRNGType) {
    IRNGType[IRNGType["WICHMANN_HILL"] = 0] = "WICHMANN_HILL";
    IRNGType[IRNGType["MARSAGLIA_MULTICARRY"] = 1] = "MARSAGLIA_MULTICARRY";
    IRNGType[IRNGType["SUPER_DUPER"] = 2] = "SUPER_DUPER";
    IRNGType[IRNGType["MERSENNE_TWISTER"] = 3] = "MERSENNE_TWISTER";
    IRNGType[IRNGType["KNUTH_TAOCP"] = 4] = "KNUTH_TAOCP";
    IRNGType[IRNGType["KNUTH_TAOCP2002"] = 5] = "KNUTH_TAOCP2002";
    IRNGType[IRNGType["LECUYER_CMRG"] = 6] = "LECUYER_CMRG";
})(exports.IRNGType || (exports.IRNGType = {}));

});

var timeseed_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeseed = void 0;
const { trunc, ceil, min, log2, pow } = Math;
const { now } = Date;
function timeseed() {
    const n = now();
    do {
        now();
    } while (now() - n < 500);
    const nBits = min(32, ceil(log2(n)));
    const lowBits = trunc(nBits / 2);
    const hi = trunc(n / pow(2, lowBits));
    const lo = n - hi * pow(2, lowBits);
    const buf = new ArrayBuffer(4);
    const reverser = new Uint8Array(buf);
    const uint32 = new Uint32Array(buf);
    uint32[0] = lo ^ hi;
    reverser.reverse();
    return uint32[0];
}
exports.timeseed = timeseed;

});

var mersenneTwister = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.MersenneTwister = void 0;
const N = 624;
const M = 397;
const MATRIX_A = 0x9908b0df;
const UPPER_MASK = 0x80000000;
const LOWER_MASK = 0x7fffffff;
const TEMPERING_MASK_B = 0x9d2c5680;
const TEMPERING_MASK_C = 0xefc60000;




const SEED_LEN = 625;
class MersenneTwister extends irng.IRNG {
    constructor(_seed = timeseed_1.timeseed()) {
        super(_seed);
    }
    MT_sgenrand(seed) {
        for (let i = 0; i < N; i++) {
            this.mt[i] = seed & 0xffff0000;
            seed = 69069 * seed + 1;
            this.mt[i] |= (seed & 0xffff0000) >>> 16;
            seed = 69069 * seed + 1;
        }
        this.mti = N;
    }
    MT_genrand() {
        let y = new Int32Array(1);
        let mag01 = new Int32Array([0x0, MATRIX_A]);
        const dummy = this.m_seed;
        this.mti = dummy[0];
        if (this.mti >= N) {
            let kk;
            if (this.mti === N + 1)
                this.MT_sgenrand(4357);
            for (kk = 0; kk < N - M; kk++) {
                y[0] = (this.mt[kk] & UPPER_MASK) | (this.mt[kk + 1] & LOWER_MASK);
                this.mt[kk] = this.mt[kk + M] ^ (y[0] >>> 1) ^ mag01[y[0] & 0x1];
            }
            for (; kk < N - 1; kk++) {
                y[0] = (this.mt[kk] & UPPER_MASK) | (this.mt[kk + 1] & LOWER_MASK);
                this.mt[kk] = this.mt[kk + (M - N)] ^ (y[0] >>> 1) ^ mag01[y[0] & 0x1];
            }
            y[0] = (this.mt[N - 1] & UPPER_MASK) | (this.mt[0] & LOWER_MASK);
            this.mt[N - 1] = this.mt[M - 1] ^ (y[0] >>> 1) ^ mag01[y[0] & 0x1];
            this.mti = 0;
        }
        y[0] = this.mt[this.mti++];
        y[0] ^= y[0] >>> 11;
        y[0] ^= (y[0] << 7) & TEMPERING_MASK_B;
        y[0] ^= (y[0] << 15) & TEMPERING_MASK_C;
        y[0] ^= y[0] >>> 18;
        dummy[0] = this.mti;
        return (new Uint32Array(y.buffer)[0] * 2.3283064365386963e-10);
    }
    fixupSeeds() {
        const s = this.m_seed;
        s[0] = 624;
        if (s[0] <= 0)
            s[0] = 624;
        if (this.mt.find(v => !!v) === undefined) {
            this.init(timeseed_1.timeseed());
        }
        return;
    }
    _setup() {
        const buf = new ArrayBuffer(SEED_LEN * 4);
        this._kind = irngType.IRNGType.MERSENNE_TWISTER;
        this._name = 'Mersenne-Twister';
        this.m_seed = new Int32Array(buf).fill(0);
        this.mt = new Int32Array(buf, 4);
        this.mti = N + 1;
    }
    init(_seed = timeseed_1.timeseed()) {
        const s = new Uint32Array([0]);
        s[0] = _seed;
        for (let j = 0; j < 50; j++) {
            s[0] = 69069 * s[0] + 1;
        }
        for (let j = 0; j < this.m_seed.length; j++) {
            s[0] = 69069 * s[0] + 1;
            this.m_seed[j] = s[0];
        }
        this.fixupSeeds();
        super.init(_seed);
    }
    internal_unif_rand() {
        let rc = this.MT_genrand();
        return fixup_1.fixup(rc);
    }
    set seed(_seed) {
        if (_seed.length > this.m_seed.length || _seed.length === 0) {
            this.init(timeseed_1.timeseed());
            return;
        }
        this.m_seed.set(_seed);
    }
    get seed() {
        return Array.from(this.m_seed);
    }
}
exports.MersenneTwister = MersenneTwister;

});

var inormalRng = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.IRNGNormal = void 0;


class IRNGNormal {
    constructor(_rng) {
        this.rng = _rng;
        this.unif_rand = this.unif_rand.bind(this);
        this.norm_rand = this.norm_rand.bind(this);
        this.internal_norm_rand = this.internal_norm_rand.bind(this);
    }
    norm_rand(n = 1) {
        n = !n || n < 0 ? 1 : n;
        return rFunc.map(irng.segFnCache()(n))(() => this.internal_norm_rand());
    }
    unif_rand(n = 1) {
        return this.rng.unif_rand(n);
    }
}
exports.IRNGNormal = IRNGNormal;

});

var buggyKindermanRamage = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuggyKindermanRamage = void 0;


const { log, sqrt, min: fmin2, max: fmax2, abs: fabs, exp } = Math;
class BuggyKindermanRamage extends inormalRng.IRNGNormal {
    constructor(_rng = new mersenneTwister.MersenneTwister(0)) {
        super(_rng);
    }
    internal_norm_rand() {
        const A = 2.216035867166471;
        const C1 = 0.398942280401433;
        const C2 = 0.180025191068563;
        const g = (x) => C1 * exp(-x * x / 2.0) - C2 * (A - x);
        const u1 = this.rng.unif_rand();
        let u2;
        let u3;
        let tt;
        if (u1 < 0.884070402298758) {
            let u2 = this.rng.unif_rand();
            return A * (1.1311316354418 * u1 + u2 - 1);
        }
        if (u1 >= 0.973310954173898) {
            for (;;) {
                u2 = this.rng.unif_rand();
                u3 = this.rng.unif_rand();
                tt = A * A - 2 * log(u3);
                if (u2 * u2 < A * A / tt)
                    return u1 < 0.986655477086949 ? sqrt(tt) : -sqrt(tt);
            }
        }
        if (u1 >= 0.958720824790463) {
            for (;;) {
                u2 = this.rng.unif_rand();
                u3 = this.rng.unif_rand();
                tt = A - 0.63083480192196 * fmin2(u2, u3);
                if (fmax2(u2, u3) <= 0.755591531667601)
                    return u2 < u3 ? tt : -tt;
                if (0.034240503750111 * fabs(u2 - u3) <= g(tt))
                    return u2 < u3 ? tt : -tt;
            }
        }
        if (u1 >= 0.911312780288703) {
            for (;;) {
                u2 = this.rng.unif_rand();
                u3 = this.rng.unif_rand();
                tt = 0.479727404222441 + 1.10547366102207 * fmin2(u2, u3);
                if (fmax2(u2, u3) <= 0.87283497667179)
                    return u2 < u3 ? tt : -tt;
                if (0.049264496373128 * fabs(u2 - u3) <= g(tt))
                    return u2 < u3 ? tt : -tt;
            }
        }
        for (;;) {
            u2 = this.rng.unif_rand();
            u3 = this.rng.unif_rand();
            tt = 0.479727404222441 - 0.59550713801594 * fmin2(u2, u3);
            if (fmax2(u2, u3) <= 0.805577924423817)
                return u2 < u3 ? tt : -tt;
        }
    }
}
exports.BuggyKindermanRamage = BuggyKindermanRamage;

});

var boxMuller = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.BoxMuller = void 0;


const { log, sqrt, cos, sin } = Math;
const DBL_MIN = 2.22507e-308;
const M_PI = 3.14159265358979323846264338327950288;
class BoxMuller extends inormalRng.IRNGNormal {
    constructor(_rng = new mersenneTwister.MersenneTwister(0)) {
        super(_rng);
        this.BM_norm_keep = 0;
        _rng.register('INIT', this.reset.bind(this));
    }
    reset() {
        this.BM_norm_keep = 0;
    }
    internal_norm_rand() {
        let s = 0.0;
        let theta = 0;
        if (this.BM_norm_keep !== 0.0) {
            s = this.BM_norm_keep;
            this.BM_norm_keep = 0.0;
            return s;
        }
        else {
            theta = 2 * M_PI * this.rng.unif_rand();
            let R = sqrt(-2 * log(this.rng.unif_rand())) +
                10 * DBL_MIN;
            this.BM_norm_keep = R * sin(theta);
            return R * cos(theta);
        }
    }
}
exports.BoxMuller = BoxMuller;

});

var ahrens_dieter = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.AhrensDieter = void 0;


const a = [
    0.0,
    0.03917609,
    0.07841241,
    0.1177699,
    0.1573107,
    0.1970991,
    0.2372021,
    0.2776904,
    0.3186394,
    0.3601299,
    0.4022501,
    0.4450965,
    0.4887764,
    0.5334097,
    0.5791322,
    0.626099,
    0.6744898,
    0.7245144,
    0.7764218,
    0.8305109,
    0.8871466,
    0.9467818,
    1.00999,
    1.077516,
    1.150349,
    1.229859,
    1.318011,
    1.417797,
    1.534121,
    1.67594,
    1.862732,
    2.153875
];
const d = [
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.2636843,
    0.2425085,
    0.2255674,
    0.2116342,
    0.1999243,
    0.1899108,
    0.1812252,
    0.1736014,
    0.1668419,
    0.1607967,
    0.1553497,
    0.1504094,
    0.1459026,
    0.14177,
    0.1379632,
    0.1344418,
    0.1311722,
    0.128126,
    0.1252791,
    0.1226109,
    0.1201036,
    0.1177417,
    0.1155119,
    0.1134023,
    0.1114027,
    0.1095039
];
const t = [
    7.673828e-4,
    0.00230687,
    0.003860618,
    0.005438454,
    0.007050699,
    0.008708396,
    0.01042357,
    0.01220953,
    0.01408125,
    0.01605579,
    0.0181529,
    0.02039573,
    0.02281177,
    0.02543407,
    0.02830296,
    0.03146822,
    0.03499233,
    0.03895483,
    0.04345878,
    0.04864035,
    0.05468334,
    0.06184222,
    0.07047983,
    0.08113195,
    0.09462444,
    0.1123001,
    0.136498,
    0.1716886,
    0.2276241,
    0.330498,
    0.5847031
];
const h = [
    0.03920617,
    0.03932705,
    0.03950999,
    0.03975703,
    0.04007093,
    0.04045533,
    0.04091481,
    0.04145507,
    0.04208311,
    0.04280748,
    0.04363863,
    0.04458932,
    0.04567523,
    0.04691571,
    0.04833487,
    0.04996298,
    0.05183859,
    0.05401138,
    0.05654656,
    0.0595313,
    0.06308489,
    0.06737503,
    0.07264544,
    0.07926471,
    0.08781922,
    0.09930398,
    0.1155599,
    0.1404344,
    0.1836142,
    0.2790016,
    0.7010474
];
class AhrensDieter extends inormalRng.IRNGNormal {
    constructor(_rng = new mersenneTwister.MersenneTwister(0)) {
        super(_rng);
    }
    internal_norm_rand() {
        let u1 = this.rng.unif_rand();
        let s = 0.0;
        let w;
        let aa;
        let tt;
        let u2;
        let y;
        if (u1 > 0.5) {
            s = 1.0;
        }
        u1 = u1 + u1 - s;
        u1 *= 32.0;
        const i = new Int32Array([u1]);
        if (i[0] === 32)
            i[0] = 31;
        if (i[0] !== 0) {
            u2 = u1 - i[0];
            aa = a[i[0] - 1];
            while (u2 <= t[i[0] - 1]) {
                u1 = this.rng.unif_rand();
                w = u1 * (a[i[0]] - aa);
                tt = (w * 0.5 + aa) * w;
                for (;;) {
                    if (u2 > tt) {
                        y = aa + w;
                        return s === 1.0 ? -y : y;
                    }
                    u1 = this.rng.unif_rand();
                    if (u2 < u1)
                        break;
                    tt = u1;
                    u2 = this.rng.unif_rand();
                }
                u2 = this.rng.unif_rand();
            }
            w = (u2 - t[i[0] - 1]) * h[i[0] - 1];
        }
        else {
            i[0] = 6;
            aa = a[31];
            for (;;) {
                u1 = u1 + u1;
                if (u1 >= 1.0)
                    break;
                aa = aa + d[i[0] - 1];
                i[0] = i[0] + 1;
            }
            u1 = (u1 - 1.0);
            jump: for (;;) {
                w = u1 * d[i[0] - 1];
                tt = (w * 0.5 + aa) * w;
                for (;;) {
                    u2 = this.rng.unif_rand();
                    if (u2 > tt)
                        break jump;
                    u1 = this.rng.unif_rand();
                    if (u2 < u1)
                        break;
                    tt = u1;
                }
                u1 = this.rng.unif_rand();
            }
        }
        y = aa + w;
        return s === 1.0 ? -y : y;
    }
}
exports.AhrensDieter = AhrensDieter;

});

var qnorm_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qnorm = void 0;




const printer = src('qnorm');
const { isNaN: ISNAN } = Number;
const { log, sqrt, abs: fabs } = Math;
const ML_NEGINF = -Infinity;
const ML_POSINF = Infinity;
function qnorm(p, mu = 0, sigma = 1, lower_tail = true, log_p = false) {
    let q;
    let p_;
    let r;
    let val;
    return rFunc.map(p)(fx => {
        if (ISNAN(fx) || ISNAN(mu) || ISNAN(sigma))
            return fx + mu + sigma;
        let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, fx, ML_NEGINF, ML_POSINF);
        if (rc !== undefined) {
            return rc;
        }
        if (sigma < 0)
            return _general.ML_ERR_return_NAN(printer);
        if (sigma === 0)
            return mu;
        p_ = expm1_1.R_DT_qIv(lower_tail, log_p, fx);
        q = p_ - 0.5;
        printer('qnorm(p=%d, m=%d, s=%d, l.t.= %s, log= %s): q = %d', p, mu, sigma, lower_tail, log_p, q);
        if (fabs(q) <= 0.425) {
            r = 0.180625 - q * q;
            val =
                q *
                    (((((((r * 2509.0809287301226727 + 33430.575583588128105) * r +
                        67265.770927008700853) *
                        r +
                        45921.953931549871457) *
                        r +
                        13731.693765509461125) *
                        r +
                        1971.5909503065514427) *
                        r +
                        133.14166789178437745) *
                        r +
                        3.387132872796366608) /
                    (((((((r * 5226.495278852854561 + 28729.085735721942674) * r +
                        39307.89580009271061) *
                        r +
                        21213.794301586595867) *
                        r +
                        5394.1960214247511077) *
                        r +
                        687.1870074920579083) *
                        r +
                        42.313330701600911252) *
                        r +
                        1);
        }
        else {
            if (q > 0)
                r = expm1_1.R_DT_CIv(lower_tail, log_p, fx);
            else
                r = p_;
            r = sqrt(-(log_p && ((lower_tail && q <= 0) || (!lower_tail && q > 0))
                ? p
                : log(r)));
            printer('close to 0 or 1: r = %7d', r);
            if (r <= 5) {
                r += -1.6;
                val =
                    (((((((r * 7.7454501427834140764e-4 + 0.0227238449892691845833) * r +
                        0.24178072517745061177) *
                        r +
                        1.27045825245236838258) *
                        r +
                        3.64784832476320460504) *
                        r +
                        5.7694972214606914055) *
                        r +
                        4.6303378461565452959) *
                        r +
                        1.42343711074968357734) /
                        (((((((r * 1.05075007164441684324e-9 + 5.475938084995344946e-4) * r +
                            0.0151986665636164571966) *
                            r +
                            0.14810397642748007459) *
                            r +
                            0.68976733498510000455) *
                            r +
                            1.6763848301838038494) *
                            r +
                            2.05319162663775882187) *
                            r +
                            1);
            }
            else {
                r += -5;
                val =
                    (((((((r * 2.01033439929228813265e-7 + 2.71155556874348757815e-5) *
                        r +
                        0.0012426609473880784386) *
                        r +
                        0.026532189526576123093) *
                        r +
                        0.29656057182850489123) *
                        r +
                        1.7848265399172913358) *
                        r +
                        5.4637849111641143699) *
                        r +
                        6.6579046435011037772) /
                        (((((((r * 2.04426310338993978564e-15 + 1.4215117583164458887e-7) *
                            r +
                            1.8463183175100546818e-5) *
                            r +
                            7.868691311456132591e-4) *
                            r +
                            0.0148753612908506148525) *
                            r +
                            0.13692988092273580531) *
                            r +
                            0.59983220655588793769) *
                            r +
                            1);
            }
            if (q < 0.0)
                val = -val;
        }
        return mu + sigma * val;
    });
}
exports.qnorm = qnorm;

});

var inversion = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Inversion = void 0;



const BIG = 134217728;
const { isArray } = Array;
class Inversion extends inormalRng.IRNGNormal {
    constructor(_rng = new mersenneTwister.MersenneTwister(0)) {
        super(_rng);
    }
    internal_norm_rand() {
        let u1 = this.rng.unif_rand();
        let t = this.rng.unif_rand();
        u1 = new Int32Array([BIG * u1])[0] + t;
        const result = qnorm_1.qnorm(u1 / BIG, 0.0, 1.0, !!1, !!0);
        return isArray(result) ? result[0] : result;
    }
}
exports.Inversion = Inversion;

});

var kindermanRamage = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.KindermanRamage = void 0;


const { exp, log, sqrt, max: fmax2, min: fmin2, abs: fabs } = Math;
const A = 2.216035867166471;
const C1 = 0.398942280401433;
const C2 = 0.180025191068563;
class KindermanRamage extends inormalRng.IRNGNormal {
    constructor(_rng = new mersenneTwister.MersenneTwister(0)) {
        super(_rng);
    }
    internal_norm_rand() {
        let u1;
        let u2;
        let u3;
        let tt;
        const g = (x) => C1 * exp(-x * x / 2.0) - C2 * (A - x);
        u1 = this.rng.unif_rand();
        if (u1 < 0.884070402298758) {
            u2 = this.rng.unif_rand();
            return A * (1.13113163544418 * u1 + u2 - 1);
        }
        if (u1 >= 0.973310954173898) {
            for (;;) {
                u2 = this.rng.unif_rand();
                u3 = this.rng.unif_rand();
                tt = A * A - 2 * log(u3);
                if (u2 * u2 < A * A / tt)
                    return u1 < 0.986655477086949 ? sqrt(tt) : -sqrt(tt);
            }
        }
        if (u1 >= 0.958720824790463) {
            for (;;) {
                u2 = this.rng.unif_rand();
                u3 = this.rng.unif_rand();
                tt = A - 0.63083480192196 * fmin2(u2, u3);
                if (fmax2(u2, u3) <= 0.755591531667601)
                    return u2 < u3 ? tt : -tt;
                if (0.034240503750111 * fabs(u2 - u3) <= g(tt))
                    return u2 < u3 ? tt : -tt;
            }
        }
        if (u1 >= 0.911312780288703) {
            for (;;) {
                u2 = this.rng.unif_rand();
                u3 = this.rng.unif_rand();
                tt = 0.479727404222441 + 1.10547366102207 * fmin2(u2, u3);
                if (fmax2(u2, u3) <= 0.87283497667179)
                    return u2 < u3 ? tt : -tt;
                if (0.049264496373128 * fabs(u2 - u3) <= g(tt))
                    return u2 < u3 ? tt : -tt;
            }
        }
        for (;;) {
            u2 = this.rng.unif_rand();
            u3 = this.rng.unif_rand();
            tt = 0.479727404222441 - 0.59550713801594 * fmin2(u2, u3);
            if (tt < 0)
                continue;
            if (fmax2(u2, u3) <= 0.805577924423817)
                return u2 < u3 ? tt : -tt;
            if (0.053377549506886 * fabs(u2 - u3) <= g(tt))
                return u2 < u3 ? tt : -tt;
        }
    }
}
exports.KindermanRamage = KindermanRamage;

});

var normal$1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.IRNGNormal = exports.KindermanRamage = exports.Inversion = exports.AhrensDieter = exports.BoxMuller = exports.BuggyKindermanRamage = void 0;

Object.defineProperty(exports, "BuggyKindermanRamage", { enumerable: true, get: function () { return buggyKindermanRamage.BuggyKindermanRamage; } });

Object.defineProperty(exports, "BoxMuller", { enumerable: true, get: function () { return boxMuller.BoxMuller; } });

Object.defineProperty(exports, "AhrensDieter", { enumerable: true, get: function () { return ahrens_dieter.AhrensDieter; } });

Object.defineProperty(exports, "Inversion", { enumerable: true, get: function () { return inversion.Inversion; } });

Object.defineProperty(exports, "KindermanRamage", { enumerable: true, get: function () { return kindermanRamage.KindermanRamage; } });

Object.defineProperty(exports, "IRNGNormal", { enumerable: true, get: function () { return inormalRng.IRNGNormal; } });

});

var rbeta_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rbeta = exports.expmax = void 0;


const { LN2: M_LN2, log, min: fmin2, max: fmax2, exp, sqrt } = Math;
const { MAX_VALUE: DBL_MAX, isFinite: R_FINITE } = Number;
const printer = src('rbeta');
exports.expmax = _general.DBL_MAX_EXP * M_LN2;
function rbeta(n, aa, bb, rng) {
    const result = new Array(n).fill(0).map(() => {
        if (aa < 0 || bb < 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (!R_FINITE(aa) && !R_FINITE(bb))
            return 0.5;
        if (aa === 0 && bb === 0)
            return rng.unif_rand() < 0.5 ? 0 : 1;
        if (!R_FINITE(aa) || bb === 0)
            return 1.0;
        if (!R_FINITE(bb) || aa === 0)
            return 0.0;
        let a;
        let b;
        let alpha;
        let r;
        let s;
        let t;
        let u1 = 0;
        let u2;
        let v = 0;
        let w = 0;
        let y;
        let z;
        let qsame;
        let beta = 0;
        let gamma = 0;
        let delta;
        let k1 = 0;
        let k2 = 0;
        let olda = -1.0;
        let oldb = -1.0;
        qsame = olda === aa && oldb === bb;
        if (!qsame) {
            olda = aa;
            oldb = bb;
        }
        a = fmin2(aa, bb);
        b = fmax2(aa, bb);
        alpha = a + b;
        function v_w_from__u1_bet(AA) {
            v = beta * log(u1 / (1.0 - u1));
            if (v <= exports.expmax) {
                w = AA * exp(v);
                if (!R_FINITE(w)) {
                    w = DBL_MAX;
                }
            }
            else {
                w = DBL_MAX;
            }
        }
        if (a <= 1.0) {
            if (!qsame) {
                beta = 1.0 / a;
                delta = 1.0 + b - a;
                k1 = delta * (0.0138889 + 0.0416667 * a) / (b * beta - 0.777778);
                k2 = 0.25 + (0.5 + 0.25 / delta) * a;
            }
            for (;;) {
                u1 = rng.unif_rand();
                u2 = rng.unif_rand();
                if (u1 < 0.5) {
                    y = u1 * u2;
                    z = u1 * y;
                    if (0.25 * u2 + z - y >= k1)
                        continue;
                }
                else {
                    z = u1 * u1 * u2;
                    if (z <= 0.25) {
                        v_w_from__u1_bet(b);
                        break;
                    }
                    if (z >= k2)
                        continue;
                }
                v_w_from__u1_bet(b);
                if (alpha * (log(alpha / (a + w)) + v) - 1.3862944 >= log(z))
                    break;
            }
            return aa === a ? a / (a + w) : w / (a + w);
        }
        else {
            if (!qsame) {
                beta = sqrt((alpha - 2.0) / (2.0 * a * b - alpha));
                gamma = a + 1.0 / beta;
            }
            do {
                u1 = rng.unif_rand();
                u2 = rng.unif_rand();
                v_w_from__u1_bet(a);
                z = u1 * u1 * u2;
                r = gamma * v - 1.3862944;
                s = a + r - w;
                if (s + 2.609438 >= 5.0 * z)
                    break;
                t = log(z);
                if (s > t)
                    break;
            } while (r + alpha * log(alpha / (b + w)) < t);
            return aa !== a ? b / (b + w) : w / (b + w);
        }
    });
    return result.length === 1 ? result[0] : result;
}
exports.rbeta = rbeta;

});

var beta = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Beta = exports.special = void 0;













exports.special = {
    beta: beta_1.beta,
    lbeta: lbeta_1.lbeta
};
function Beta(rng = new normal$1.Inversion()) {
    function dbeta(x, shape1, shape2, ncp, log) {
        if (ncp === undefined || ncp === 0) {
            return dbeta_1.dbeta(x, shape1, shape2, log || false);
        }
        else {
            return dnbeta_1.dnbeta(x, shape1, shape2, ncp || 0, log || false);
        }
    }
    function pbeta(q, shape1, shape2, ncp, lowerTail = true, logP = false) {
        if (ncp === undefined || ncp === 0) {
            return pbeta_1.pbeta(q, shape1, shape2, lowerTail, logP);
        }
        else {
            return pnbeta_1.pnbeta(q, shape1, shape2, ncp, lowerTail, logP);
        }
    }
    function qbeta(p, shape1, shape2, ncp, lowerTail = true, logP = false) {
        if (ncp === undefined) {
            return qbeta_1.qbeta(p, shape1, shape2, lowerTail, logP);
        }
        else {
            return qnbeta_1.qnbeta(p, shape1, shape2, ncp, lowerTail, logP);
        }
    }
    function rbeta(n, shape1, shape2, ncp = 0) {
        if (ncp === 0) {
            return rbeta_1.rbeta(n, shape1, shape2, rng);
        }
        else {
            let ax = rnchisq_1.rnchisq(n, 2 * shape1, ncp, rng);
            let bx = rchisq_1.rchisq(n, 2 * shape2, rng);
            let result = rFunc.multiplexer(ax, bx)((a, b) => a / (a + b));
            return result.length === 1 ? result[0] : result;
        }
    }
    return Object.freeze({
        dbeta,
        pbeta,
        qbeta,
        rbeta
    });
}
exports.Beta = Beta;

});

var pbinom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pbinom = void 0;




const printer = src('pbinom');
const { floor, round: R_forceint } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
function pbinom(xx, n, p, lowerTail = true, logP = false) {
    return rFunc.map(xx)(x => {
        if (ISNAN(x) || ISNAN(n) || ISNAN(p))
            return NaN;
        if (!R_FINITE(n) || !R_FINITE(p)) {
            return _general.ML_ERR_return_NAN(printer);
        }
        let lower_tail = lowerTail;
        let log_p = logP;
        if (_general.R_nonint(n)) {
            printer('non-integer n = %d', n);
            return _general.ML_ERR_return_NAN(printer);
        }
        n = R_forceint(n);
        if (n < 0 || p < 0 || p > 1)
            return _general.ML_ERR_return_NAN(printer);
        if (x < 0)
            return _general.R_DT_0(lower_tail, log_p);
        x = floor(x + 1e-7);
        if (n <= x)
            return _general.R_DT_1(lower_tail, log_p);
        printer('calling pbeta:(q=%d,a=%d,b=%d, l.t=%s, log=%s', p, x + 1, n - x, !lower_tail, log_p);
        return pbeta_1.pbeta(p, x + 1, n - x, !lower_tail, log_p);
    });
}
exports.pbinom = pbinom;

});

var qbinom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qbinom = void 0;


const { max: fmax2, min: fmin2, floor, sqrt } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, EPSILON: DBL_EPSILON } = Number;





const printer_do_search = src('do_search');
function do_search(y, z, p, n, pr, incr) {
    if (z.val >= p) {
        printer_do_search('new z=%o >= p = %d  --> search to left (y--) ..', z, p);
        while (true) {
            let newz;
            if (y === 0 ||
                (newz = pbinom_1.pbinom(y - incr, n, pr, true, false)) < p)
                return y;
            y = fmax2(0, y - incr);
            z.val = newz;
        }
    }
    else {
        printer_do_search('new z=%d < p = %d  --> search to right (y++) ..', z.val, p);
        while (true) {
            y = fmin2(y + incr, n);
            if (y === n ||
                (z.val = pbinom_1.pbinom(y, n, pr, true, false)) >= p)
                return y;
        }
    }
}
function qbinom(pp, n, pr, lowerTail = true, logP = false) {
    return rFunc.map(pp)(p => _qbinom(p, n, pr, lowerTail, logP));
}
exports.qbinom = qbinom;
const printer_qbinom = src('_qbinom');
function _qbinom(p, size, pr, lower_tail, log_p) {
    let q;
    let mu;
    let sigma;
    let gamma;
    const z = new toms708.NumberW(0);
    let y;
    if (ISNAN(p) || ISNAN(size) || ISNAN(pr))
        return NaN;
    if (!R_FINITE(size) || !R_FINITE(pr)) {
        return _general.ML_ERR_return_NAN(printer_qbinom);
    }
    if (!R_FINITE(p) && !log_p) {
        return _general.ML_ERR_return_NAN(printer_qbinom);
    }
    if (!Number.isInteger(size)) {
        return _general.ML_ERR_return_NAN(printer_qbinom);
    }
    if (pr < 0 || pr > 1 || size < 0) {
        return _general.ML_ERR_return_NAN(printer_qbinom);
    }
    let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, 0, size);
    if (rc !== undefined) {
        return rc;
    }
    if (pr === 0 || size === 0)
        return 0;
    q = 1 - pr;
    if (q === 0)
        return size;
    mu = size * pr;
    sigma = sqrt(size * pr * q);
    gamma = (q - pr) / sigma;
    printer_qbinom('qbinom(p=%d, n=%d, pr=%d, l.t.=%s, log=%s): sigm=%d, gam=%d', p, size, pr, lower_tail, log_p, sigma, gamma);
    if (!lower_tail || log_p) {
        p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
        if (p === 0)
            return 0;
        if (p === 1)
            return size;
    }
    if (Math.abs(p - 1) < DBL_EPSILON) {
        return size;
    }
    z.val = qnorm_1.qnorm(p, 0, 1, true, false);
    y = floor(mu + sigma * (z.val + gamma * (z.val * z.val - 1) / 6) + 0.5);
    if (y > size) {
        y = size;
    }
    printer_qbinom('  new (p,1-p)=(%d,%d), z=qnorm(..)=%d, y=%d, size=%d', p, 1 - p, z.val, y, size);
    z.val = pbinom_1.pbinom(y, size, pr, true, false);
    p *= 1 - 64 * DBL_EPSILON;
    if (size < 1e5) {
        return do_search(y, z, p, size, pr, 1);
    }
    let incr = floor(size * 0.001);
    let oldincr;
    do {
        console.log('loopdieloop');
        oldincr = incr;
        y = do_search(y, z, p, size, pr, incr);
        incr = fmax2(1, floor(incr / 100));
    } while (oldincr > 1 && incr > size * 1e-15);
    return y;
}

});

var rbinom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rbinom = void 0;




const { log, abs: fabs, abs, sqrt, min: fmin2, trunc, round } = Math;
const { MAX_SAFE_INTEGER: INT_MAX, isFinite: R_FINITE } = Number;
const sequence = rFunc.seq()();
const printer_rbinom = src('_rbinom');
function rbinom(N, nin, pp, rng) {
    return rFunc.map(sequence(N))(() => _rbinom(nin, pp, rng));
}
exports.rbinom = rbinom;
function _rbinom(nin, pp, rng) {
    let c = 0;
    let fm = 0;
    let npq = 0;
    let p1 = 0;
    let p2 = 0;
    let p3 = 0;
    let p4 = 0;
    let qn = 0;
    let xl = 0;
    let xll = 0;
    let xlr = 0;
    let xm = 0;
    let xr = 0;
    let psave = -1.0;
    let nsave = -1;
    let m = 0;
    let f;
    let f1;
    let f2;
    let u;
    let v;
    let w;
    let w2;
    let x;
    let x1;
    let x2;
    let z;
    let z2;
    let p;
    let q;
    let np;
    let g;
    let r;
    let al;
    let alv;
    let amaxp;
    let ffm;
    let ynorm;
    let i;
    let ix = 0;
    let k;
    let n;
    if (!R_FINITE(nin))
        return _general.ML_ERR_return_NAN(printer_rbinom);
    r = round(nin);
    if (r !== nin)
        return _general.ML_ERR_return_NAN(printer_rbinom);
    if (!R_FINITE(pp) ||
        r < 0 ||
        pp < 0 ||
        pp > 1) {
        return _general.ML_ERR_return_NAN(printer_rbinom);
    }
    if (r === 0 || pp === 0)
        return 0;
    if (pp === 1)
        return r;
    if (r >= INT_MAX) {
        printer_rbinom('Evade overflow:%d > MAX_SAFE_INTEGER', r);
        return qbinom_1.qbinom(rng.unif_rand(), r, pp, false, false);
    }
    n = trunc(r);
    p = fmin2(pp, 1 - pp);
    q = 1 - p;
    np = n * p;
    r = p / q;
    g = r * (n + 1);
    let gotoL_np_small = false;
    if (pp !== psave || n !== nsave) {
        psave = pp;
        nsave = n;
        if (np < 30.0) {
            qn = _general.R_pow_di(q, n);
            gotoL_np_small = true;
        }
        else {
            ffm = np + p;
            m = trunc(ffm);
            fm = m;
            npq = np * q;
            p1 = trunc(2.195 * sqrt(npq) - 4.6 * q) + 0.5;
            xm = fm + 0.5;
            xl = xm - p1;
            xr = xm + p1;
            c = 0.134 + 20.5 / (15.3 + fm);
            al = (ffm - xl) / (ffm - xl * p);
            xll = al * (1.0 + 0.5 * al);
            al = (xr - ffm) / (xr * q);
            xlr = al * (1.0 + 0.5 * al);
            p2 = p1 * (1.0 + c + c);
            p3 = p2 + c / xll;
            p4 = p3 + c / xlr;
        }
    }
    else if (n === nsave) {
        if (np < 30.0)
            gotoL_np_small = true;
    }
    let gotoFinis = false;
    while (!gotoL_np_small) {
        u = rng.unif_rand() * p4;
        v = rng.unif_rand();
        if (u <= p1) {
            ix = trunc(xm - p1 * v + u);
            gotoFinis = true;
            break;
        }
        if (u <= p2) {
            x = xl + (u - p1) / c;
            v = v * c + 1.0 - fabs(xm - x) / p1;
            if (v > 1.0 || v <= 0)
                continue;
            ix = trunc(x);
        }
        else {
            if (u > p3) {
                ix = trunc(xr - log(v) / xlr);
                if (ix > n)
                    continue;
                v = v * (u - p3) * xlr;
            }
            else {
                ix = trunc(xl + log(v) / xll);
                if (ix < 0)
                    continue;
                v = v * (u - p2) * xll;
            }
        }
        k = abs(ix - m);
        if (k <= 20 || k >= npq / 2 - 1) {
            f = 1.0;
            if (m < ix) {
                for (i = m + 1; i <= ix; i++)
                    f *= g / i - r;
            }
            else if (m !== ix) {
                for (i = ix + 1; i <= m; i++)
                    f /= g / i - r;
            }
            if (v <= f) {
                gotoFinis = true;
                break;
            }
        }
        else {
            amaxp = k / npq * ((k * (k / 3 + 0.625) + 0.1666666666666) / npq + 0.5);
            ynorm = -k * k / (2.0 * npq);
            alv = log(v);
            if (alv < ynorm - amaxp) {
                gotoFinis = true;
                break;
            }
            if (alv <= ynorm + amaxp) {
                x1 = ix + 1;
                f1 = fm + 1.0;
                z = n + 1 - fm;
                w = n - ix + 1.0;
                z2 = z * z;
                x2 = x1 * x1;
                f2 = f1 * f1;
                w2 = w * w;
                if (alv <=
                    xm * log(f1 / x1) +
                        (n - m + 0.5) * log(z / w) +
                        (ix - m) * log(w * p / (x1 * q)) +
                        (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / f2) / f2) / f2) / f2) /
                            f1 /
                            166320.0 +
                        (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / z2) / z2) / z2) / z2) /
                            z /
                            166320.0 +
                        (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / x2) / x2) / x2) / x2) /
                            x1 /
                            166320.0 +
                        (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / w2) / w2) / w2) / w2) /
                            w /
                            166320) {
                    gotoFinis = true;
                    break;
                }
            }
        }
    }
    if (!gotoFinis) {
        while (true) {
            ix = 0;
            f = qn;
            u = rng.unif_rand();
            while (true) {
                if (u < f) {
                    gotoFinis = true;
                    break;
                }
                if (ix > 110)
                    break;
                u -= f;
                ix++;
                f *= g / ix - r;
            }
            if (gotoFinis) {
                break;
            }
        }
    }
    if (psave > 0.5) {
        ix = n - ix;
    }
    return ix;
}

});

var binomial = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Binomial = void 0;





function Binomial(rng = new mersenneTwister.MersenneTwister()) {
    return {
        dbinom: dbinom_1.dbinom,
        pbinom: pbinom_1.pbinom,
        qbinom: qbinom_1.qbinom,
        rbinom: (N, nin, pp) => rbinom_1.rbinom(N, nin, pp, rng)
    };
}
exports.Binomial = Binomial;

});

var dnbinom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dnbinom_mu = exports.dnbinom = void 0;




const printer = src('dnbinom');
const { log, round: R_forceint, log1p } = Math;
const { isFinite: R_FINITE, isNaN: ISNAN } = Number;
function dnbinom(xx, size, prob, give_log) {
    const fx = Array.isArray(xx) ? xx : [xx];
    const result = fx.map(x => {
        let ans;
        let p;
        if (ISNAN(x) || ISNAN(size) || ISNAN(prob)) {
            return x + size + prob;
        }
        if (prob <= 0 || prob > 1 || size < 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        let rc = _general.R_D_nonint_check(give_log, x, printer);
        if (rc !== undefined) {
            return rc;
        }
        if (x < 0 || !R_FINITE(x)) {
            return _general.R_D__0(give_log);
        }
        if (x === 0 && size === 0) {
            return _general.R_D__1(give_log);
        }
        x = R_forceint(x);
        ans = dbinom_1.dbinom_raw(size, x + size, prob, 1 - prob, give_log);
        p = size / (size + x);
        return give_log ? log(p) + ans : p * ans;
    });
    return result.length === 1 ? result[0] : result;
}
exports.dnbinom = dnbinom;
const printer_dnbinom_mu = src('dnbinom_mu');
function dnbinom_mu(xx, size, mu, give_log) {
    const fx = Array.isArray(xx) ? xx : [xx];
    const result = fx.map(x => {
        let ans;
        let p;
        if (ISNAN(x) || ISNAN(size) || ISNAN(mu)) {
            return x + size + mu;
        }
        if (mu < 0 || size < 0) {
            return _general.ML_ERR_return_NAN(printer_dnbinom_mu);
        }
        let rc = _general.R_D_nonint_check(give_log, x, printer_dnbinom_mu);
        if (rc !== undefined) {
            return rc;
        }
        if (x < 0 || !R_FINITE(x)) {
            return _general.R_D__0(give_log);
        }
        if (x === 0 && size === 0) {
            return _general.R_D__1(give_log);
        }
        x = R_forceint(x);
        if (x === 0) {
            let llogx;
            if (size < mu) {
                llogx = log(size / (size + mu));
            }
            else {
                llogx = log1p(-mu / (size + mu));
            }
            return _general.R_D_exp(give_log, size * llogx);
        }
        if (x < 1e-10 * size) {
            p = size < mu ? log(size / (1 + size / mu)) : log(mu / (1 + mu / size));
            return _general.R_D_exp(give_log, x * p - mu - lgamma_fn.lgammafn(x + 1) + log1p(x * (x - 1) / (2 * size)));
        }
        ans = dbinom_1.dbinom_raw(size, x + size, size / (size + mu), mu / (size + mu), give_log);
        p = size / (size + x);
        return give_log ? log(p) + ans : p * ans;
    });
    return result.length === 0 ? result[0] : result;
}
exports.dnbinom_mu = dnbinom_mu;

});

var pnbinom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pnbinom_mu = exports.pnbinom = void 0;


const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const { floor, log } = Math;


const printer = src('pnbinom');
function pnbinom(xx, size, prob, lowerTail, logP) {
    const fx = Array.isArray(xx) ? xx : [xx];
    const result = fx.map(x => {
        if (ISNAN(x) || ISNAN(size) || ISNAN(prob))
            return x + size + prob;
        if (!R_FINITE(size) || !R_FINITE(prob)) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (size < 0 || prob <= 0 || prob > 1) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (size === 0)
            return x >= 0 ? _general.R_DT_1(lowerTail, logP) : _general.R_DT_0(lowerTail, logP);
        if (x < 0)
            return _general.R_DT_0(lowerTail, logP);
        if (!R_FINITE(x))
            return _general.R_DT_1(lowerTail, logP);
        x = floor(x + 1e-7);
        return pbeta_1.pbeta(prob, size, x + 1, lowerTail, logP);
    });
    return result.length === 1 ? result[0] : result;
}
exports.pnbinom = pnbinom;
const printer_pnbinom_mu = src('printer_pnbinom_mu');
function pnbinom_mu(xx, size, mu, lowerTail, logP) {
    const fx = Array.isArray(xx) ? xx : [xx];
    const result = fx.map(x => {
        if (ISNAN(x) || ISNAN(size) || ISNAN(mu))
            return x + size + mu;
        if (!R_FINITE(size) || !R_FINITE(mu))
            return _general.ML_ERR_return_NAN(printer_pnbinom_mu);
        if (size < 0 || mu < 0)
            return _general.ML_ERR_return_NAN(printer_pnbinom_mu);
        if (size === 0)
            return x >= 0 ? _general.R_DT_1(lowerTail, logP) : _general.R_DT_0(lowerTail, logP);
        if (x < 0)
            return _general.R_DT_0(lowerTail, logP);
        if (!R_FINITE(x))
            return _general.R_DT_1(lowerTail, logP);
        x = floor(x + 1e-7);
        {
            let ierr = new toms708.NumberW(0);
            let w = new toms708.NumberW(0);
            let wc = new toms708.NumberW(0);
            toms708.Toms708.bratio(size, x + 1, size / (size + mu), mu / (size + mu), w, wc, ierr);
            if (ierr)
                printer('pnbinom_mu() -> bratio() gave error code %d', ierr.val);
            if (logP) {
                w.val = log(w.val);
                wc.val = log(wc.val);
            }
            return lowerTail ? w.val : wc.val;
        }
    });
    return result.length === 1 ? result[0] : result;
}
exports.pnbinom_mu = pnbinom_mu;

});

var qnbinom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qnbinom_mu = exports.qnbinom = void 0;







const { isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF, EPSILON: DBL_EPSILON } = Number;
const { max: fmax2, sqrt, floor, round: R_forceint } = Math;
const printer_do_search = src('do_search');
function do_search(y, z, p, n, pr, incr) {
    printer_do_search('start: y:%d, z:%o, p:%d, n:%d, pr:%d, incr:%d', y, z, p, n, pr, incr);
    if (z.val >= p) {
        while (true) {
            if (y === 0 ||
                (z.val = pnbinom_1.pnbinom(y - incr, n, pr, true, false)) < p) {
                printer_do_search('exit1');
                return y;
            }
            y = fmax2(0, y - incr);
        }
    }
    else {
        while (true) {
            y = y + incr;
            if ((z.val = pnbinom_1.pnbinom(y, n, pr, true, false)) >= p) {
                printer_do_search('exit2');
                return y;
            }
        }
    }
}
const printer_qnbinom = src('qnbinom');
function qnbinom(pp, size, prob, lower_tail, log_p) {
    return rFunc.map(pp)(p => {
        let P;
        let Q;
        let mu;
        let sigma;
        let gamma;
        let y;
        const z = new toms708.NumberW(0);
        if (ISNAN(p) || ISNAN(size) || ISNAN(prob)) {
            return NaN;
        }
        if (prob === 0 && size === 0)
            return 0;
        if (prob <= 0 || prob > 1 || size < 0) {
            return _general.ML_ERR_return_NAN(printer_qnbinom);
        }
        if (prob === 1 || size === 0)
            return 0;
        let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, 0, ML_POSINF);
        if (rc !== undefined) {
            return rc;
        }
        Q = 1.0 / prob;
        P = (1.0 - prob) * Q;
        mu = size * P;
        sigma = sqrt(size * P * Q);
        gamma = (Q + P) / sigma;
        if (!lower_tail || log_p) {
            p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
            if (p === _general.R_DT_0(lower_tail, log_p))
                return 0;
            if (p === _general.R_DT_1(lower_tail, log_p))
                return ML_POSINF;
        }
        if (p + 1.01 * DBL_EPSILON >= 1)
            return ML_POSINF;
        z.val = qnorm_1.qnorm(p, 0, 1, true, false);
        y = R_forceint(mu + sigma * (z.val + gamma * (z.val * z.val - 1) / 6));
        z.val = pnbinom_1.pnbinom(y, size, prob, true, false);
        p *= 1 - 64 * DBL_EPSILON;
        if (y < 1e5)
            return do_search(y, z, p, size, prob, 1);
        {
            let incr = floor(y * 0.001);
            let oldincr;
            do {
                oldincr = incr;
                y = do_search(y, z, p, size, prob, incr);
                incr = fmax2(1, floor(incr / 100));
            } while (oldincr > 1 && incr > y * 1e-15);
            return y;
        }
    });
}
exports.qnbinom = qnbinom;
function qnbinom_mu(pp, size, mu, lower_tail, log_p) {
    return qnbinom(pp, size, size / (size + mu), lower_tail, log_p);
}
exports.qnbinom_mu = qnbinom_mu;

});

var rnbinom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rnbinom_mu = exports.rnbinom = void 0;




const { isFinite: R_FINITE } = Number;
const printer_rnbinom = src('rnbinom');
function rnbinom(n, size, prob, rng) {
    printer_rnbinom('n:%d, size:%d, prob:%d', n, size, prob);
    const result = new Array(n).fill(0).map(() => {
        if (!R_FINITE(size) ||
            !R_FINITE(prob) ||
            size <= 0 ||
            prob <= 0 ||
            prob > 1) {
            return _general.ML_ERR_return_NAN(printer_rnbinom);
        }
        return prob === 1
            ? 0
            : rpois_1.rpois(1, rgamma_1.rgamma(1, size, (1 - prob) / prob, rng), rng);
    });
    return result.length === 1 ? result[0] : result;
}
exports.rnbinom = rnbinom;
const printer_rnbinom_mu = src('rnbinom_mu');
function rnbinom_mu(n = 1, size, mu, rng) {
    const result = new Array(n).fill(0).map(() => {
        if (!R_FINITE(size) || !R_FINITE(mu) || size <= 0 || mu < 0) {
            return _general.ML_ERR_return_NAN(printer_rnbinom_mu);
        }
        return mu === 0
            ? 0
            : rpois_1.rpois(1, rgamma_1.rgamma(1, size, mu / size, rng), rng);
    });
    return result.length === 1 ? result[0] : result;
}
exports.rnbinom_mu = rnbinom_mu;

});

var binomialNegative = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.NegativeBinomial = void 0;





const errText = Object.freeze([
    'at most specify either argument "mu" or  "prob", but not both at the same time!',
    'both arguments "mu" and "prob" are undefined'
]);
function select(fs, mu, prob) {
    const selector = {
        mu: {
            d: dnbinom_1.dnbinom_mu,
            p: pnbinom_1.pnbinom_mu,
            q: qnbinom_1.qnbinom_mu,
            r: rnbinom_1.rnbinom_mu
        },
        p: {
            d: dnbinom_1.dnbinom,
            p: pnbinom_1.pnbinom,
            q: qnbinom_1.qnbinom,
            r: rnbinom_1.rnbinom
        }
    };
    if (prob !== undefined && mu !== undefined) {
        throw new Error(errText[0]);
    }
    if (prob === undefined && mu === undefined) {
        throw new Error(errText[1]);
    }
    const s = prob === undefined ? 'mu' : 'p';
    return selector[s][fs];
}
function NegativeBinomial(rng = new normal$1.Inversion()) {
    function dnbinom(x, size, prob, mu, giveLog = false) {
        const val = mu || prob;
        return select('d', mu, prob)(x, size, val, giveLog);
    }
    function pnbinom(q, size, prob, mu, lowerTail = true, logP = false) {
        const val = mu || prob;
        return select('p', mu, prob)(q, size, val, lowerTail, logP);
    }
    function qnbinom(q, size, prob, mu, lowerTail = true, logP = false) {
        const val = mu || prob;
        return select('q', mu, prob)(q, size, val, lowerTail, logP);
    }
    function rnbinom(n, size, prob, mu) {
        const val = mu || prob;
        return select('r', mu, prob)(n, size, val, rng);
    }
    return {
        dnbinom,
        pnbinom,
        qnbinom,
        rnbinom
    };
}
exports.NegativeBinomial = NegativeBinomial;

});

var dcauchy_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dcauchy = void 0;



const { isNaN: ISNAN } = Number;
const { PI: M_PI, log } = Math;
const printer = src('dcauchy');
function dcauchy(xx, location = 0, scale = 1, giveLog = false) {
    return rFunc.map(xx)(x => {
        let y;
        if (ISNAN(x) || ISNAN(location) || ISNAN(scale)) {
            return x + location + scale;
        }
        if (scale <= 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        y = (x - location) / scale;
        return giveLog
            ? -log(M_PI * scale * (1 + y * y))
            : 1 / (M_PI * scale * (1 + y * y));
    });
}
exports.dcauchy = dcauchy;

});

var pcauchy_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pcauchy = void 0;


const _general_2 = _general;


const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const { abs: fabs } = Math;
const printer = src('pcauchy');
function pcauchy(xx, location = 0, scale = 1, lowerTail = true, logP = false) {
    return rFunc.map(xx)(x => {
        if (ISNAN(x) || ISNAN(location) || ISNAN(scale))
            return x + location + scale;
        if (scale <= 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        x = (x - location) / scale;
        if (ISNAN(x)) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (!R_FINITE(x)) {
            if (x < 0)
                return _general.R_DT_0(lowerTail, logP);
            else
                return _general.R_DT_1(lowerTail, logP);
        }
        if (!lowerTail)
            x = -x;
        if (fabs(x) > 1) {
            let y = trigonometry.atanpi(1 / x);
            return x > 0 ? _general_2.R_D_Clog(logP, y) : _general.R_D_val(logP, -y);
        }
        else {
            return _general.R_D_val(logP, 0.5 + trigonometry.atanpi(x));
        }
    });
}
exports.pcauchy = pcauchy;

});

var qcauchy_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qcauchy = void 0;




const { expm1, exp } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const { ML_POSINF, ML_NEGINF } = {
    ML_POSINF: Infinity,
    ML_NEGINF: -Infinity
};
const printer = src('qcauchy');
function qcauchy(pp, location = 0, scale = 1, lowerTail = true, logP = false) {
    return rFunc.map(pp)(p => {
        if (ISNAN(p) || ISNAN(location) || ISNAN(scale))
            return NaN;
        let lower_tail = lowerTail;
        let rc = _general.R_Q_P01_check(logP, p);
        if (rc !== undefined) {
            return rc;
        }
        if (scale <= 0 || !R_FINITE(scale)) {
            if (scale === 0)
                return location;
            return _general.ML_ERR_return_NAN(printer);
        }
        const my_INF = location + (lower_tail ? scale : -scale) * ML_POSINF;
        if (logP) {
            if (p > -1) {
                if (p === 0)
                    return my_INF;
                lower_tail = !lower_tail;
                p = -expm1(p);
            }
            else
                p = exp(p);
        }
        else {
            if (p > 0.5) {
                if (p === 1)
                    return my_INF;
                p = 1 - p;
                lower_tail = !lower_tail;
            }
        }
        if (p === 0.5)
            return location;
        if (p === 0)
            return location + (lower_tail ? scale : -scale) * ML_NEGINF;
        return location + (lower_tail ? -scale : scale) / tanpi_1.tanpi(p);
    });
}
exports.qcauchy = qcauchy;

});

var rcauchy_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rcauchy = void 0;


const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const { PI: M_PI } = Math;
const printer = src('rcauchy');
function rcauchy(n, location = 0, scale = 1, rng) {
    const result = new Array(n).fill(0).map(() => {
        if (ISNAN(location) || !R_FINITE(scale) || scale < 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (scale === 0 || !R_FINITE(location))
            return location;
        else
            return location + scale * Math.tan(M_PI * rng.unif_rand());
    });
    return result.length === 1 ? result[0] : result;
}
exports.rcauchy = rcauchy;

});

var cauchy = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cauchy = void 0;





function Cauchy(rng = new mersenneTwister.MersenneTwister(0)) {
    return {
        rcauchy: (n, location = 0, scale = 1) => rcauchy_1.rcauchy(n, location, scale, rng),
        dcauchy: dcauchy_1.dcauchy,
        pcauchy: pcauchy_1.pcauchy,
        qcauchy: qcauchy_1.qcauchy
    };
}
exports.Cauchy = Cauchy;

});

var chebyshev = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChebyshevSeries = void 0;

exports.ChebyshevSeries = {
    chebyshev_eval: chebyshev$1.chebyshev_eval,
    chebyshev_init: chebyshev$1.chebyshev_init
};

});

var dgamma_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dgamma = void 0;




const { log } = Math;
const { isNaN: ISNAN } = Number;
const ML_POSINF = Infinity;
const printer = src('dgamma');
function dgamma(xx, shape, scale, aslog = false) {
    return rFunc.map(xx)(x => {
        let pr;
        if (ISNAN(x) || ISNAN(shape) || ISNAN(scale))
            return x + shape + scale;
        if (shape < 0 || scale <= 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (x < 0) {
            return _general.R_D__0(aslog);
        }
        if (shape === 0) {
            return x === 0 ? ML_POSINF : _general.R_D__0(aslog);
        }
        if (x === 0) {
            if (shape < 1)
                return ML_POSINF;
            if (shape > 1) {
                return _general.R_D__0(aslog);
            }
            return aslog ? -log(scale) : 1 / scale;
        }
        if (shape < 1) {
            pr = dpois_1.dpois_raw(shape, x / scale, aslog);
            return aslog ? pr + log(shape / x) : pr * shape / x;
        }
        pr = dpois_1.dpois_raw(shape - 1, x / scale, aslog);
        return aslog ? pr - log(scale) : pr / scale;
    });
}
exports.dgamma = dgamma;

});

var dchisq_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dchisq = void 0;

function dchisq(x, df, log = false) {
    return dgamma_1.dgamma(x, df / 2, 2, log);
}
exports.dchisq = dchisq;

});

var dnchisq_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dnchisq = void 0;




const { ceil, sqrt } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer_dnchisq = src('dnchisq');
function dnchisq(xx, df, ncp, give_log) {
    const eps = 5e-15;
    const fa = Array.isArray(xx) ? xx : [xx];
    const result = fa.map(x => {
        let i;
        let ncp2;
        let q;
        let mid;
        let dfmid;
        let imax;
        let sum;
        let term;
        if (ISNAN(x) || ISNAN(df) || ISNAN(ncp)) {
            return x + df + ncp;
        }
        if (!R_FINITE(df) || !R_FINITE(ncp) || ncp < 0 || df < 0) {
            return _general.ML_ERR_return_NAN(printer_dnchisq);
        }
        if (x < 0) {
            return _general.R_D__0(give_log);
        }
        if (x === 0 && df < 2)
            return ML_POSINF;
        if (ncp === 0)
            return df > 0 ? dchisq_1.dchisq(x, df, give_log) : _general.R_D__0(give_log);
        if (x === ML_POSINF)
            return _general.R_D__0(give_log);
        ncp2 = 0.5 * ncp;
        imax = ceil((-(2 + df) + sqrt((2 - df) * (2 - df) + 4 * ncp * x)) / 4);
        if (imax < 0)
            imax = 0;
        if (R_FINITE(imax)) {
            dfmid = df + 2 * imax;
            mid = dpois_1.dpois_raw(imax, ncp2, false) * dchisq_1.dchisq(x, dfmid, false);
        }
        else {
            if (give_log || ncp > 1000) {
                let nl = df + ncp;
                let ic = nl / (nl + ncp);
                return dchisq_1.dchisq(x * ic, nl * ic, give_log);
            }
            else
                return _general.R_D__0(give_log);
        }
        sum = mid;
        term = mid;
        df = dfmid;
        i = imax;
        let x2 = x * ncp2;
        do {
            i++;
            q = x2 / i / df;
            df += 2;
            term *= q;
            sum += term;
        } while (q >= 1 || term * q > (1 - q) * eps || term > 1e-10 * sum);
        term = mid;
        df = dfmid;
        i = imax;
        while (i !== 0) {
            df -= 2;
            q = i * df / x2;
            i--;
            term *= q;
            sum += term;
            if (q < 1 && term * q <= (1 - q) * eps)
                break;
        }
        return _general.R_D_val(give_log, sum);
    });
    return result.length === 1 ? result[0] : result;
}
exports.dnchisq = dnchisq;

});

var dnorm = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dnorm4 = void 0;


const { isNaN: ISNAN, isFinite: R_FINITE, MAX_VALUE: DBL_MAX, POSITIVE_INFINITY: ML_POSINF, NaN: ML_NAN } = Number;
const { sqrt, exp, abs: fabs, round: R_forceint, log } = Math;
const printer = src('dnorm4');
const { isArray } = Array;
function dnorm4(x, mu = 0, sigma = 1, give_log = false) {
    let fa = (() => (isArray(x) && x) || [x])();
    let result = fa.map(fx => {
        if (ISNAN(fx) || ISNAN(mu) || ISNAN(sigma)) {
            return fx + mu + sigma;
        }
        if (!R_FINITE(sigma)) {
            return _general.R_D__0(give_log);
        }
        if (!R_FINITE(fx) && mu === fx) {
            return ML_NAN;
        }
        if (sigma <= 0) {
            if (sigma < 0) {
                return _general.ML_ERR_return_NAN(printer);
            }
            return fx === mu ? ML_POSINF : _general.R_D__0(give_log);
        }
        fx = (fx - mu) / sigma;
        if (!R_FINITE(fx))
            return _general.R_D__0(give_log);
        fx = fabs(fx);
        if (fx >= 2 * sqrt(DBL_MAX))
            return _general.R_D__0(give_log);
        if (give_log) {
            return -(_general.M_LN_SQRT_2PI + 0.5 * fx * fx + log(sigma));
        }
        if (fx < 5)
            return _general.M_1_SQRT_2PI * exp(-0.5 * fx * fx) / sigma;
        if (fx > sqrt(-2 * _general.M_LN2 * (_general.DBL_MIN_EXP + 1 - _general.DBL_MANT_DIG))) {
            return 0;
        }
        let x1 = _general.ldexp(R_forceint(_general.ldexp(fx, 16)), -16);
        let x2 = fx - x1;
        return (_general.M_1_SQRT_2PI / sigma * (exp(-0.5 * x1 * x1) * exp((-0.5 * x2 - x1) * x2)));
    });
    return (result.length === 1 ? result[0] : result);
}
exports.dnorm4 = dnorm4;

});

var pnorm = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pnorm_both = exports.pnorm5 = void 0;



const { isNaN: ISNAN, isFinite: R_FINITE, EPSILON: DBL_EPSILON, NaN: ML_NAN, MIN_VALUE: DBL_MIN } = Number;
const { trunc, log, exp, abs: fabs, log1p } = Math;

const SIXTEN = 16;
const printer = src('pnorm5');
function do_del(ccum, cum, log_p, X, temp, upper, lower, x) {
    let xsq = trunc(X * SIXTEN) / SIXTEN;
    let del = (X - xsq) * (X + xsq);
    if (log_p) {
        cum.val = -xsq * xsq * 0.5 + -del * 0.5 + log(temp);
        if ((lower && x > 0) || (upper && x <= 0))
            ccum.val = log1p(-exp(-xsq * xsq * 0.5) * exp(-del * 0.5) * temp);
    }
    else {
        cum.val = exp(-xsq * xsq * 0.5) * exp(-del * 0.5) * temp;
        ccum.val = 1.0 - cum.val;
    }
}
function pnorm5(q, mu = 0, sigma = 1, lowerTail = true, logP = false) {
    return rFunc.map(q)(fx => {
        let p = new toms708.NumberW(0);
        let cp = new toms708.NumberW(0);
        if (ISNAN(fx) || ISNAN(mu) || ISNAN(sigma))
            return fx + mu + sigma;
        if (!R_FINITE(fx) && mu === fx)
            return ML_NAN;
        if (sigma <= 0) {
            if (sigma < 0)
                return _general.ML_ERR_return_NAN(printer);
            return fx < mu ? _general.R_DT_0(lowerTail, logP) : _general.R_DT_1(lowerTail, logP);
        }
        p.val = (fx - mu) / sigma;
        if (!R_FINITE(p.val))
            return fx < mu ? _general.R_DT_0(lowerTail, logP) : _general.R_DT_1(lowerTail, logP);
        fx = p.val;
        pnorm_both(fx, p, cp, !lowerTail, logP);
        return lowerTail ? p.val : cp.val;
    });
}
exports.pnorm5 = pnorm5;
function pnorm_both(x, cum, ccum, i_tail, log_p) {
    const a = [
        2.2352520354606839287,
        161.02823106855587881,
        1067.6894854603709582,
        18154.981253343561249,
        0.065682337918207449113
    ];
    const b = [
        47.20258190468824187,
        976.09855173777669322,
        10260.932208618978205,
        45507.789335026729956
    ];
    const c = [
        0.39894151208813466764,
        8.8831497943883759412,
        93.506656132177855979,
        597.27027639480026226,
        2494.5375852903726711,
        6848.1904505362823326,
        11602.651437647350124,
        9842.7148383839780218,
        1.0765576773720192317e-8
    ];
    const d = [
        22.266688044328115691,
        235.38790178262499861,
        1519.377599407554805,
        6485.558298266760755,
        18615.571640885098091,
        34900.952721145977266,
        38912.003286093271411,
        19685.429676859990727
    ];
    const p = [
        0.21589853405795699,
        0.1274011611602473639,
        0.022235277870649807,
        0.001421619193227893466,
        2.9112874951168792e-5,
        0.02307344176494017303
    ];
    const q = [
        1.28426009614491121,
        0.468238212480865118,
        0.0659881378689285515,
        0.00378239633202758244,
        7.29751555083966205e-5
    ];
    let xden;
    let xnum;
    let temp;
    let eps;
    let xsq;
    let y;
    let min = DBL_MIN;
    let i = new Int32Array([0]);
    let lower;
    let upper;
    if (ISNAN(x)) {
        cum.val = ccum.val = x;
        return;
    }
    eps = DBL_EPSILON * 0.5;
    lower = i_tail !== true;
    upper = i_tail !== false;
    y = fabs(x);
    if (y <= 0.67448975) {
        if (y > eps) {
            xsq = x * x;
            xnum = a[4] * xsq;
            xden = xsq;
            for (i[0] = 0; i[0] < 3; ++i[0]) {
                xnum = (xnum + a[i[0]]) * xsq;
                xden = (xden + b[i[0]]) * xsq;
            }
        }
        else
            xnum = xden = 0.0;
        temp = x * (xnum + a[3]) / (xden + b[3]);
        if (lower)
            cum.val = 0.5 + temp;
        if (upper)
            ccum.val = 0.5 - temp;
        if (log_p) {
            if (lower)
                cum.val = log(cum.val);
            if (upper)
                ccum.val = log(ccum.val);
        }
    }
    else if (y <= _general.M_SQRT_32) {
        xnum = c[8] * y;
        xden = y;
        for (i[0] = 0; i[0] < 7; ++i[0]) {
            xnum = (xnum + c[i[0]]) * y;
            xden = (xden + d[i[0]]) * y;
        }
        temp = (xnum + c[7]) / (xden + d[7]);
        do_del(ccum, cum, log_p, y, temp, upper, lower, x);
        if (x > 0) {
            temp = cum.val;
            if (lower) {
                cum.val = ccum.val;
            }
            ccum.val = temp;
        }
    }
    else if ((log_p && y < 1e170) ||
        (lower && -37.5193 < x && x < 8.2924) ||
        (upper && -8.2924 < x && x < 37.5193)) {
        xsq = 1.0 / (x * x);
        xnum = p[5] * xsq;
        xden = xsq;
        for (i[0] = 0; i[0] < 4; ++i[0]) {
            xnum = (xnum + p[i[0]]) * xsq;
            xden = (xden + q[i[0]]) * xsq;
        }
        temp = xsq * (xnum + p[4]) / (xden + q[4]);
        temp = (_general.M_1_SQRT_2PI - temp) / y;
        do_del(ccum, cum, log_p, x, temp, upper, lower, x);
        if (x > 0) {
            temp = cum.val;
            if (lower) {
                cum.val = ccum.val;
            }
            ccum.val = temp;
        }
    }
    else {
        if (x > 0) {
            cum.val = _general.R_D__1(log_p);
            ccum.val = _general.R_D__0(log_p);
        }
        else {
            cum.val = _general.R_D__0(log_p);
            ccum.val = _general.R_D__1(log_p);
        }
    }
    if (log_p) {
        if (cum.val > -min)
            cum.val = -0;
        if (ccum.val > -min) {
            ccum.val = -0;
        }
    }
    else {
        if (cum.val < min)
            cum.val = 0;
        if (ccum.val < min)
            ccum.val = 0;
    }
    return;
}
exports.pnorm_both = pnorm_both;

});

var pgamma_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pgamma = exports.pgamma_raw = exports.lgamma1p = void 0;







const { LN2: M_LN2, log1p, expm1, sqrt, floor, pow, log, exp, max: fmax2, abs: fabs } = Math;
const { isNaN: ISNAN, MIN_VALUE: DBL_MIN, EPSILON: DBL_EPSILON, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF } = Number;
const { isArray } = Array;
const sqr = (x) => x * x;
const scalefactor = sqr(sqr(sqr(4294967296.0)));
const M_cutoff = M_LN2 * _general.DBL_MAX_EXP / DBL_EPSILON;
function logcf(x, i, d, eps) {
    let c1 = 2 * d;
    let c2 = i + d;
    let c4 = c2 + d;
    let a1 = c2;
    let b1 = i * (c2 - i * x);
    let b2 = d * d * x;
    let a2 = c4 * c2 - b2;
    b2 = c4 * b1 - i * b2;
    while (fabs(a2 * b1 - a1 * b2) > fabs(eps * b1 * b2)) {
        let c3 = c2 * c2 * x;
        c2 += d;
        c4 += d;
        a1 = c4 * a2 - c3 * a1;
        b1 = c4 * b2 - c3 * b1;
        c3 = c1 * c1 * x;
        c1 += d;
        c4 += d;
        a2 = c4 * a1 - c3 * a2;
        b2 = c4 * b1 - c3 * b2;
        if (fabs(b2) > scalefactor) {
            a1 /= scalefactor;
            b1 /= scalefactor;
            a2 /= scalefactor;
            b2 /= scalefactor;
        }
        else if (fabs(b2) < 1 / scalefactor) {
            a1 *= scalefactor;
            b1 *= scalefactor;
            a2 *= scalefactor;
            b2 *= scalefactor;
        }
    }
    return a2 / b2;
}
function log1pmx(x) {
    const minLog1Value = -0.79149064;
    if (x > 1 || x < minLog1Value)
        return log1p(x) - x;
    else {
        let r = x / (2 + x);
        let y = r * r;
        if (fabs(x) < 1e-2) {
            let two = 2;
            return (r * ((((two / 9 * y + two / 7) * y + two / 5) * y + two / 3) * y - x));
        }
        else {
            let tol_logcf = 1e-14;
            return r * (2 * y * logcf(y, 3, 2, tol_logcf) - x);
        }
    }
}
function lgamma1p(a) {
    const eulers_const = 0.5772156649015328606065120900824024;
    const N = 40;
    const coeffs = [
        0.3224670334241132182362075833230126,
        0.6735230105319809513324605383715e-1,
        0.2058080842778454787900092413529198e-1,
        0.7385551028673985266273097291406834e-2,
        0.2890510330741523285752988298486755e-2,
        0.1192753911703260977113935692828109e-2,
        0.5096695247430424223356548135815582e-3,
        0.2231547584535793797614188036013401e-3,
        0.994575127818085337145958900319017e-4,
        0.4492623673813314170020750240635786e-4,
        0.2050721277567069155316650397830591e-4,
        0.9439488275268395903987425104415055e-5,
        0.4374866789907487804181793223952411e-5,
        0.2039215753801366236781900709670839e-5,
        0.9551412130407419832857179772951265e-6,
        0.4492469198764566043294290331193655e-6,
        0.2120718480555466586923135901077628e-6,
        0.1004322482396809960872083050053344e-6,
        0.476981016936398056576019341724673e-7,
        0.2271109460894316491031998116062124e-7,
        0.1083865921489695409107491757968159e-7,
        0.5183475041970046655121248647057669e-8,
        0.2483674543802478317185008663991718e-8,
        0.119214014058609120744254820277464e-8,
        0.5731367241678862013330194857961011e-9,
        0.2759522885124233145178149692816341e-9,
        0.1330476437424448948149715720858008e-9,
        0.6422964563838100022082448087644648e-10,
        0.3104424774732227276239215783404066e-10,
        0.1502138408075414217093301048780668e-10,
        0.7275974480239079662504549924814047e-11,
        0.3527742476575915083615072228655483e-11,
        0.1711991790559617908601084114443031e-11,
        0.8315385841420284819798357793954418e-12,
        0.4042200525289440065536008957032895e-12,
        0.1966475631096616490411045679010286e-12,
        0.9573630387838555763782200936508615e-13,
        0.4664076026428374224576492565974577e-13,
        0.2273736960065972320633279596737272e-13,
        0.1109139947083452201658320007192334e-13
    ];
    const c = 0.2273736845824652515226821577978691e-12;
    const tol_logcf = 1e-14;
    let lgam;
    let i;
    if (fabs(a) >= 0.5)
        return lgamma_fn.lgammafn(a + 1);
    lgam = c * logcf(-a / 2, N + 2, 1, tol_logcf);
    for (i = N - 1; i >= 0; i--)
        lgam = coeffs[i] - a * lgam;
    return (a * lgam - eulers_const) * a - log1pmx(a);
}
exports.lgamma1p = lgamma1p;
const pr_dpois_wrap = src('dpois_wrap');
function dpois_wrap(x_plus_1, lambda, give_log) {
    pr_dpois_wrap('dpois_wrap(x+1=%d, lambda=%d, log=%s)', x_plus_1, lambda, give_log);
    if (!R_FINITE(lambda)) {
        return _general.R_D__0(give_log);
    }
    if (x_plus_1 > 1)
        return dpois_1.dpois_raw(x_plus_1 - 1, lambda, give_log);
    if (lambda > fabs(x_plus_1 - 1) * M_cutoff)
        return _general.R_D_exp(give_log, -lambda - lgamma_fn.lgammafn(x_plus_1));
    else {
        let d = dpois_1.dpois_raw(x_plus_1, lambda, give_log);
        pr_dpois_wrap('  -> d=dpois_raw(..)=%d', d);
        return give_log ? d + log(x_plus_1 / lambda) : d * (x_plus_1 / lambda);
    }
}
const pr_pgamma_smallx = src('pgamma_smallx');
function pgamma_smallx(x, alph, lowerTail, logP) {
    let sum = 0;
    let c = alph;
    let n = 0;
    let term;
    pr_pgamma_smallx(' pg_smallx(x=%d, alph=%d): ', x, alph);
    do {
        n++;
        c *= -x / n;
        term = c / (alph + n);
        sum += term;
    } while (fabs(term) > DBL_EPSILON * fabs(sum));
    pr_pgamma_smallx('%d terms --> conv.sum=%d;', n, sum);
    if (lowerTail) {
        let f1 = logP ? log1p(sum) : 1 + sum;
        let f2;
        if (alph > 1) {
            f2 = dpois_1.dpois_raw(alph, x, logP);
            f2 = logP ? f2 + x : f2 * exp(x);
        }
        else if (logP)
            f2 = alph * log(x) - lgamma1p(alph);
        else
            f2 = pow(x, alph) / exp(lgamma1p(alph));
        pr_pgamma_smallx(' (f1,f2)= (%d,%d)', f1, f2);
        return logP ? f1 + f2 : f1 * f2;
    }
    else {
        let lf2 = alph * log(x) - lgamma1p(alph);
        pr_pgamma_smallx(' 1:%d  2:%d', alph * log(x), lgamma1p(alph));
        pr_pgamma_smallx(' sum=%d  log(1+sum)=%d	 lf2=%d', sum, log1p(sum), lf2);
        if (logP)
            return expm1_1.R_Log1_Exp(log1p(sum) + lf2);
        else {
            let f1m1 = sum;
            let f2m1 = expm1(lf2);
            return -(f1m1 + f2m1 + f1m1 * f2m1);
        }
    }
}
function pd_upper_series(x, y, logP) {
    let term = x / y;
    let sum = term;
    do {
        y++;
        term *= x / y;
        sum += term;
    } while (term > sum * DBL_EPSILON);
    return logP ? log(sum) : sum;
}
const pr_pd_lower_cf = src('pd_lower_cf');
function pd_lower_cf(y, d) {
    let f = 0.0;
    let of;
    let f0;
    let i;
    let c2;
    let c3;
    let c4;
    let a1;
    let b1;
    let a2;
    let b2;
    const max_it = 200000;
    pr_pd_lower_cf('pd_lower_cf(y=%d, d=%d)', y, d);
    if (y === 0)
        return 0;
    f0 = y / d;
    if (fabs(y - 1) < fabs(d) * DBL_EPSILON) {
        pr_pd_lower_cf(' very small "y" -> returning (y/d)');
        return f0;
    }
    if (f0 > 1)
        f0 = 1;
    c2 = y;
    c4 = d;
    a1 = 0;
    b1 = 1;
    a2 = y;
    b2 = d;
    while (b2 > scalefactor) {
        a1 /= scalefactor;
        b1 /= scalefactor;
        a2 /= scalefactor;
        b2 /= scalefactor;
    }
    i = 0;
    of = -1;
    while (i < max_it) {
        i++;
        c2--;
        c3 = i * c2;
        c4 += 2;
        a1 = c4 * a2 + c3 * a1;
        b1 = c4 * b2 + c3 * b1;
        i++;
        c2--;
        c3 = i * c2;
        c4 += 2;
        a2 = c4 * a1 + c3 * a2;
        b2 = c4 * b1 + c3 * b2;
        if (b2 !== 0) {
            f = a2 / b2;
            if (fabs(f - of) <= DBL_EPSILON * fmax2(f0, fabs(f))) {
                pr_pd_lower_cf(' %d iter.\n', i);
                return f;
            }
            of = f;
        }
    }
    pr_pd_lower_cf(" ** NON-convergence in pgamma()'s pd_lower_cf() f= %d.", f);
    return f;
}
const pr_pd_lower_series = src('pd_lower_series');
function pd_lower_series(lambda, y) {
    let term = 1;
    let sum = 0;
    pr_pd_lower_series('pd_lower_series(lam=%d, y=%d) ...', lambda, y);
    while (y >= 1 && term > sum * DBL_EPSILON) {
        term *= y / lambda;
        sum += term;
        y--;
    }
    pr_pd_lower_series(' done: term=%d, sum=%d, y= %d', term, sum, y);
    if (y !== floor(y)) {
        let f;
        pr_pd_lower_series(' y not int: add another term ');
        f = pd_lower_cf(y, lambda + 1 - y);
        pr_pd_lower_series('  (= %d) * term = %d to sum %d', f, term * f, sum);
        sum += term * f;
    }
    return sum;
}
function dpnorm(x, lowerTail, lp) {
    if (x < 0) {
        x = -x;
        lowerTail = !lowerTail;
    }
    if (x > 10 && !lowerTail) {
        let term = 1 / x;
        let sum = term;
        let x2 = x * x;
        let i = 1;
        do {
            term *= -i / x2;
            sum += term;
            i += 2;
        } while (fabs(term) > DBL_EPSILON * sum);
        return 1 / sum;
    }
    else {
        let d = dnorm.dnorm4(x, 0, 1, false);
        return d / exp(lp);
    }
}
const pr_ppois_asymp = src('ppois_asymp');
function ppois_asymp(x, lambda, lowerTail, logP) {
    const coefs_a = [
        -1e99,
        2 / 3,
        -4 / 135,
        8 / 2835,
        16 / 8505,
        -8992 / 12629925,
        -334144 / 492567075,
        698752 / 1477701225
    ];
    const coefs_b = [
        -1e99,
        1 / 12,
        1 / 288,
        -139 / 51840,
        -571 / 2488320,
        163879 / 209018880,
        5246819 / 75246796800,
        -534703531 / 902961561600
    ];
    let elfb;
    let elfb_term;
    let res12;
    let res1_term;
    let res1_ig;
    let res2_term;
    let res2_ig;
    let dfm;
    let pt_;
    let s2pt;
    let f;
    let np;
    let i;
    dfm = lambda - x;
    pt_ = -log1pmx(dfm / x);
    s2pt = sqrt(2 * x * pt_);
    if (dfm < 0)
        s2pt = -s2pt;
    res12 = 0;
    res1_ig = res1_term = sqrt(x);
    res2_ig = res2_term = s2pt;
    for (i = 1; i < 8; i++) {
        res12 += res1_ig * coefs_a[i];
        res12 += res2_ig * coefs_b[i];
        res1_term *= pt_ / i;
        res2_term *= 2 * pt_ / (2 * i + 1);
        res1_ig = res1_ig / x + res1_term;
        res2_ig = res2_ig / x + res2_term;
    }
    elfb = x;
    elfb_term = 1;
    for (i = 1; i < 8; i++) {
        elfb += elfb_term * coefs_b[i];
        elfb_term /= x;
    }
    if (!lowerTail)
        elfb = -elfb;
    pr_ppois_asymp('res12 = %d   elfb=%d', elfb, res12);
    f = res12 / elfb;
    np = pnorm.pnorm5(s2pt, 0.0, 1.0, !lowerTail, logP);
    if (logP) {
        let n_d_over_p = dpnorm(s2pt, !lowerTail, np);
        pr_ppois_asymp('pp*_asymp(): f=%d	 np=e^%d  nd/np=%d  f*nd/np=%d', f, np, n_d_over_p, f * n_d_over_p);
        return np + log1p(f * n_d_over_p);
    }
    else {
        let nd = dnorm.dnorm4(s2pt, 0, 1, logP);
        pr_ppois_asymp('pp*_asymp(): f=%d	 np=%d  nd=%d  f*nd=%d', f, np, nd, f * nd);
        return np + f * nd;
    }
}
const pr_pgamma_raw = src('pgamma_raw');
function pgamma_raw(x, alph, lowerTail = true, logP = false) {
    let res;
    pr_pgamma_raw('pgamma_raw(x=%d, alph=%d, low=%s, log=%s)', x, alph, lowerTail, logP);
    let rc = _general.R_P_bounds_01(lowerTail, logP, x, 0, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    if (x < 1) {
        res = pgamma_smallx(x, alph, lowerTail, logP);
    }
    else if (x <= alph - 1 && x < 0.8 * (alph + 50)) {
        let sum = pd_upper_series(x, alph, logP);
        let d = dpois_wrap(alph, x, logP);
        pr_pgamma_raw(' alph "large": sum=pd_upper*()= %d, d=dpois_w(*)= %d', sum, d);
        if (!lowerTail)
            res = logP ? expm1_1.R_Log1_Exp(d + sum) : 1 - d * sum;
        else
            res = logP ? sum + d : sum * d;
    }
    else if (alph - 1 < x && alph < 0.8 * (x + 50)) {
        let sum;
        let d = dpois_wrap(alph, x, logP);
        pr_pgamma_raw('  x "large": d=dpois_w(*)= %d ', d);
        if (alph < 1) {
            if (x * DBL_EPSILON > 1 - alph)
                sum = _general.R_D__1(logP);
            else {
                let f = pd_lower_cf(alph, x - (alph - 1)) * x / alph;
                sum = logP ? log(f) : f;
            }
        }
        else {
            sum = pd_lower_series(x, alph - 1);
            sum = logP ? log1p(sum) : 1 + sum;
        }
        pr_pgamma_raw(', sum= %d', sum);
        if (!lowerTail)
            res = logP ? sum + d : sum * d;
        else
            res = logP ? expm1_1.R_Log1_Exp(d + sum) : 1 - d * sum;
    }
    else {
        pr_pgamma_raw(' using ppois_asymp()');
        res = ppois_asymp(alph - 1, x, !lowerTail, logP);
    }
    if (!logP && res < DBL_MIN / DBL_EPSILON) {
        pr_pgamma_raw(' very small res=%.14g; -> recompute via log\n', res);
        return exp(pgamma_raw(x, alph, lowerTail, true));
    }
    else
        return res;
}
exports.pgamma_raw = pgamma_raw;
const printer_pgamma = src('pgamma');
function pgamma(q, shape, scale, lowerTail, logP) {
    const fa = isArray(q) ? q : [q];
    const result = fa.map(x => {
        if (ISNAN(x) || ISNAN(shape) || ISNAN(scale)) {
            return x + shape + scale;
        }
        if (shape < 0 || scale <= 0)
            return _general.ML_ERR_return_NAN(printer_pgamma);
        x /= scale;
        if (ISNAN(x))
            return x;
        if (shape === 0)
            return x <= 0
                ? _general.R_DT_0(lowerTail, logP)
                : _general.R_DT_1(lowerTail, logP);
        return pgamma_raw(x, shape, lowerTail, logP);
    });
    return result.length === 1 ? result[0] : result;
}
exports.pgamma = pgamma;

});

var pchisq_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pchisq = void 0;

function pchisq(x, df, lowerTail = true, logP = false) {
    return pgamma_1.pgamma(x, df / 2., 2., lowerTail, logP);
}
exports.pchisq = pchisq;

});

var logspaceAdd = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.logspace_add = void 0;
const { max: fmax2, log1p, exp, abs: fabs } = Math;
function logspace_add(logx, logy) {
    return fmax2(logx, logy) + log1p(exp(-fabs(logx - logy)));
}
exports.logspace_add = logspace_add;

});

var pnchisq_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pnchisq_raw = exports.pnchisq = exports.DBL_MIN_EXP = exports.DBL_MAX_EXP = void 0;







const { sqrt, abs: fabs, exp, log, min: fmin2, max: fmax2, LN2: M_LN2, LN10: M_LN10 } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, EPSILON: DBL_EPSILON, NEGATIVE_INFINITY: ML_NEGINF } = Number;
exports.DBL_MAX_EXP = Math.log2(Number.MAX_VALUE);
exports.DBL_MIN_EXP = Math.log2(Number.MIN_VALUE);
const _dbl_min_exp = M_LN2 * exports.DBL_MIN_EXP;
const { expm1, log1p } = Math;
const printer = src('pnchisq');
function pnchisq(xx, df, ncp = 0, lower_tail = true, log_p = false) {
    return rFunc.map(xx)(x => {
        let ans;
        if (ISNAN(x) || ISNAN(df) || ISNAN(ncp)) {
            return NaN;
        }
        if (!R_FINITE(df) || !R_FINITE(ncp)) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (df < 0 || ncp < 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        ans = pnchisq_raw(x, df, ncp, 1e-12, 8 * DBL_EPSILON, 1000000, lower_tail, log_p);
        if (ncp >= 80) {
            if (lower_tail) {
                ans = fmin2(ans, _general.R_D__1(log_p));
            }
            else {
                if (ans < (log_p ? -10 * M_LN10 : 1e-10))
                    _general.ML_ERROR(_general.ME.ME_PRECISION, 'pnchisq', printer);
                if (!log_p)
                    ans = fmax2(ans, 0.0);
            }
        }
        if (!log_p || ans < -1e-8) {
            return ans;
        }
        printer('   pnchisq_raw(*, log_p): ans=%d => 2nd call, other tail', ans);
        ans = pnchisq_raw(x, df, ncp, 1e-12, 8 * DBL_EPSILON, 1000000, !lower_tail, false);
        return log1p(-ans);
    });
}
exports.pnchisq = pnchisq;
function pnchisq_raw(x, f, theta, errmax, reltol, itrmax, lower_tail, log_p) {
    let lam;
    let x2;
    let f2;
    let term;
    let bound;
    let f_x_2n;
    let f_2n;
    let l_lam = -1;
    let l_x = -1;
    let lamSml;
    let tSml;
    let is_r;
    let is_b;
    let is_it;
    let ans;
    let u;
    let v;
    let t;
    let lt;
    let lu = -1;
    if (x <= 0) {
        if (x === 0 && f === 0) {
            const _L = -0.5 * theta;
            const result = lower_tail ?
                _general.R_D_exp(log_p, _L)
                : (log_p ? expm1_1.R_Log1_Exp(_L)
                    : -expm1(_L));
            printer('result1:%d', result);
            return result;
        }
        return _general.R_DT_0(lower_tail, log_p);
    }
    if (!R_FINITE(x))
        return _general.R_DT_1(lower_tail, log_p);
    if (theta < 80) {
        let ans;
        let i;
        if (lower_tail &&
            f > 0 &&
            log(x) < M_LN2 + 2 / f * (lgamma_fn.lgammafn(f / 2 + 1) + _dbl_min_exp)) {
            let lambda = 0.5 * theta;
            let sum = ML_NEGINF;
            let sum2 = ML_NEGINF;
            let pr = -lambda;
            for (i = 0; i < 110; pr += log(lambda) - log(++i)) {
                sum2 = logspaceAdd.logspace_add(sum2, pr);
                sum = logspaceAdd.logspace_add(sum, pr + pchisq_1.pchisq(x, f + 2 * i, lower_tail, true));
                if (sum2 >= -1e-15) {
                    break;
                }
            }
            ans = sum - sum2;
            printer('pnchisq(x=%d, f=%d, th.=%d); th. < 80, logspace: i=%d, ans=(sum=%d)-(sum2=%d)', x, f, theta, i, sum, sum2);
            return log_p ? ans : exp(ans);
        }
        else {
            let lambda = 0.5 * theta;
            let sum = 0;
            let sum2 = 0;
            let pr = exp(-lambda);
            for (i = 0; i < 110; pr *= lambda / ++i) {
                sum2 += pr;
                sum += pr * pchisq_1.pchisq(x, f + 2 * i, lower_tail, false);
                if (sum2 >= 1 - 1e-15)
                    break;
            }
            ans = sum / sum2;
            printer('pnchisq(x=%d, f=%d, theta=%d); theta < 80: i=%d, sum=%d, sum2=%d', x, f, theta, i, sum, sum2);
            return log_p ? log(ans) : ans;
        }
    }
    printer('pnchisq(x=%d, f=%d, theta=%d >= 80): ', x, f, theta);
    lam = 0.5 * theta;
    lamSml = -lam < _dbl_min_exp;
    if (lamSml) {
        u = 0;
        lu = -lam;
        l_lam = log(lam);
    }
    else {
        u = exp(-lam);
    }
    v = u;
    x2 = 0.5 * x;
    f2 = 0.5 * f;
    f_x_2n = f - x;
    printer('-- v=exp(-th/2)=%d, x/2= %d, f/2= %d', v, x2, f2);
    if (f2 * DBL_EPSILON > 0.125 &&
        fabs((t = x2 - f2)) <
            sqrt(DBL_EPSILON) * f2) {
        lt = (1 - t) * (2 - t / (f2 + 1)) - _general.M_LN_SQRT_2PI - 0.5 * log(f2 + 1);
        printer(' (case I) === > ');
    }
    else {
        lt = f2 * log(x2) - x2 - lgamma_fn.lgammafn(f2 + 1);
    }
    printer(' lt= %d', lt);
    tSml = lt < _dbl_min_exp;
    if (tSml) {
        printer(' is very small');
        if (x > f + theta + 5 * sqrt(2 * (f + 2 * theta))) {
            return _general.R_DT_1(lower_tail, log_p);
        }
        l_x = log(x);
        ans = term = 0;
        t = 0;
    }
    else {
        t = exp(lt);
        printer(', t=exp(lt)= %d', t);
        term = v * t;
        ans = term;
    }
    let n;
    for (n = 1, f_2n = f + 2, f_x_2n += 2;; n++, f_2n += 2, f_x_2n += 2) {
        printer(' _OL_: n=%d', n);
        if (f_x_2n > 0) {
            bound = t * x / f_x_2n;
            printer(' L10: n=%d; term= %d; bound= %d', n, term, bound);
            is_r = is_it = false;
            if (((is_b = bound <= errmax) && (is_r = term <= reltol * ans)) ||
                (is_it = n > itrmax)) {
                printer('BREAK n=%d %s; bound= %d %s, rel.err= %d %s', n, is_it ? '> itrmax' : '', bound, is_b ? '<= errmax' : '', term / ans, is_r ? '<= reltol' : '');
                break;
            }
        }
        if (lamSml) {
            lu += l_lam - log(n);
            if (lu >= _dbl_min_exp) {
                printer(' n=%d; nomore underflow in u = exp(lu) === > change', n);
                v = u = exp(lu);
                lamSml = false;
            }
        }
        else {
            u *= lam / n;
            v += u;
        }
        if (tSml) {
            lt += l_x - log(f_2n);
            if (lt >= _dbl_min_exp) {
                printer('  n=%d; nomore underflow in t = exp(lt) === > change', n);
                t = exp(lt);
                tSml = false;
            }
        }
        else {
            t *= x / f_2n;
        }
        if (!lamSml && !tSml) {
            term = v * t;
            ans += term;
        }
    }
    if (is_it) {
        printer('pnchisq(x=%d, ..): not converged in %d iter.', x, itrmax);
    }
    printer(' ===  L_End: n=%d; term= %d; bound=%d', n, term, bound);
    return _general.R_DT_val(lower_tail, log_p, ans);
}
exports.pnchisq_raw = pnchisq_raw;

});

var qgamma_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports._qgamma = exports.qgamma = exports.qchisq_appr = void 0;







const pgamma_3 = pgamma_1;

const { isArray } = Array;
const { abs: fabs, sqrt, pow, exp, log } = Math;
const { isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF, NEGATIVE_INFINITY: ML_NEGINF, MIN_VALUE: DBL_MIN, isFinite: R_FINITE } = Number;
const printer_qchisq_appr = src('qchisq_appr');
function qchisq_appr(p, nu, g, lower_tail, log_p, tol) {
    const C7 = 4.67;
    const C8 = 6.66;
    const C9 = 6.73;
    const C10 = 13.32;
    let alpha;
    let a;
    let c;
    let ch;
    let p1;
    let p2;
    let q;
    let t;
    let x;
    if (ISNAN(p) || ISNAN(nu))
        return p + nu;
    let rc = _general.R_Q_P01_check(log_p, p);
    if (rc !== undefined) {
        return rc;
    }
    if (nu <= 0) {
        return _general.ML_ERR_return_NAN(printer_qchisq_appr);
    }
    alpha = 0.5 * nu;
    c = alpha - 1;
    if (nu < -1.24 * (p1 = expm1_1.R_DT_log(lower_tail, log_p, p))) {
        let lgam1pa = alpha < 0.5 ? pgamma_3.lgamma1p(alpha) : log(alpha) + g;
        ch = exp((lgam1pa + p1) / alpha + _general.M_LN2);
        printer_qchisq_appr(' small chi-sq., ch0 = %d', ch);
    }
    else if (nu > 0.32) {
        x = qnorm_1.qnorm(p, 0, 1, lower_tail, log_p);
        p1 = 2 / (9 * nu);
        ch = nu * pow(x * sqrt(p1) + 1 - p1, 3);
        printer_qchisq_appr(' nu > .32: Wilson-Hilferty; x = %d', x);
        if (ch > 2.2 * nu + 6)
            ch = -2 * (expm1_1.R_DT_Clog(lower_tail, log_p, p) - c * log(0.5 * ch) + g);
    }
    else {
        ch = 0.4;
        a = expm1_1.R_DT_Clog(lower_tail, log_p, p) + g + c * _general.M_LN2;
        printer_qchisq_appr(' nu <= .32: a = %d', a);
        do {
            q = ch;
            p1 = 1 / (1 + ch * (C7 + ch));
            p2 = ch * (C9 + ch * (C8 + ch));
            t = -0.5 + (C7 + 2 * ch) * p1 - (C9 + ch * (C10 + 3 * ch)) / p2;
            ch -= (1 - exp(a + 0.5 * ch) * p2 * p1) / t;
        } while (fabs(q - ch) > tol * fabs(ch));
    }
    return ch;
}
exports.qchisq_appr = qchisq_appr;
function qgamma(p, alpha = 1, scale = 1, lowerTail = true, logP = false) {
    const fa = isArray(p) ? p : [p];
    const result = fa.map(pp => _qgamma(pp, alpha, scale, lowerTail, logP));
    return result.length === 1 ? result[0] : result;
}
exports.qgamma = qgamma;
const printer_qgamma = src('_qgamma');
function _qgamma(p, alpha = 1, scale = 1 / alpha, lower_tail = true, log_p = false) {
    const EPS1 = 1e-2;
    const EPS2 = 5e-7;
    const EPS_N = 1e-15;
    const MAXIT = 1000;
    const pMIN = 1e-100;
    const pMAX = 1 - 1e-14;
    const i420 = 1 / 420;
    const i2520 = 1 / 2520;
    const i5040 = 1 / 5040;
    let p_;
    let a;
    let b;
    let c;
    let g;
    let ch;
    let ch0;
    let p1;
    let p2;
    let s1;
    let s2;
    let s3;
    let s4;
    let s5;
    let s6;
    let t;
    let x;
    let i;
    let max_it_Newton = 1;
    let q = 0;
    let goto_END = false;
    if (ISNAN(p) || ISNAN(alpha) || ISNAN(scale))
        return p + alpha + scale;
    let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, 0, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    if (alpha < 0 || scale <= 0)
        return _general.ML_ERR_return_NAN(printer_qgamma);
    if (alpha === 0)
        return 0;
    if (alpha < 1e-10) {
        printer_qgamma('value of shape (%d) is extremely small: results may be unreliable', alpha);
        max_it_Newton = 7;
    }
    p_ = expm1_1.R_DT_qIv(lower_tail, log_p, p);
    printer_qgamma('qgamma(p=%d, alpha=%d, scale=%d, l.t.=%s, log_p=%s): ', p, alpha, scale, lower_tail, log_p);
    g = lgamma_fn.lgammafn(alpha);
    ch = qchisq_appr(p, 2 * alpha, g, lower_tail, log_p, EPS1);
    if (!R_FINITE(ch)) {
        max_it_Newton = 0;
        goto_END = true;
    }
    if (goto_END === false) {
        if (ch < EPS2) {
            max_it_Newton = 20;
            goto_END = true;
        }
    }
    if (goto_END === false) {
        if (p_ > pMAX || p_ < pMIN) {
            max_it_Newton = 20;
            goto_END = true;
        }
    }
    if (goto_END === false) {
        printer_qgamma('\t==> ch = %d:', ch);
        c = alpha - 1;
        s6 = (120 + c * (346 + 127 * c)) * i5040;
        ch0 = ch;
        for (i = 1; i <= MAXIT; i++) {
            q = ch;
            p1 = 0.5 * ch;
            p2 =
                p_ -
                    pgamma_1.pgamma_raw(p1, alpha, true, false);
            if (i === 1)
                printer_qgamma(' Ph.II iter; ch=%d, p2=%d', ch, p2);
            if (i >= 2)
                printer_qgamma('     it=%d,  ch=%d, p2=%d', i, ch, p2);
            if (!R_FINITE(p2) || ch <= 0) {
                ch = ch0;
                max_it_Newton = 27;
                goto_END = true;
                break;
            }
            t = p2 * exp(alpha * _general.M_LN2 + g + p1 - c * log(ch));
            b = t / ch;
            a = 0.5 * t - b * c;
            s1 = (210 + a * (140 + a * (105 + a * (84 + a * (70 + 60 * a))))) * i420;
            s2 = (420 + a * (735 + a * (966 + a * (1141 + 1278 * a)))) * i2520;
            s3 = (210 + a * (462 + a * (707 + 932 * a))) * i2520;
            s4 =
                (252 + a * (672 + 1182 * a) + c * (294 + a * (889 + 1740 * a))) * i5040;
            s5 = (84 + 2264 * a + c * (1175 + 606 * a)) * i2520;
            ch +=
                t *
                    (1 +
                        0.5 * t * s1 -
                        b * c * (s1 - b * (s2 - b * (s3 - b * (s4 - b * (s5 - b * s6))))));
            if (fabs(q - ch) < EPS2 * ch) {
                goto_END = true;
                break;
            }
            if (fabs(q - ch) > 0.1 * ch) {
                if (ch < q)
                    ch = 0.9 * q;
                else
                    ch = 1.1 * q;
            }
        }
        printer_qgamma('qgamma(%d) not converged in %d iterations; rel.ch=%d', p, MAXIT, ch / fabs(q - ch));
    }
    x = 0.5 * scale * ch;
    if (max_it_Newton) {
        if (!log_p) {
            p = log(p);
            log_p = true;
        }
        if (x === 0) {
            const _1_p = 1 + 1e-7;
            const _1_m = 1 - 1e-7;
            x = DBL_MIN;
            p_ = pgamma_1.pgamma(x, alpha, scale, lower_tail, log_p);
            if ((lower_tail && p_ > p * _1_p) || (!lower_tail && p_ < p * _1_m))
                return 0;
        }
        else
            p_ = pgamma_1.pgamma(x, alpha, scale, lower_tail, log_p);
        if (p_ === ML_NEGINF)
            return 0;
        for (i = 1; i <= max_it_Newton; i++) {
            p1 = p_ - p;
            if (i === 1)
                printer_qgamma(' it=%d: p=%d, x = %d, p.=%d; p1=d{p}=%d', i, p, x, p_, p1);
            if (i >= 2)
                printer_qgamma('          x{it= %d} = %d, p.=%d, p1=d{p}=%d', i, x, p_, p1);
            if (fabs(p1) < fabs(EPS_N * p))
                break;
            g = dgamma_1.dgamma(x, alpha, scale, log_p);
            if (g === _general.R_D__0(log_p)) {
                if (i === 1)
                    printer_qgamma('no final Newton step because dgamma(*)== 0!');
                break;
            }
            t = log_p ? p1 * exp(p_ - g) : p1 / g;
            t = lower_tail ? x - t : x + t;
            p_ = pgamma_1.pgamma(t, alpha, scale, lower_tail, log_p);
            if (fabs(p_ - p) > fabs(p1) ||
                (i > 1 && fabs(p_ - p) === fabs(p1))) {
                if (i === 1 && max_it_Newton > 1)
                    printer_qgamma('no Newton step done since delta{p} >= last delta');
                break;
            }
            if (t > 1.1 * x)
                t = 1.1 * x;
            else if (t < 0.9 * x)
                t = 0.9 * x;
            x = t;
        }
    }
    return x;
}
exports._qgamma = _qgamma;

});

var qchisq_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qchisq = void 0;

function qchisq(p, df, lowerTail = true, logP = false) {
    return qgamma_1.qgamma(p, 0.5 * df, 2.0, lowerTail, logP);
}
exports.qchisq = qchisq;

});

var qnchisq_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qnchisq = void 0;





const { expm1, min: fmin2 } = Math;
const { MAX_VALUE: DBL_MAX, MIN_VALUE: DBL_MIN, EPSILON: DBL_EPSILON, isNaN: ISNAN, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer = src('_qnchisq');
function qnchisq(pp, df, ncp = 0, lowerTail = true, logP = false) {
    return rFunc.map(pp)(p => _qnchisq(p, df, ncp, lowerTail, logP));
}
exports.qnchisq = qnchisq;
function _qnchisq(p, df, ncp, lower_tail = true, log_p = false) {
    printer('start');
    const accu = 1e-13;
    const racc = 4 * DBL_EPSILON;
    const Eps = 1e-11;
    const rEps = 1e-10;
    let ux;
    let lx;
    let ux0;
    let nx;
    let pp;
    if (ISNAN(p) || ISNAN(df) || ISNAN(ncp)) {
        return NaN;
    }
    if (!R_FINITE(df)) {
        return _general.ML_ERR_return_NAN(printer);
    }
    if (df < 0 || ncp < 0) {
        return _general.ML_ERR_return_NAN(printer);
    }
    let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, 0, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    pp = _general.R_D_qIv(log_p, p);
    if (pp > 1 - DBL_EPSILON) {
        return lower_tail ? ML_POSINF : 0.0;
    }
    {
        let b;
        let c;
        let ff;
        b = ncp * ncp / (df + 3 * ncp);
        c = (df + 3 * ncp) / (df + 2 * ncp);
        ff = (df + 2 * ncp) / (c * c);
        ux = b + c * qchisq_1.qchisq(p, ff, lower_tail, log_p);
        if (ux < 0)
            ux = 1;
        ux0 = ux;
    }
    if (!lower_tail && ncp >= 80) {
        if (pp < 1e-10)
            _general.ML_ERROR(_general.ME.ME_PRECISION, 'qnchisq', printer);
        p = log_p ? -expm1(p) : 0.5 - p + 0.5;
        lower_tail = true;
    }
    else {
        p = pp;
    }
    pp = fmin2(1 - DBL_EPSILON, p * (1 + Eps));
    if (lower_tail) {
        for (; ux < DBL_MAX &&
            pnchisq_1.pnchisq_raw(ux, df, ncp, Eps, rEps, 10000, true, false) < pp; ux *= 2)
            ;
        pp = p * (1 - Eps);
        for (lx = fmin2(ux0, DBL_MAX); lx > DBL_MIN &&
            pnchisq_1.pnchisq_raw(lx, df, ncp, Eps, rEps, 10000, true, false) > pp; lx *= 0.5)
            ;
    }
    else {
        for (; ux < DBL_MAX &&
            pnchisq_1.pnchisq_raw(ux, df, ncp, Eps, rEps, 10000, false, false) > pp; ux *= 2)
            ;
        pp = p * (1 - Eps);
        for (lx = fmin2(ux0, DBL_MAX); lx > DBL_MIN &&
            pnchisq_1.pnchisq_raw(lx, df, ncp, Eps, rEps, 10000, false, false) < pp; lx *= 0.5)
            ;
    }
    if (lower_tail) {
        do {
            nx = 0.5 * (lx + ux);
            if (pnchisq_1.pnchisq_raw(nx, df, ncp, accu, racc, 100000, true, false) > p)
                ux = nx;
            else
                lx = nx;
        } while ((ux - lx) / nx > accu);
    }
    else {
        do {
            nx = 0.5 * (lx + ux);
            if (pnchisq_1.pnchisq_raw(nx, df, ncp, accu, racc, 100000, false, false) < p)
                ux = nx;
            else
                lx = nx;
        } while ((ux - lx) / nx > accu);
    }
    return 0.5 * (ux + lx);
}

});

var chi2 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChiSquared = void 0;









function ChiSquared(rng = new normal$1.Inversion()) {
    function rchisq(n = 1, df, ncp) {
        return ncp === undefined
            ? rchisq_1.rchisq(n, df, rng)
            : rnchisq_1.rnchisq(n, df, ncp, rng);
    }
    function qchisq(p, df, ncp, lowerTail = true, logP = false) {
        return ncp === undefined
            ? qchisq_1.qchisq(p, df, lowerTail, logP)
            : qnchisq_1.qnchisq(p, df, ncp, lowerTail, logP);
    }
    function pchisq(p, df, ncp, lowerTail = true, logP = false) {
        return ncp === undefined
            ? pchisq_1.pchisq(p, df, lowerTail, logP)
            : pnchisq_1.pnchisq(p, df, ncp, lowerTail, logP);
    }
    function dchisq(x, df, ncp, log = false) {
        return ncp === undefined ? dchisq_1.dchisq(x, df, log) : dnchisq_1.dnchisq(x, df, ncp, log);
    }
    return {
        dchisq,
        pchisq,
        qchisq,
        rchisq
    };
}
exports.ChiSquared = ChiSquared;

});

var dexp_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dexp = void 0;



const { log, exp } = Math;
const { isNaN: ISNAN } = Number;
const printer = src('dexp');
function dexp(x, scale, give_log = false) {
    return rFunc.map(x)(fx => {
        if (ISNAN(fx) || ISNAN(scale)) {
            return NaN;
        }
        if (scale <= 0.0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (fx < 0) {
            return _general.R_D__0(give_log);
        }
        return give_log ? -fx / scale - log(scale) : exp(-fx / scale) / scale;
    });
}
exports.dexp = dexp;

});

var pexp_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pexp = void 0;




const { expm1 } = Math;
const { isNaN: ISNAN } = Number;
const printer = src('pexp');
function pexp(q, scale, lower_tail, log_p) {
    return rFunc.map(q)(fx => {
        if (ISNAN(fx) || ISNAN(scale))
            return fx + scale;
        if (scale < 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (fx <= 0)
            return _general.R_DT_0(lower_tail, log_p);
        fx = -(fx / scale);
        return lower_tail
            ? log_p ? expm1_1.R_Log1_Exp(fx) : -expm1(fx)
            : _general.R_D_exp(log_p, fx);
    });
}
exports.pexp = pexp;

});

var qexp_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qexp = void 0;




const { isNaN: ISNAN } = Number;
const printer = src('qexp');
function qexp(_p, scale, lower_tail, log_p) {
    return rFunc.map(_p)(p => {
        if (ISNAN(p) || ISNAN(scale))
            return p + scale;
        if (scale < 0)
            return _general.ML_ERR_return_NAN(printer);
        let rc = _general.R_Q_P01_check(log_p, p);
        if (rc !== undefined) {
            return rc;
        }
        if (p === _general.R_DT_0(lower_tail, log_p))
            return 0;
        return -scale * expm1_1.R_DT_Clog(lower_tail, log_p, p);
    });
}
exports.qexp = qexp;

});

var rexp_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rexp = void 0;



const { isFinite: R_FINITE } = Number;
const printer = src('rexp');
function rexp(n = 1, scale = 1, rng) {
    const result = new Array(n).fill(0).map(m => {
        if (!R_FINITE(scale) || scale <= 0.0) {
            if (scale === 0)
                return 0;
            return _general.ML_ERR_return_NAN(printer);
        }
        return scale * sexp.exp_rand(rng.unif_rand);
    });
    return result.length === 1 ? result[0] : result;
}
exports.rexp = rexp;

});

var taocp1997Init = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.TAOCP1997init = void 0;

const { trunc } = Math;
function TAOCP1997init(seed) {
    const KK = 100;
    const LL = 37;
    const MM = 1073741824;
    const MMF = 1073741824 - 1;
    const KKK = 199;
    const KKL = 63;
    let ss = seed - seed % 2 + 2;
    const X = new Uint32Array(KKK);
    const arr = rFunc.seq(-1)();
    for (let j of arr(1, KK)) {
        X[j] = ss;
        ss = ss + ss;
        if (ss >= MM)
            ss = ss - MM + 2;
    }
    X[1]++;
    ss = seed;
    let T = 69;
    while (T > 0) {
        for (let j of arr(KK, 2)) {
            X[j + j] = X[j];
        }
        for (let j of arr(KKK, KKL + 1, -2)) {
            X[KKK - j] = X[j] - X[j] % 2;
        }
        for (let j of arr(KKK, KK + 1)) {
            if (X[j] % 2 === 1) {
                X[j - KKL] = (X[j - KKL] - X[j]) & MMF;
                X[j - KK] = (X[j - KK] - X[j]) & MMF;
            }
        }
        if (ss & 1) {
            for (let j of arr(KK, 1)) {
                X[j + 1] = X[j];
            }
            X[1 - 1] = X[KK + 1 - 1];
            if (X[KK + 1 - 1] % 2 === 1) {
                X[LL + 1 - 1] = (X[LL + 1 - 1] - X[KK + 1 - 1]) & MMF;
            }
        }
        if (ss) {
            ss = trunc(ss / 2);
        }
        else {
            T = T - 1;
        }
    }
    const res = new Uint32Array(KK);
    res.set(X.slice(LL, KK));
    res.set(X.slice(0, LL), KK - LL);
    return res;
}
exports.TAOCP1997init = TAOCP1997init;

});

var knuthTaocp = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.KnuthTAOCP = void 0;





const MM = 1 << 30;
const KK = 100;
const LL = 37;
const QUALITY = 1009;
const qualityBuffer = new ArrayBuffer(QUALITY * 4);
const ran_arr_buf = new Uint32Array(qualityBuffer);
const KT = 9.31322574615479e-10;
const mod_diff = (x, y) => (x - y) & (MM - 1);
const SEED_LEN = 101;
class KnuthTAOCP extends irng.IRNG {
    constructor(_seed = timeseed_1.timeseed()) {
        super(_seed);
    }
    get KT_pos() {
        return this.m_seed[100];
    }
    set KT_pos(v) {
        this.m_seed[100] = v;
    }
    fixupSeeds() {
        if (this.KT_pos <= 0)
            this.KT_pos = 100;
        const s = this.m_seed.slice(0, 100);
        if (s.find(v => !!v) === undefined)
            this.init(timeseed_1.timeseed());
        return;
    }
    KT_next() {
        const s = this.m_seed;
        if (this.KT_pos >= 100) {
            this.ran_arr_cycle();
            this.KT_pos = 0;
        }
        return s[this.KT_pos++];
    }
    RNG_Init_R_KT(_seed) {
        this.m_seed.set(taocp1997Init.TAOCP1997init(_seed % 1073741821));
        this.KT_pos = 100;
        this.fixupSeeds();
    }
    ran_arr_cycle() {
        this.ran_array(ran_arr_buf, QUALITY);
        ran_arr_buf[KK] = -1;
        return ran_arr_buf[0];
    }
    ran_array(aa, n) {
        let i;
        let j;
        const ran_x = this.m_seed;
        for (j = 0; j < KK; j++)
            aa[j] = ran_x[j];
        for (; j < n; j++)
            aa[j] = mod_diff(aa[j - KK], aa[j - LL]);
        for (i = 0; i < LL; i++, j++)
            ran_x[i] = mod_diff(aa[j - KK], aa[j - LL]);
        for (; i < KK; i++, j++)
            ran_x[i] = mod_diff(aa[j - KK], ran_x[i - LL]);
    }
    _setup() {
        this.buf = new ArrayBuffer(SEED_LEN * 4);
        this._kind = irngType.IRNGType.KNUTH_TAOCP;
        this._name = 'Knuth-TAOCP';
        this.m_seed = new Int32Array(this.buf).fill(0);
    }
    init(_seed = timeseed_1.timeseed()) {
        const s = new Uint32Array([0]);
        s[0] = _seed;
        for (let j = 0; j < 50; j++) {
            s[0] = 69069 * s[0] + 1;
        }
        this.RNG_Init_R_KT(s[0]);
        super.init(_seed);
    }
    set seed(_seed) {
        if (_seed.length > this.m_seed.length || _seed.length === 0) {
            this.init(timeseed_1.timeseed());
            return;
        }
        this.m_seed.set(_seed);
    }
    internal_unif_rand() {
        return fixup_1.fixup(this.KT_next() * KT);
    }
    get seed() {
        return Array.from(this.m_seed);
    }
}
exports.KnuthTAOCP = KnuthTAOCP;

});

var knuthTaocp2002 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.KnuthTAOCP2002 = void 0;




const QUALITY = 1009;
const SEED_LEN = 101;
const LL = 37;
const KK = 100;
const TT = 70;
const MM = 1073741824;
function mod_diff(x, y) {
    const d = new Uint32Array(3);
    d[0] = x;
    d[1] = y;
    d[2] = (d[0] - d[1]) & (MM - 1);
    return d[2];
}
function is_odd(x) {
    return x % 2 === 1;
}
class KnuthTAOCP2002 extends irng.IRNG {
    constructor(_seed = timeseed_1.timeseed()) {
        super(_seed);
    }
    get KT_pos() {
        return this.m_seed[100];
    }
    set KT_pos(v) {
        this.m_seed[100] = v;
    }
    ran_array(aa, n) {
        let i;
        let j;
        for (j = 0; j < KK; j++) {
            aa[j] = this.ran_x[j];
        }
        for (; j < n; j++) {
            aa[j] = mod_diff(aa[j - KK], aa[j - LL]);
        }
        for (i = 0; i < LL; i++, j++) {
            this.ran_x[i] = mod_diff(aa[j - KK], aa[j - LL]);
        }
        for (; i < KK; i++, j++) {
            this.ran_x[i] = mod_diff(aa[j - KK], this.ran_x[i - LL]);
        }
    }
    ran_arr_cycle() {
        this.ran_array(this.ran_arr_buf, QUALITY);
        this.ran_arr_buf[KK] = -1;
    }
    ran_start(_seed) {
        let t;
        let j;
        const x = new Uint32Array(KK + KK - 1);
        const ss = new Uint32Array(1);
        const se = new Uint32Array([_seed]);
        ss[0] = (se[0] + 2) & (MM - 2);
        for (j = 0; j < KK; j++) {
            x[j] = ss[0];
            ss[0] = ss[0] << 1;
            if (ss[0] >= MM) {
                ss[0] = ss[0] - (MM - 2);
            }
        }
        x[1]++;
        for (ss[0] = se[0] & (MM - 1), t = TT - 1; t;) {
            for (j = KK - 1; j > 0; j--) {
                x[j + j] = x[j];
                x[j + j - 1] = 0;
            }
            for (j = KK + KK - 2; j >= KK; j--) {
                x[j - (KK - LL)] = mod_diff(x[j - (KK - LL)], x[j]);
                x[j - KK] = mod_diff(x[j - KK], x[j]);
            }
            if (is_odd(ss[0])) {
                for (j = KK; j > 0; j--) {
                    x[j] = x[j - 1];
                }
                x[0] = x[KK];
                x[LL] = mod_diff(x[LL], x[KK]);
            }
            if (ss[0]) {
                ss[0] = ss[0] >>> 1;
            }
            else {
                t--;
            }
        }
        for (j = 0; j < LL; j++) {
            this.ran_x[j + KK - LL] = x[j];
        }
        for (; j < KK; j++) {
            this.ran_x[j - LL] = x[j];
        }
        for (j = 0; j < 10; j++) {
            this.ran_array(x, KK + KK - 1);
        }
    }
    RNG_Init_KT2(_seed) {
        this.ran_start(_seed % 1073741821);
        this.KT_pos = 100;
    }
    KT_next() {
        if (this.KT_pos >= 100) {
            this.ran_arr_cycle();
            this.KT_pos = 0;
        }
        return this.ran_x[this.KT_pos++];
    }
    _setup() {
        this._kind = irngType.IRNGType.KNUTH_TAOCP2002;
        this._name = 'Knuth-TAOCP-2002';
        this.qualityBuffer = new ArrayBuffer(QUALITY * 4);
        this.ran_arr_buf = new Uint32Array(this.qualityBuffer);
        const buf = new ArrayBuffer(SEED_LEN * 4);
        this.m_seed = new Uint32Array(buf).fill(0);
        this.ran_x = this.m_seed;
    }
    internal_unif_rand() {
        const KT = 9.31322574615479e-10;
        return fixup_1.fixup(this.KT_next() * KT);
    }
    init(_seed = timeseed_1.timeseed()) {
        const s = new Uint32Array([0]);
        s[0] = _seed;
        for (let j = 0; j < 50; j++) {
            s[0] = 69069 * s[0] + 1;
        }
        this.RNG_Init_KT2(s[0]);
        super.init(_seed);
    }
    set seed(_seed) {
        if (_seed.length > this.m_seed.length || _seed.length === 0) {
            this.init(timeseed_1.timeseed());
            return;
        }
        this.m_seed.set(_seed);
    }
    get seed() {
        return Array.from(this.m_seed);
    }
}
exports.KnuthTAOCP2002 = KnuthTAOCP2002;

});

var lecuyerCmrg = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.LecuyerCMRG = void 0;



const SEED_LEN = 6;
const a12 = 1403580;
const a13n = 810728;
const m2 = 4294944443;
const m1 = 4294967087;
const normc = 2.328306549295727688e-10;
const a21 = 527612;
const a23n = 1370589;
class LecuyerCMRG extends irng.IRNG {
    constructor(_seed = timeseed_1.timeseed()) {
        super(_seed);
    }
    _setup() {
        this._kind = irngType.IRNGType.LECUYER_CMRG;
        this._name = "L'Ecuyer-CMRG";
        this.m_seed = new Int32Array(SEED_LEN).fill(0);
    }
    init(se = timeseed_1.timeseed()) {
        const s = new Int32Array([0]);
        s[0] = se;
        for (let j = 0; j < 50; j++) {
            s[0] = 69069 * s[0] + 1;
        }
        for (let j = 0; j < this.m_seed.length; j++) {
            s[0] = 69069 * s[0] + 1;
            while (s[0] >= m2) {
                s[0] = 69069 * s[0] + 1;
            }
            this.m_seed[j] = s[0];
        }
        super.init(se);
    }
    internal_unif_rand() {
        const II = this.m_seed;
        let k;
        let p1;
        let p2;
        p1 = a12 * new Uint32Array([II[1]])[0] - a13n * new Uint32Array([II[0]])[0];
        k = new Int32Array([p1 / m1])[0];
        p1 -= k * m1;
        if (p1 < 0.0)
            p1 += m1;
        II[0] = II[1];
        II[1] = II[2];
        II[2] = new Int32Array([p1])[0];
        p2 = a21 * new Uint32Array([II[5]])[0] - a23n * new Uint32Array([II[3]])[0];
        k = new Int32Array([p2 / m2])[0];
        p2 -= k * m2;
        if (p2 < 0.0)
            p2 += m2;
        II[3] = II[4];
        II[4] = II[5];
        II[5] = new Int32Array([p2])[0];
        return (p1 > p2 ? p1 - p2 : p1 - p2 + m1) * normc;
    }
    set seed(_seed) {
        if (_seed.length > this.m_seed.length || _seed.length === 0) {
            this.init(timeseed_1.timeseed());
            return;
        }
        this.m_seed.set(_seed);
    }
    get seed() {
        return Array.from(this.m_seed);
    }
}
exports.LecuyerCMRG = LecuyerCMRG;

});

var marsagliaMulticarry = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarsagliaMultiCarry = void 0;




const SEED_LEN = 2;
class MarsagliaMultiCarry extends irng.IRNG {
    constructor(_seed = timeseed_1.timeseed()) {
        super(_seed);
    }
    fixupSeeds() {
        const s = this.m_seed;
        if (s[0] === 0)
            s[0] = 1;
        if (s[1] === 0)
            s[1] = 1;
        return;
    }
    init(_seed = timeseed_1.timeseed()) {
        const s = new Int32Array([_seed]);
        for (let j = 0; j < 50; j++) {
            s[0] = 69069 * s[0] + 1;
        }
        for (let j = 0; j < this.m_seed.length; j++) {
            s[0] = 69069 * s[0] + 1;
            this.m_seed[j] = s[0];
        }
        this.fixupSeeds();
        super.init(_seed);
    }
    _setup() {
        this._kind = irngType.IRNGType.MARSAGLIA_MULTICARRY;
        this._name = 'Marsaglia-MultiCarry';
        this.m_seed = new Int32Array(new ArrayBuffer(SEED_LEN * 4)).fill(0);
    }
    internal_unif_rand() {
        const s = this.m_seed;
        s[0] = 36969 * (s[0] & 65535) + (s[0] >>> 16);
        s[1] = 18000 * (s[1] & 65535) + (s[1] >>> 16);
        const un = new Uint32Array(SEED_LEN);
        un[0] = s[0] << 16;
        un[1] = s[1] & 0xffff;
        un[0] = un[0] ^ un[1];
        return fixup_1.fixup(un[0] * fixup_1.i2_32m1);
    }
    set seed(_seed) {
        if (_seed.length > this.m_seed.length || _seed.length === 0) {
            this.init(timeseed_1.timeseed());
            return;
        }
        this.m_seed.set(_seed);
    }
    get seed() {
        return Array.from(this.m_seed);
    }
}
exports.MarsagliaMultiCarry = MarsagliaMultiCarry;

});

var superDuper = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuperDuper = void 0;




const SEED_LEN = 2;
const buf = new ArrayBuffer(SEED_LEN * 4);
class SuperDuper extends irng.IRNG {
    constructor(_seed = timeseed_1.timeseed()) {
        super(_seed);
    }
    _setup() {
        this._kind = irngType.IRNGType.SUPER_DUPER;
        this._name = 'Super-Duper';
        this.m_seed = new Int32Array(buf).fill(0);
    }
    internal_unif_rand() {
        const s = this.m_seed;
        s[0] ^= (s[0] >>> 15) & 0x1ffff;
        s[0] ^= s[0] << 17;
        s[1] *= 69069;
        const un = new Uint32Array(SEED_LEN);
        un[0] = s[0];
        un[1] = s[1];
        un[0] = un[0] ^ un[1];
        return fixup_1.fixup(un[0] * fixup_1.i2_32m1);
    }
    fixupSeeds() {
        const s = this.m_seed;
        if (s[0] === 0)
            s[0] = 1;
        s[1] |= 1;
        return;
    }
    init(_seed = timeseed_1.timeseed()) {
        const s = new Uint32Array([_seed]);
        for (let j = 0; j < 50; j++) {
            s[0] = 69069 * s[0] + 1;
        }
        for (let j = 0; j < this.m_seed.length; j++) {
            s[0] = 69069 * s[0] + 1;
            this.m_seed[j] = s[0];
        }
        this.fixupSeeds();
        super.init(_seed);
    }
    set seed(_seed) {
        if (_seed.length > this.m_seed.length || _seed.length === 0) {
            this.init(timeseed_1.timeseed());
            return;
        }
        this.m_seed.set(_seed);
    }
    get seed() {
        return Array.from(this.m_seed);
    }
}
exports.SuperDuper = SuperDuper;

});

var wichmannHill = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.WichmannHill = void 0;
const { trunc } = Math;
const frac = (x) => x - trunc(x);




const SEED_LEN = 3;
class WichmannHill extends irng.IRNG {
    constructor(_seed = timeseed_1.timeseed()) {
        super(_seed);
    }
    _setup() {
        this._kind = irngType.IRNGType.WICHMANN_HILL;
        this._name = 'Wichmann-Hill';
        const buf = new ArrayBuffer(SEED_LEN * 4);
        this.m_seed = new Uint32Array(buf).fill(0);
    }
    internal_unif_rand() {
        const s = this.m_seed;
        s[0] = (s[0] * 171) % 30269;
        s[1] = (s[1] * 172) % 30307;
        s[2] = (s[2] * 170) % 30323;
        let value = s[0] / 30269.0 + s[1] / 30307.0 + s[2] / 30323.0;
        return fixup_1.fixup(frac(value));
    }
    fixupSeeds() {
        const s = this.m_seed;
        s[0] = s[0] % 30269;
        s[1] = s[1] % 30307;
        s[2] = s[2] % 30323;
        if (s[0] === 0)
            s[0] = 1;
        if (s[1] === 0)
            s[1] = 1;
        if (s[2] === 0)
            s[2] = 1;
        return;
    }
    init(seed = timeseed_1.timeseed()) {
        const s = new Uint32Array([seed]);
        for (let j = 0; j < 50; j++) {
            s[0] = 69069 * s[0] + 1;
        }
        for (let j = 0; j < this.m_seed.length; j++) {
            s[0] = 69069 * s[0] + 1;
            this.m_seed[j] = s[0];
        }
        this.fixupSeeds();
        super.init(seed);
    }
    set seed(_seed) {
        if (_seed.length > this.m_seed.length || _seed.length === 0) {
            this.init(timeseed_1.timeseed());
            return;
        }
        this.m_seed.set(_seed);
    }
    get seed() {
        return Array.from(this.m_seed);
    }
}
exports.WichmannHill = WichmannHill;

});

var rng = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.IRNGNormal = exports.IRNG = exports.rng = void 0;

Object.defineProperty(exports, "IRNG", { enumerable: true, get: function () { return irng.IRNG; } });







Object.defineProperty(exports, "IRNGNormal", { enumerable: true, get: function () { return inormalRng.IRNGNormal; } });



exports.rng = {
    KnuthTAOCP: knuthTaocp.KnuthTAOCP,
    KnuthTAOCP2002: knuthTaocp2002.KnuthTAOCP2002,
    LecuyerCMRG: lecuyerCmrg.LecuyerCMRG,
    MarsagliaMultiCarry: marsagliaMulticarry.MarsagliaMultiCarry,
    MersenneTwister: mersenneTwister.MersenneTwister,
    normal: {
        AhrensDieter: normal$1.AhrensDieter,
        BoxMuller: normal$1.BoxMuller,
        BuggyKindermanRamage: normal$1.BuggyKindermanRamage,
        Inversion: normal$1.Inversion,
        KindermanRamage: normal$1.KindermanRamage
    },
    SuperDuper: superDuper.SuperDuper,
    timeseed: timeseed_1.timeseed,
    WichmannHill: wichmannHill.WichmannHill,
};

});

var exp = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Exponential = void 0;





const { MersenneTwister } = rng.rng;
function Exponential(rng = new MersenneTwister(0)) {
    return {
        dexp: (x, rate = 1, asLog = false) => dexp_1.dexp(x, 1 / rate, asLog),
        pexp: (q, rate = 1, lowerTail = true, logP = false) => pexp_1.pexp(q, 1 / rate, lowerTail, logP),
        qexp: (p, rate = 1, lowerTail = true, logP = false) => qexp_1.qexp(p, 1 / rate, lowerTail, logP),
        rexp: (n, rate = 1) => rexp_1.rexp(n, 1 / rate, rng)
    };
}
exports.Exponential = Exponential;

});

var df_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.df = void 0;




const { log } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer_df = src('df');
function df(xx, m, n, giveLog = false) {
    const fx = Array.isArray(xx) ? xx : [xx];
    const result = fx.map(x => {
        let p;
        let q;
        let f;
        let dens;
        if (ISNAN(x) || ISNAN(m) || ISNAN(n)) {
            return x + m + n;
        }
        if (m <= 0 || n <= 0) {
            return _general.ML_ERR_return_NAN(printer_df);
        }
        if (x < 0) {
            return _general.R_D__0(giveLog);
        }
        if (x === 0) {
            return m > 2 ? _general.R_D__0(giveLog) : m === 2 ? _general.R_D__1(giveLog) : ML_POSINF;
        }
        if (!R_FINITE(m) && !R_FINITE(n)) {
            if (x === 1) {
                return ML_POSINF;
            }
            else {
                return _general.R_D__0(giveLog);
            }
        }
        if (!R_FINITE(n)) {
            return dgamma_1.dgamma(x, m / 2, 2 / m, giveLog);
        }
        if (m > 1e14) {
            dens = dgamma_1.dgamma(1 / x, n / 2, 2 / n, giveLog);
            return giveLog ? dens - 2 * log(x) : dens / (x * x);
        }
        f = 1 / (n + x * m);
        q = n * f;
        p = x * m * f;
        if (m >= 2) {
            f = m * q / 2;
            dens = dbinom_1.dbinom_raw((m - 2) / 2, (m + n - 2) / 2, p, q, giveLog);
        }
        else {
            f = m * m * q / (2 * p * (m + n));
            dens = dbinom_1.dbinom_raw(m / 2, (m + n) / 2, p, q, giveLog);
        }
        return giveLog ? log(f) + dens : f * dens;
    });
    return result.length === 1 ? result[0] : result;
}
exports.df = df;

});

var dnf_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dnf = void 0;





const { log1p, log } = Math;
const { isFinite: R_FINITE, isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer = src('dnf');
function dnf(xx, df1, df2, ncp, giveLog) {
    const fx = Array.isArray(xx) ? xx : [xx];
    const result = fx.map(x => {
        let y;
        let z;
        let f;
        if (ISNAN(x) || ISNAN(df1) || ISNAN(df2) || ISNAN(ncp)) {
            return x + df2 + df1 + ncp;
        }
        if (df1 <= 0 || df2 <= 0 || ncp < 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (x < 0) {
            return _general.R_D__0(giveLog);
        }
        if (!R_FINITE(ncp)) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (!R_FINITE(df1) && !R_FINITE(df2)) {
            if (x === 1)
                return ML_POSINF;
            else
                return _general.R_D__0(giveLog);
        }
        if (!R_FINITE(df2))
            return df1 * dnchisq_1.dnchisq(x * df1, df1, ncp, giveLog);
        if (df1 > 1e14 && ncp < 1e7) {
            f =
                1 +
                    ncp / df1;
            z = dgamma_1.dgamma(1 / x / f, df2 / 2, 2 / df2, giveLog);
            return giveLog ? z - 2 * log(x) - log(f) : z / (x * x) / f;
        }
        y = df1 / df2 * x;
        z = dnbeta_1.dnbeta(y / (1 + y), df1 / 2, df2 / 2, ncp, giveLog);
        return giveLog
            ? z + log(df1) - log(df2) - 2 * log1p(y)
            : z * (df1 / df2) / (1 + y) / (1 + y);
    });
    return result.length === 1 ? result[0] : result;
}
exports.dnf = dnf;

});

var pf_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pf = void 0;




const { isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF, NaN: ML_NAN, isFinite: ML_VALID } = Number;
const { LN2: M_LN2 } = Math;
const printer_pf = src('pf');
function pf(q, df1, df2, lowerTail = true, logP = false) {
    const fx = Array.isArray(q) ? q : [q];
    const result = fx.map(x => {
        if (ISNAN(x) || ISNAN(df1) || ISNAN(df2))
            return x + df2 + df1;
        if (df1 <= 0 || df2 <= 0) {
            return _general.ML_ERR_return_NAN(printer_pf);
        }
        let rc = _general.R_P_bounds_01(lowerTail, logP, x, 0, ML_POSINF);
        if (rc !== undefined) {
            return rc;
        }
        if (df2 === ML_POSINF) {
            if (df1 === ML_POSINF) {
                if (x < 1)
                    return _general.R_DT_0(lowerTail, logP);
                if (x === 1)
                    return logP ? -M_LN2 : 0.5;
                if (x > 1)
                    return _general.R_DT_1(lowerTail, logP);
            }
            return pchisq_1.pchisq(x * df1, df1, lowerTail, logP);
        }
        if (df1 === ML_POSINF)
            return pchisq_1.pchisq(df2 / x, df2, !lowerTail, logP);
        if (df1 * x > df2)
            x = pbeta_1.pbeta(df2 / (df2 + df1 * x), df2 / 2, df1 / 2, !lowerTail, logP);
        else
            x = pbeta_1.pbeta(df1 * x / (df2 + df1 * x), df1 / 2, df2 / 2, lowerTail, logP);
        return ML_VALID(x) ? x : ML_NAN;
    });
    return result.length === 1 ? result[0] : result;
}
exports.pf = pf;

});

var pnf_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pnf = void 0;




const { isNaN: ISNAN, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer_pnf = src('pnf');
function pnf(xx, df1, df2, ncp, lowerTail = true, logP = false) {
    const fx = Array.isArray(xx) ? xx : [xx];
    const result = fx.map(x => {
        let y;
        if (ISNAN(x) || ISNAN(df1) || ISNAN(df2) || ISNAN(ncp))
            return x + df2 + df1 + ncp;
        if (df1 <= 0 || df2 <= 0 || ncp < 0)
            return _general.ML_ERR_return_NAN(printer_pnf);
        if (!R_FINITE(ncp))
            return _general.ML_ERR_return_NAN(printer_pnf);
        if (!R_FINITE(df1) && !R_FINITE(df2))
            return _general.ML_ERR_return_NAN(printer_pnf);
        let rc = _general.R_P_bounds_01(lowerTail, logP, x, 0, ML_POSINF);
        if (rc !== undefined) {
            return rc;
        }
        if (df2 > 1e8)
            return pnchisq_1.pnchisq(x * df1, df1, ncp, lowerTail, logP);
        y = df1 / df2 * x;
        return pnbeta_1.pnbeta2(y / (1 + y), 1 / (1 + y), df1 / 2, df2 / 2, ncp, lowerTail, logP);
    });
    return result.length === 1 ? result[0] : result;
}
exports.pnf = pnf;

});

var qf_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qf = void 0;




const printer = src('qf');
const { isNaN: ISNAN, isFinite: R_FINITE, NaN: ML_NAN, POSITIVE_INFINITY: ML_POSINF, isFinite: ML_VALID } = Number;
function qf(pp, df1, df2, lower_tail, log_p) {
    const fp = Array.isArray(pp) ? pp : [pp];
    const result = fp.map(p => {
        if (ISNAN(p) || ISNAN(df1) || ISNAN(df2))
            return p + df1 + df2;
        if (df1 <= 0 || df2 <= 0)
            return _general.ML_ERR_return_NAN(printer);
        let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, 0, ML_POSINF);
        if (rc !== undefined) {
            return rc;
        }
        if (df1 <= df2 && df2 > 4e5) {
            if (!R_FINITE(df1))
                return 1;
            return qchisq_1.qchisq(p, df1, lower_tail, log_p) / df1;
        }
        if (df1 > 4e5) {
            return df2 / qchisq_1.qchisq(p, df2, !lower_tail, log_p);
        }
        p = (1 / qbeta_1.qbeta(p, df2 / 2, df1 / 2, !lower_tail, log_p) - 1) * (df2 / df1);
        return ML_VALID(p) ? p : ML_NAN;
    });
    return result.length === 1 ? result[0] : result;
}
exports.qf = qf;

});

var qnf_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qnf = void 0;




const { isNaN: ISNAN, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer = src('qnf');
function qnf(pp, df1, df2, ncp, lowerTail = true, logP = false) {
    const fp = Array.isArray(pp) ? pp : [pp];
    const result = fp.map(p => {
        let y;
        if (ISNAN(p) || ISNAN(df1) || ISNAN(df2) || ISNAN(ncp))
            return p + df1 + df2 + ncp;
        switch (true) {
            case df1 <= 0 || df2 <= 0 || ncp < 0:
            case !R_FINITE(ncp):
            case !R_FINITE(df1) && !R_FINITE(df2):
                return _general.ML_ERR_return_NAN(printer);
        }
        let rc = _general.R_Q_P01_boundaries(lowerTail, logP, p, 0, ML_POSINF);
        if (rc !== undefined) {
            return rc;
        }
        if (df2 > 1e8)
            return qnchisq_1.qnchisq(p, df1, ncp, lowerTail, logP) / df1;
        y = qnbeta_1.qnbeta(p, df1 / 2, df2 / 2, ncp, lowerTail, logP);
        return y / (1 - y) * (df2 / df1);
    });
    return result.length === 1 ? result[0] : result;
}
exports.qnf = qnf;

});

var rf_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rf = void 0;




const printer = src('rf');
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const sequence = rFunc.seq()();
function rf(n, n1, n2, rng) {
    return rFunc.map(sequence(n))(() => {
        let v1;
        let v2;
        if (ISNAN(n1) || ISNAN(n2) || n1 <= 0 || n2 <= 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        v1 = R_FINITE(n1) ? rchisq_1.rchisq(1, n1, rng) / n1 : 1;
        v2 = R_FINITE(n2) ? rchisq_1.rchisq(1, n2, rng) / n2 : 1;
        return v1 / v2;
    });
}
exports.rf = rf;

});

var fDistro = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.FDist = void 0;



const r_func_2 = rFunc;








const sequence = rFunc.seq()();
function FDist(rng = new normal$1.Inversion()) {
    function df(x, df1, df2, ncp, log = false) {
        if (ncp === undefined) {
            return df_1.df(x, df1, df2, log);
        }
        return dnf_1.dnf(x, df1, df2, ncp, log);
    }
    function pf(q, df1, df2, ncp, lowerTail = true, logP = false) {
        if (ncp === undefined) {
            return pf_1.pf(q, df1, df2, lowerTail, logP);
        }
        return pnf_1.pnf(q, df1, df2, ncp, lowerTail, logP);
    }
    function qf(p, df1, df2, ncp, lowerTail = true, logP = false) {
        if (ncp === undefined) {
            return qf_1.qf(p, df1, df2, lowerTail, logP);
        }
        return qnf_1.qnf(p, df1, df2, ncp, lowerTail, logP);
    }
    function rf(n, df1, df2, ncp) {
        if (ncp === undefined) {
            return rf_1.rf(n, df1, df2, rng);
        }
        if (Number.isNaN(ncp)) {
            return r_func_2.possibleScalar(sequence(n).fill(NaN));
        }
        const div = r_func_2.arrayrify((a, b) => a / b);
        const numerator = div(rnchisq_1.rnchisq(n, df1, ncp, rng), df1);
        const denominator = div(rchisq_1.rchisq(n, df2, rng), df2);
        return r_func_2.multiplexer(numerator, denominator)((x1, d) => x1 / d);
    }
    return {
        df,
        pf,
        qf,
        rf
    };
}
exports.FDist = FDist;

});

var polygamma = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pentagamma = exports.tetragamma = exports.trigamma = exports.digamma = exports.psigamma = void 0;




const printer = src('dpsifn');
const { NaN: ML_NAN, POSITIVE_INFINITY: ML_POSINF, isNaN: ISNAN, EPSILON: DBL_EPSILON } = Number;
const n_max = 100;
const { pow, abs: fabs, max: fmax2, min: fmin2, exp, log, sin, cos, PI: M_PI, round, round: R_forceint } = Math;
function dpsifn(x, n, kode, m, ans, nz, ierr) {
    const bvalues = [
        1.0,
        -5.0e-1,
        1.66666666666666667e-1,
        -3.33333333333333333e-2,
        2.38095238095238095e-2,
        -3.33333333333333333e-2,
        7.57575757575757576e-2,
        -2.53113553113553114e-1,
        1.16666666666666667,
        -7.09215686274509804,
        5.49711779448621554e1,
        -5.29124242424242424e2,
        6.1921231884057971e3,
        -8.65802531135531136e4,
        1.42551716666666667e6,
        -2.7298231067816092e7,
        6.01580873900642368e8,
        -1.51163157670921569e10,
        4.29614643061166667e11,
        -1.37116552050883328e13,
        4.88332318973593167e14,
        -1.92965793419400681e16
    ];
    let nx;
    let xinc = 0;
    let xdmln = 0;
    let i;
    let j;
    let k;
    let mm;
    let mx;
    let nn;
    let np;
    let fn;
    let arg;
    let den;
    let elim;
    let eps;
    let fln;
    let fx;
    let rln;
    let rxsq;
    let r1m4;
    let r1m5;
    let s;
    let slope;
    let t;
    let ta;
    let tk;
    let tol;
    let tols;
    let tss;
    let tst;
    let tt;
    let t1;
    let t2;
    let wdtol;
    let xdmy = 0;
    let xln = 0.0;
    let xm;
    let xmin;
    let xq;
    let yint;
    let trm = new Array(23).fill(0);
    let trmr = new Array(n_max + 1).fill(0);
    ierr.val = 0;
    if (n < 0 || kode < 1 || kode > 2 || m < 1) {
        ierr.val = 1;
        return;
    }
    if (x <= 0) {
        if (x === round(x)) {
            for (j = 0; j < m; j++)
                ans[j] = (j + n) % 2 ? ML_POSINF : ML_NAN;
            return;
        }
        dpsifn(1 - x, n, 1, m, ans, nz, ierr);
        if (m > 1 || n > 3) {
            ierr.val = 4;
            return;
        }
        x *= M_PI;
        if (n === 0)
            tt = cos(x) / sin(x);
        else if (n === 1)
            tt = -1 / _general.R_pow_di(sin(x), 2);
        else if (n === 2)
            tt = 2 * cos(x) / _general.R_pow_di(sin(x), 3);
        else if (n === 3)
            tt =
                -2 *
                    (2 * _general.R_pow_di(cos(x), 2) + 1) /
                    _general.R_pow_di(sin(x), 4);
        else
            tt = ML_NAN;
        s = n % 2 ? -1 : 1;
        t1 = t2 = s = 1;
        for (k = 0, j = k - n; j < m; k++, j++, s = -s) {
            t1 *= M_PI;
            if (k >= 2)
                t2 *= k;
            if (j >= 0)
                ans[j] = s * (ans[j] + t1 / t2 * tt);
        }
        if (n === 0 && kode === 2)
            ans[0] += xln;
        return;
    }
    nz.val = 0;
    xln = log(x);
    if (kode === 1 && m === 1) {
        let lrg = 1 / (2 * DBL_EPSILON);
        if (n === 0 && x * xln > lrg) {
            ans[0] = -xln;
            return;
        }
        else if (n >= 1 && x > n * lrg) {
            ans[0] = exp(-n * xln) / n;
            return;
        }
    }
    mm = m;
    nx = _general.imin2(-_general.DBL_MIN_EXP, _general.DBL_MAX_EXP);
    r1m5 = _general.M_LOG10_2;
    r1m4 = Number.EPSILON * 0.5;
    wdtol = fmax2(r1m4, 0.5e-18);
    elim = 2.302 * (nx * r1m5 - 3.0);
    let L10 = false;
    let L20 = false;
    let L30 = false;
    while (true) {
        nn = n + mm - 1;
        fn = nn;
        t = (fn + 1) * xln;
        if (fabs(t) > elim) {
            if (t <= 0.0) {
                nz.val = 0;
                ierr.val = 2;
                return;
            }
        }
        else {
            if (x < wdtol) {
                ans[0] = _general.R_pow_di(x, -n - 1);
                if (mm !== 1) {
                    for (k = 1; k < mm; k++)
                        ans[k] = ans[k - 1] / x;
                }
                if (n === 0 && kode === 2)
                    ans[0] += xln;
                return;
            }
            rln = r1m5 * _general.DBL_MANT_DIG;
            rln = fmin2(rln, 18.06);
            fln = fmax2(rln, 3.0) - 3.0;
            yint = 3.5 + 0.4 * fln;
            slope = 0.21 + fln * (0.0006038 * fln + 0.008677);
            xm = yint + slope * fn;
            mx = (xm >> 0) + 1;
            xmin = mx;
            if (n !== 0) {
                xm = -2.302 * rln - fmin2(0.0, xln);
                arg = xm / n;
                arg = fmin2(0.0, arg);
                eps = exp(arg);
                xm = 1.0 - eps;
                if (fabs(arg) < 1.0e-3)
                    xm = -arg;
                fln = x * xm / eps;
                xm = xmin - x;
                if (xm > 7.0 && fln < 15.0)
                    break;
            }
            xdmy = x;
            xdmln = xln;
            xinc = 0.0;
            if (x < xmin) {
                nx = x >> 0;
                xinc = xmin - nx;
                xdmy = x + xinc;
                xdmln = log(xdmy);
            }
            t = fn * xdmln;
            t1 = xdmln + xdmln;
            t2 = t + xdmln;
            tk = fmax2(fabs(t), fmax2(fabs(t1), fabs(t2)));
            if (tk <= elim) {
                L10 = true;
                break;
            }
        }
        nz.val++;
        mm--;
        ans[mm] = 0;
        if (mm === 0) {
            return;
        }
    }
    if (!L10) {
        nn = (fln >> 0) + 1;
        np = n + 1;
        t1 = (n + 1) * xln;
        t = exp(-t1);
        s = t;
        den = x;
        for (i = 1; i <= nn; i++) {
            den += 1;
            trm[i] = pow(den, -np);
            s += trm[i];
        }
        ans[0] = s;
        if (n === 0 && kode === 2)
            ans[0] = s + xln;
        if (mm !== 1) {
            tol = wdtol / 5.0;
            for (j = 1; j < mm; j++) {
                t /= x;
                s = t;
                tols = t * tol;
                den = x;
                for (i = 1; i <= nn; i++) {
                    den += 1;
                    trm[i] /= den;
                    s += trm[i];
                    if (trm[i] < tols)
                        break;
                }
                ans[j] = s;
            }
        }
        return;
    }
    tss = exp(-t);
    tt = 0.5 / xdmy;
    t1 = tt;
    tst = wdtol * tt;
    if (nn !== 0)
        t1 = tt + 1.0 / fn;
    rxsq = 1.0 / (xdmy * xdmy);
    ta = 0.5 * rxsq;
    t = (fn + 1) * ta;
    s = t * bvalues[2];
    if (fabs(s) >= tst) {
        tk = 2.0;
        for (k = 4; k <= 22; k++) {
            t = t * ((tk + fn + 1) / (tk + 1.0)) * ((tk + fn) / (tk + 2.0)) * rxsq;
            trm[k] = t * bvalues[k - 1];
            if (fabs(trm[k]) < tst)
                break;
            s += trm[k];
            tk += 2;
        }
    }
    s = (s + t1) * tss;
    while (true) {
        if (xinc !== 0.0) {
            nx = xinc >> 0;
            np = nn + 1;
            if (nx > n_max) {
                nz.val = 0;
                ierr.val = 3;
                return;
            }
            else {
                if (nn === 0) {
                    L20 = true;
                    break;
                }
                xm = xinc - 1.0;
                fx = x + xm;
                for (i = 1; i <= nx; i++) {
                    trmr[i] = pow(fx, -np);
                    s += trmr[i];
                    xm -= 1;
                    fx = x + xm;
                }
            }
        }
        ans[mm - 1] = s;
        if (fn === 0) {
            L30 = true;
            break;
        }
        for (j = 2; j <= mm; j++) {
            fn--;
            tss *= xdmy;
            t1 = tt;
            if (fn !== 0)
                t1 = tt + 1.0 / fn;
            t = (fn + 1) * ta;
            s = t * bvalues[2];
            if (fabs(s) >= tst) {
                tk = 4 + fn;
                for (k = 4; k <= 22; k++) {
                    trm[k] = trm[k] * (fn + 1) / tk;
                    if (fabs(trm[k]) < tst)
                        break;
                    s += trm[k];
                    tk += 2;
                }
            }
            s = (s + t1) * tss;
            if (xinc !== 0.0) {
                if (fn === 0) {
                    L20 = true;
                    break;
                }
                xm = xinc - 1.0;
                fx = x + xm;
                for (i = 1; i <= nx; i++) {
                    trmr[i] = trmr[i] * fx;
                    s += trmr[i];
                    xm -= 1;
                    fx = x + xm;
                }
            }
            ans[mm - j] = s;
            if (fn === 0) {
                L30 = true;
                break;
            }
        }
        return;
    }
    printer(L20 ? 'goto L20 was set!' : 'goto L20 was not set');
    if (!L30) {
        for (i = 1; i <= nx; i++) {
            s += 1 / (x + (nx - i));
        }
    }
    if (kode !== 2)
        ans[0] = s - xdmln;
    else if (xdmy !== x) {
        xq = xdmy / x;
        ans[0] = s - log(xq);
    }
    return;
}
const print_psigamma = src('psigamma');
function psigamma(_x, _deriv = 0) {
    let ans = [0];
    let nz = new toms708.NumberW();
    let ierr = new toms708.NumberW();
    return rFunc.multiplexer(_x, _deriv)((x, deriv) => {
        let k;
        let n;
        nz.val = 0;
        ierr.val = 0;
        ans[0] = 0;
        if (ISNAN(x))
            return x;
        deriv = R_forceint(deriv);
        n = deriv >> 0;
        if (n > n_max) {
            print_psigamma('"deriv = %d > %d (= n_max)', n, n_max);
            return ML_NAN;
        }
        dpsifn(x, n, 1, 1, ans, nz, ierr);
        if (ierr.val !== 0) {
            return ML_NAN;
        }
        ans[0] = -ans[0];
        for (k = 1; k <= n; k++)
            ans[0] *= -k;
        return ans[0];
    });
}
exports.psigamma = psigamma;
function digamma(_x) {
    let ans = [0];
    let nz = new toms708.NumberW();
    let ierr = new toms708.NumberW();
    return rFunc.map(_x)(x => {
        ans[0] = 0;
        nz.val = 0;
        ierr.val = 0;
        if (ISNAN(x))
            return x;
        dpsifn(x, 0, 1, 1, ans, nz, ierr);
        if (ierr.val !== 0) {
            return ML_NAN;
        }
        return -ans[0];
    });
}
exports.digamma = digamma;
function trigamma(_x) {
    let ans = [0];
    let nz = new toms708.NumberW(0);
    let ierr = new toms708.NumberW(0);
    return rFunc.map(_x)(x => {
        ans[0] = 0;
        nz.val = 0;
        ierr.val = 0;
        if (ISNAN(x))
            return x;
        dpsifn(x, 1, 1, 1, ans, nz, ierr);
        if (ierr.val !== 0) {
            return ML_NAN;
        }
        return ans[0];
    });
}
exports.trigamma = trigamma;
function tetragamma(_x) {
    let ans = [0];
    let nz = new toms708.NumberW();
    let ierr = new toms708.NumberW();
    return rFunc.map(_x)(x => {
        ans[0] = 0;
        nz.val = 0;
        ierr.val = 0;
        if (ISNAN(x))
            return x;
        dpsifn(x, 2, 1, 1, ans, nz, ierr);
        if (ierr.val !== 0) {
            return ML_NAN;
        }
        return -2.0 * ans[0];
    });
}
exports.tetragamma = tetragamma;
function pentagamma(_x) {
    let ans = [0];
    let nz = new toms708.NumberW();
    let ierr = new toms708.NumberW();
    return rFunc.map(_x)(x => {
        ans[0] = 0;
        nz.val = 0;
        ierr.val = 0;
        if (ISNAN(x))
            return x;
        dpsifn(x, 3, 1, 1, ans, nz, ierr);
        if (ierr.val !== 0) {
            return ML_NAN;
        }
        return 6.0 * ans[0];
    });
}
exports.pentagamma = pentagamma;

});

var gamma = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Gamma = exports.special = void 0;










exports.special = {
    digamma: polygamma.digamma,
    gamma: gamma_fn_1.gammafn,
    lgamma: lgamma_fn.lgammafn,
    pentagamma: polygamma.pentagamma,
    psigamma: polygamma.psigamma,
    tetragamma: polygamma.tetragamma,
    trigamma: polygamma.trigamma
};
const { abs } = Math;
function Gamma(norm = new normal$1.Inversion()) {
    const printer_n = src('gamma_normalize_params');
    function gammaNormalizeParams(rate, scale) {
        if (scale === undefined && rate === undefined) {
            return 1;
        }
        if (scale !== undefined && rate !== undefined) {
            if (abs(scale * rate - 1) >= 1e-16) {
                printer_n('Both scale:%d and rate:%d are defined but scale <> 1/rate');
                return undefined;
            }
            return scale;
        }
        if (scale !== undefined && rate === undefined) {
            return scale;
        }
        if (scale === undefined && rate !== undefined) {
            return 1 / rate;
        }
        throw new Error('unreachable code, you cant be here!');
    }
    const printer_d = src('dgamma');
    function dgamma(x, shape, rate, scale, asLog = false) {
        let _scale = gammaNormalizeParams(rate, scale);
        if (_scale !== undefined) {
            return dgamma_1.dgamma(x, shape, _scale, asLog);
        }
        printer_d('Cannot normalize to [scale]');
        return rFunc.multiplexer(x)(() => NaN);
    }
    const printer_p = src('pgamma');
    function pgamma(q, shape, rate, scale, lowerTail = true, logP = false) {
        let _scale = gammaNormalizeParams(rate, scale);
        if (_scale !== undefined) {
            return pgamma_1.pgamma(q, shape, _scale, lowerTail, logP);
        }
        printer_p('Cannot normalize to [scale]');
        return rFunc.multiplexer(q)(() => NaN);
    }
    const printer_q = src('qgamma');
    function qgamma(q, shape, rate, scale, lowerTail = true, logP = false) {
        let _scale = gammaNormalizeParams(rate, scale);
        if (_scale !== undefined) {
            return qgamma_1.qgamma(q, shape, _scale, lowerTail, logP);
        }
        printer_q('Cannot normalize to [scale]');
        return rFunc.multiplexer(q)(() => NaN);
    }
    const printer_r = src('rgamma');
    function rgamma(n, shape, rate, scale) {
        let _scale = gammaNormalizeParams(rate, scale);
        if (_scale !== undefined) {
            return rgamma_1.rgamma(n, shape, _scale, norm);
        }
        printer_r('Cannot normalize to [scale]');
    }
    return Object.freeze({
        dgamma,
        pgamma,
        qgamma,
        rgamma
    });
}
exports.Gamma = Gamma;

});

var dgeom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dgeom = void 0;



const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const { round: R_forceint, log } = Math;
const printer = src('dgeom');
function dgeom(xx, p, giveLog = false) {
    const fx = Array.isArray(xx) ? xx : [xx];
    const result = fx.map(x => {
        let prob;
        if (ISNAN(x) || ISNAN(p))
            return x + p;
        if (p <= 0 || p > 1) {
            return _general.ML_ERR_return_NAN(printer);
        }
        let rc = _general.R_D_nonint_check(giveLog, x, printer);
        if (rc !== undefined) {
            return rc;
        }
        if (x < 0 || !R_FINITE(x) || p === 0) {
            return _general.R_D__0(giveLog);
        }
        x = R_forceint(x);
        prob = dbinom_1.dbinom_raw(0, x, p, 1 - p, giveLog);
        return giveLog ? log(p) + prob : p * prob;
    });
    return result.length === 1 ? result[0] : result;
}
exports.dgeom = dgeom;

});

var pgeom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pgeom = void 0;



const { expm1, log1p, log, exp, floor } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer = src('pgeom');
function pgeom(xx, p, lowerTail = true, logP = false) {
    const fx = Array.isArray(xx) ? xx : [xx];
    const result = fx.map(x => {
        if (ISNAN(x) || ISNAN(p))
            return x + p;
        if (p <= 0 || p > 1) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (x < 0)
            return _general.R_DT_0(lowerTail, logP);
        if (!R_FINITE(x))
            return _general.R_DT_1(lowerTail, logP);
        x = floor(x + 1e-7);
        if (p === 1) {
            x = lowerTail ? 1 : 0;
            return logP ? log(x) : x;
        }
        x = log1p(-p) * (x + 1);
        if (logP)
            return expm1_1.R_DT_Clog(lowerTail, logP, x);
        else
            return lowerTail ? -expm1(x) : exp(x);
    });
    return result.length === 1 ? result[0] : result;
}
exports.pgeom = pgeom;

});

var qgeom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qgeom = void 0;



const { ceil, max: fmax2, log1p } = Math;
const { POSITIVE_INFINITY: ML_POSINF, isNaN: ISNAN } = Number;
const printer = src('qgeom');
function qgeom(pp, prob, lower_tail = true, log_p = false) {
    const fp = Array.isArray(pp) ? pp : [pp];
    const result = fp.map(p => {
        if (prob <= 0 || prob > 1) {
            return _general.ML_ERR_return_NAN(printer);
        }
        let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, 0, ML_POSINF);
        if (rc !== undefined) {
            return rc;
        }
        if (ISNAN(p) || ISNAN(prob))
            return p + prob;
        if (prob === 1)
            return 0;
        return fmax2(0, ceil(expm1_1.R_DT_Clog(lower_tail, log_p, p) / log1p(-prob) - 1 - 1e-12));
    });
    return result.length === 1 ? result[0] : result;
}
exports.qgeom = qgeom;

});

var rgeom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rgeom = void 0;




const { isFinite: R_FINITE } = Number;
const printer = src('rgeom');
function rgeom(N, p, rng) {
    const result = new Array(N).fill(0).map(() => {
        if (!R_FINITE(p) || p <= 0 || p > 1)
            return _general.ML_ERR_return_NAN(printer);
        return rpois_1.rpois(1, sexp.exp_rand(rng.unif_rand) * ((1 - p) / p), rng);
    });
    return result.length === 1 ? result[0] : result;
}
exports.rgeom = rgeom;

});

var geometric = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Geometric = void 0;





function Geometric(rng = new normal$1.Inversion()) {
    return {
        dgeom: dgeom_1.dgeom,
        pgeom: pgeom_1.pgeom,
        qgeom: qgeom_1.qgeom,
        rgeom: (N, prob) => rgeom_1.rgeom(N, prob, rng)
    };
}
exports.Geometric = Geometric;

});

var dhyper_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dhyper = void 0;




const printer = src('dhyper');
const { round: R_forceint } = Math;
const { isNaN: ISNAN } = Number;
function dhyper(xx, r, b, n, give_log = false) {
    return rFunc.map(xx)(x => {
        let p;
        let q;
        let p1;
        let p2;
        let p3;
        if (ISNAN(x) || ISNAN(r) || ISNAN(b) || ISNAN(n))
            return x + r + b + n;
        if (_general.R_D_negInonint(r) ||
            _general.R_D_negInonint(b) ||
            _general.R_D_negInonint(n) ||
            n > r + b)
            return _general.ML_ERR_return_NAN(printer);
        if (x < 0)
            return _general.R_D__0(give_log);
        let rc = _general.R_D_nonint_check(give_log, x, printer);
        if (rc !== undefined) {
            return rc;
        }
        x = R_forceint(x);
        r = R_forceint(r);
        b = R_forceint(b);
        n = R_forceint(n);
        if (n < x || r < x || n - x > b)
            return _general.R_D__0(give_log);
        if (n === 0)
            return x === 0 ? _general.R_D__1(give_log) : _general.R_D__0(give_log);
        p = n / (r + b);
        q = (r + b - n) / (r + b);
        p1 = dbinom_1.dbinom_raw(x, r, p, q, give_log);
        p2 = dbinom_1.dbinom_raw(n - x, b, p, q, give_log);
        p3 = dbinom_1.dbinom_raw(n, r + b, p, q, give_log);
        return give_log ? p1 + p2 - p3 : p1 * p2 / p3;
    });
}
exports.dhyper = dhyper;

});

var phyper_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.phyper = void 0;





const { floor, round: R_forceint, log1p } = Math;
const { EPSILON: DBL_EPSILON, isNaN: ISNAN, isFinite: R_FINITE } = Number;
function pdhyper(x, NR, NB, n, log_p) {
    let sum = 0;
    let term = 1;
    while (x > 0 && term >= DBL_EPSILON * sum) {
        term *= x * (NB - n + x) / (n + 1 - x) / (NR + 1 - x);
        sum += term;
        x--;
    }
    let ss = sum;
    return log_p ? log1p(ss) : 1 + ss;
}
const printer_phyper = src('phyper');
function phyper(xx, nr, nb, nn, lowerTail = true, logP = false) {
    return rFunc.map(xx)(x => {
        let d;
        let pd;
        let lower_tail = lowerTail;
        let log_p = logP;
        let NR = nr;
        let NB = nb;
        let n = nn;
        if (ISNAN(x) || ISNAN(NR) || ISNAN(NB) || ISNAN(n))
            return x + NR + NB + n;
        x = floor(x + 1e-7);
        NR = R_forceint(NR);
        NB = R_forceint(NB);
        n = R_forceint(n);
        if (NR < 0 || NB < 0 || !R_FINITE(NR + NB) || n < 0 || n > NR + NB) {
            return _general.ML_ERR_return_NAN(printer_phyper);
        }
        if (x * (NR + NB) > n * NR) {
            let oldNB = NB;
            NB = NR;
            NR = oldNB;
            x = n - x - 1;
            lower_tail = !lower_tail;
        }
        if (x < 0)
            return _general.R_DT_0(lower_tail, log_p);
        if (x >= NR || x >= n)
            return _general.R_DT_1(lower_tail, log_p);
        d = dhyper_1.dhyper(x, NR, NB, n, log_p);
        pd = pdhyper(x, NR, NB, n, log_p);
        return log_p
            ? expm1_1.R_DT_log(lower_tail, log_p, d + pd)
            : _general.R_D_Lval(lower_tail, d * pd);
    });
}
exports.phyper = phyper;

});

var lfastchoose_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.lfastchoose = void 0;

const { log } = Math;
function lfastchoose(n, k) {
    return -log(n + 1) - lbeta_1.internal_lbeta(n - k + 1, k + 1);
}
exports.lfastchoose = lfastchoose;

});

var qhyper_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qhyper = void 0;





const { log, exp, min: fmin2, max: fmax2, round: R_forceint } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, EPSILON: DBL_EPSILON } = Number;
const printer_qhyper = src('qhyper');
function qhyper(pp, nr, nb, n, lowerTail = true, logP = false) {
    return rFunc.map(pp)(p => {
        let N;
        let xstart;
        let xend;
        let xr;
        let xb;
        let sum;
        let term;
        let small_N;
        if (ISNAN(p) || ISNAN(nr) || ISNAN(nb) || ISNAN(n))
            return NaN;
        if (!R_FINITE(nr) || !R_FINITE(nb) || !R_FINITE(n))
            return _general.ML_ERR_return_NAN(printer_qhyper);
        let NR = R_forceint(nr);
        let NB = R_forceint(nb);
        N = NR + NB;
        n = R_forceint(n);
        if (NR < 0 || NB < 0 || n < 0 || n > N)
            return _general.ML_ERR_return_NAN(printer_qhyper);
        xstart = fmax2(0, n - NB);
        xend = fmin2(n, NR);
        let rc = _general.R_Q_P01_boundaries(lowerTail, logP, p, xstart, xend);
        if (rc !== undefined) {
            return rc;
        }
        xr = xstart;
        xb = n - xr;
        small_N = N < 1000;
        term = lfastchoose_1.lfastchoose(NR, xr) + lfastchoose_1.lfastchoose(NB, xb) - lfastchoose_1.lfastchoose(N, n);
        if (small_N)
            term = exp(term);
        NR -= xr;
        NB -= xb;
        if (!lowerTail || logP) {
            p = expm1_1.R_DT_qIv(lowerTail, logP, p);
        }
        p *= 1 - 1000 * DBL_EPSILON;
        sum = small_N ? term : exp(term);
        while (sum < p && xr < xend) {
            xr++;
            NB++;
            if (small_N)
                term *= NR / xr * (xb / NB);
            else
                term += log(NR / xr * (xb / NB));
            sum += small_N ? term : exp(term);
            xb--;
            NR--;
        }
        return xr;
    });
}
exports.qhyper = qhyper;

});

var rhyper_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rhyper = exports.afc = void 0;




const { log, round: R_forceint, exp, sqrt } = Math;
const { isFinite: R_FINITE, MAX_SAFE_INTEGER: INT_MAX } = Number;
const printer_afc = src('afc');
function afc(i) {
    const al = [
        0.0,
        0.0,
        0.69314718055994530941723212145817,
        1.7917594692280550008124773583807,
        3.17805383034794561964694160129705,
        4.78749174278204599424770093452324,
        6.57925121201010099506017829290394,
        8.52516136106541430016553103634712
    ];
    if (i < 0) {
        printer_afc('rhyper.c: afc(i), i=%d < 0 -- SHOULD NOT HAPPEN!', i);
        return -1;
    }
    if (i <= 7) {
        return al[i];
    }
    let di = i;
    let i2 = di * di;
    return ((di + 0.5) * log(di) -
        di +
        _general.M_LN_SQRT_2PI +
        (0.0833333333333333 - 0.00277777777777778 / i2) / di);
}
exports.afc = afc;
function rhyper(N, nn1in, nn2in, kkin, rng) {
    const result = new Array(N).fill(0).map(() => {
        return _rhyper(nn1in, nn2in, kkin, rng);
    });
    return result.length === 1 ? result[0] : result;
}
exports.rhyper = rhyper;
const printer_rhyper = src('_rhyper');
function _rhyper(nn1in, nn2in, kkin, rng) {
    let nn1 = 0;
    let nn2 = 0;
    let kk = 0;
    let ix = 0;
    let setup1 = false;
    let setup2 = false;
    let ks = -1;
    let n1s = -1;
    let n2s = -1;
    let m = 0;
    let minjx = 0;
    let maxjx = 0;
    let k = 0;
    let n1 = 0;
    let n2 = 0;
    let tn = 0;
    let w = 0;
    let a = 0;
    let d = 0;
    let s = 0;
    let xl = 0;
    let xr = 0;
    let kl = 0;
    let kr = 0;
    let lamdl = 0;
    let lamdr = 0;
    let p1 = 0;
    let p2 = 0;
    let p3 = 0;
    if (!R_FINITE(nn1in) || !R_FINITE(nn2in) || !R_FINITE(kkin))
        return _general.ML_ERR_return_NAN(printer_rhyper);
    nn1in = R_forceint(nn1in);
    nn2in = R_forceint(nn2in);
    kkin = R_forceint(kkin);
    if (nn1in < 0 || nn2in < 0 || kkin < 0 || kkin > nn1in + nn2in)
        return _general.ML_ERR_return_NAN(printer_rhyper);
    if (nn1in >= INT_MAX || nn2in >= INT_MAX || kkin >= INT_MAX) {
        if (kkin === 1) {
            return rbinom_1.rbinom(1, kkin, nn1in / (nn1in + nn2in), rng);
        }
        return qhyper_1.qhyper(rng.unif_rand(), nn1in, nn2in, kkin, false, false);
    }
    nn1 = nn1in;
    nn2 = nn2in;
    kk = kkin;
    if (nn1 !== n1s || nn2 !== n2s) {
        setup1 = true;
        setup2 = true;
    }
    else if (kk !== ks) {
        setup1 = false;
        setup2 = true;
    }
    else {
        setup1 = false;
        setup2 = false;
    }
    if (setup1) {
        n1s = nn1;
        n2s = nn2;
        tn = nn1 + nn2;
        if (nn1 <= nn2) {
            n1 = nn1;
            n2 = nn2;
        }
        else {
            n1 = nn2;
            n2 = nn1;
        }
    }
    if (setup2) {
        ks = kk;
        if (kk + kk >= tn) {
            k = tn - kk;
        }
        else {
            k = kk;
        }
    }
    if (setup1 || setup2) {
        m = (k + 1) * (n1 + 1) / (tn + 2);
        minjx = _general.imax2(0, k - n2);
        maxjx = _general.imin2(n1, k);
        printer_rhyper('rhyper(nn1=%d, nn2=%d, kk=%d), setup: floor(mean)= m=%d, jx in (%d..%d)', nn1, nn2, kk, m, minjx, maxjx);
    }
    if (minjx === maxjx) {
        printer_rhyper('rhyper(), branch I (degenerate)');
        ix = maxjx;
    }
    else if (m - minjx < 10) {
        const scale = 1e25;
        const con = 57.5646273248511421;
        if (setup1 || setup2) {
            let lw;
            if (k < n2) {
                lw = afc(n2) + afc(n1 + n2 - k) - afc(n2 - k) - afc(n1 + n2);
            }
            else {
                lw = afc(n1) + afc(k) - afc(k - n2) - afc(n1 + n2);
            }
            w = exp(lw + con);
        }
        let p = 0;
        let u = 0;
        printer_rhyper('rhyper(), branch II; w = %d > 0', w);
        let goto_L10 = false;
        while (true) {
            p = w;
            ix = minjx;
            u = rng.unif_rand() * scale;
            printer_rhyper('  _new_ u = %d', u);
            while (u > p) {
                u -= p;
                p *= (n1 - ix) * (k - ix);
                ix++;
                p = p / ix / (n2 - k + ix);
                printer_rhyper('       ix=%d, u=%d, p=%d (u-p=%d)\n', ix, u, p, u - p);
                if (ix > maxjx) {
                    goto_L10 = true;
                    break;
                }
            }
            if (!goto_L10) {
                break;
            }
        }
    }
    else {
        if (setup1 || setup2) {
            s = sqrt((tn - k) * k * n1 * n2 / (tn - 1) / tn / tn);
            d = 1.5 * s + 0.5;
            xl = m - d + 0.5;
            xr = m + d + 0.5;
            a = afc(m) + afc(n1 - m) + afc(k - m) + afc(n2 - k + m);
            kl = exp(a - afc(xl) - afc(n1 - xl) - afc(k - xl) - afc(n2 - k + xl));
            kr = exp(a -
                afc(xr - 1) -
                afc(n1 - xr + 1) -
                afc(k - xr + 1) -
                afc(n2 - k + xr - 1));
            lamdl = -log(xl * (n2 - k + xl) / (n1 - xl + 1) / (k - xl + 1));
            lamdr = -log((n1 - xr + 1) * (k - xr + 1) / xr / (n2 - k + xr));
            p1 = d + d;
            p2 = p1 + kl / lamdl;
            p3 = p2 + kr / lamdr;
        }
        printer_rhyper('rhyper(), branch III {accept/reject}: (xl,xr)= (%d,%d); (lamdl,lamdr)= (%d,%d)\n', xl, xr, lamdl, lamdr);
        printer_rhyper('-------- p123= c(%d,%d,%d)\n', p1, p2, p3);
        let n_uv = 0;
        while (true) {
            let u = rng.unif_rand() * p3;
            let v = rng.unif_rand();
            n_uv++;
            if (n_uv >= 10000) {
                printer_rhyper('rhyper() branch III: giving up after %d rejections', n_uv);
                return _general.ML_ERR_return_NAN(printer_rhyper);
            }
            printer_rhyper(' ... L30: new (u=%d, v ~ U[0,1])[%d]\n', u, n_uv);
            if (u < p1) {
                ix = xl + u;
            }
            else if (u <= p2) {
                ix = xl + log(v) / lamdl;
                if (ix < minjx) {
                    continue;
                }
                v = v * (u - p1) * lamdl;
            }
            else {
                ix = xr - log(v) / lamdr;
                if (ix > maxjx) {
                    continue;
                }
                v = v * (u - p2) * lamdr;
            }
            let reject = true;
            if (m < 100 || ix <= 50) {
                let i;
                let f = 1.0;
                if (m < ix) {
                    for (i = m + 1; i <= ix; i++)
                        f = f * (n1 - i + 1) * (k - i + 1) / (n2 - k + i) / i;
                }
                else if (m > ix) {
                    for (i = ix + 1; i <= m; i++)
                        f = f * i * (n2 - k + i) / (n1 - i + 1) / (k - i + 1);
                }
                if (v <= f) {
                    reject = false;
                }
            }
            else {
                const deltal = 0.0078;
                const deltau = 0.0034;
                let e;
                let g;
                let r;
                let t;
                let y;
                let de;
                let dg;
                let dr;
                let ds;
                let dt;
                let gl;
                let gu;
                let nk;
                let nm;
                let ub;
                let xk;
                let xm;
                let xn;
                let y1;
                let ym;
                let yn;
                let yk;
                let alv;
                printer_rhyper(" ... accept/reject 'large' case v=%d", v);
                y = ix;
                y1 = y + 1.0;
                ym = y - m;
                yn = n1 - y + 1.0;
                yk = k - y + 1.0;
                nk = n2 - k + y1;
                r = -ym / y1;
                s = ym / yn;
                t = ym / yk;
                e = -ym / nk;
                g = yn * yk / (y1 * nk) - 1.0;
                dg = 1.0;
                if (g < 0.0)
                    dg = 1.0 + g;
                gu = g * (1.0 + g * (-0.5 + g / 3.0));
                gl = gu - 0.25 * (g * g * g * g) / dg;
                xm = m + 0.5;
                xn = n1 - m + 0.5;
                xk = k - m + 0.5;
                nm = n2 - k + xm;
                ub =
                    y * gu -
                        m * gl +
                        deltau +
                        xm * r * (1 + r * (-0.5 + r / 3.0)) +
                        xn * s * (1 + s * (-0.5 + s / 3.0)) +
                        xk * t * (1 + t * (-0.5 + t / 3.0)) +
                        nm * e * (1 + e * (-0.5 + e / 3.0));
                alv = log(v);
                if (alv > ub) {
                    reject = true;
                }
                else {
                    dr = xm * (r * r * r * r);
                    if (r < 0.0)
                        dr /= 1.0 + r;
                    ds = xn * (s * s * s * s);
                    if (s < 0.0)
                        ds /= 1.0 + s;
                    dt = xk * (t * t * t * t);
                    if (t < 0.0)
                        dt /= 1.0 + t;
                    de = nm * (e * e * e * e);
                    if (e < 0.0)
                        de /= 1.0 + e;
                    if (alv <
                        ub - 0.25 * (dr + ds + dt + de) + (y + m) * (gl - gu) - deltal) {
                        reject = false;
                    }
                    else {
                        if (alv <=
                            a - afc(ix) - afc(n1 - ix) - afc(k - ix) - afc(n2 - k + ix)) {
                            reject = false;
                        }
                        else {
                            reject = true;
                        }
                    }
                }
            }
            if (reject) {
                continue;
            }
            break;
        }
    }
    if (kk + kk >= tn) {
        if (nn1 > nn2) {
            ix = kk - nn2 + ix;
        }
        else {
            ix = nn1 - ix;
        }
    }
    else {
        if (nn1 > nn2)
            ix = kk - ix;
    }
    return ix;
}

});

var hypergeometric = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperGeometric = void 0;





function HyperGeometric(rng = new mersenneTwister.MersenneTwister()) {
    function rhyper(N, nn1in, nn2in, kkin) {
        return rhyper_1.rhyper(N, nn1in, nn2in, kkin, rng);
    }
    return {
        dhyper: dhyper_1.dhyper,
        phyper: phyper_1.phyper,
        qhyper: qhyper_1.qhyper,
        rhyper
    };
}
exports.HyperGeometric = HyperGeometric;

});

var dlogis_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dlogis = void 0;



const { log, exp, abs: fabs } = Math;
const { isNaN: ISNAN } = Number;
const printer_dlogis = src('dlogis');
function dlogis(xx, location = 0, scale = 1, give_log = false) {
    return rFunc.map(xx)(x => {
        let e;
        let f;
        if (ISNAN(x) || ISNAN(location) || ISNAN(scale))
            return NaN;
        if (scale <= 0.0) {
            return _general.ML_ERR_return_NAN(printer_dlogis);
        }
        x = fabs((x - location) / scale);
        e = exp(-x);
        f = 1.0 + e;
        return give_log ? -(x + log(scale * f * f)) : e / (scale * f * f);
    });
}
exports.dlogis = dlogis;

});

var plogis_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.plogis = exports.Rf_log1pexp = void 0;



const { exp, log1p } = Math;
const { isNaN: ISNAN } = Number;
function Rf_log1pexp(x) {
    if (x <= 18)
        return log1p(exp(x));
    if (x > 33.3)
        return x;
    return x + exp(-x);
}
exports.Rf_log1pexp = Rf_log1pexp;
const printer_plogis = src('plogis');
function plogis(xx, location = 0, scale = 1, lower_tail = true, log_p = false) {
    return rFunc.map(xx)(x => {
        if (ISNAN(x) || ISNAN(location) || ISNAN(scale))
            return x + location + scale;
        if (scale <= 0.0) {
            return _general.ML_ERR_return_NAN(printer_plogis);
        }
        x = (x - location) / scale;
        if (ISNAN(x)) {
            return _general.ML_ERR_return_NAN(printer_plogis);
        }
        let rc = _general.R_P_bounds_Inf_01(lower_tail, log_p, x);
        if (rc !== undefined) {
            return rc;
        }
        if (log_p) {
            return -Rf_log1pexp(lower_tail ? -x : x);
        }
        else {
            return 1 / (1 + exp(lower_tail ? -x : x));
        }
    });
}
exports.plogis = plogis;

});

var qlogis_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qlogis = void 0;




const { isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF, NEGATIVE_INFINITY: ML_NEGINF } = Number;
const { log } = Math;
const printer_qlogis = src('qlogis');
function qlogis(pp, location = 0, scale = 1, lower_tail = true, log_p = false) {
    return rFunc.map(pp)(p => {
        if (ISNAN(p) || ISNAN(location) || ISNAN(scale))
            return p + location + scale;
        let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, ML_NEGINF, ML_POSINF);
        if (rc !== undefined) {
            return rc;
        }
        if (scale < 0) {
            return _general.ML_ERR_return_NAN(printer_qlogis);
        }
        if (scale === 0)
            return location;
        if (log_p) {
            if (lower_tail)
                p = p - expm1_1.R_Log1_Exp(p);
            else
                p = expm1_1.R_Log1_Exp(p) - p;
        }
        else
            p = log(lower_tail ? p / (1 - p) : (1 - p) / p);
        return location + scale * p;
    });
}
exports.qlogis = qlogis;

});

var rlogis_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rlogis = void 0;



const { log } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const sequence = rFunc.seq()();
const printer_rlogis = src('rlogis');
function rlogis(N, location = 0, scale = 1, rng) {
    return rFunc.map(sequence(N))(() => {
        if (ISNAN(location) || !R_FINITE(scale)) {
            return _general.ML_ERR_return_NAN(printer_rlogis);
        }
        if (scale === 0 || !R_FINITE(location))
            return location;
        else {
            let u = rng.unif_rand();
            return location + scale * log(u / (1 - u));
        }
    });
}
exports.rlogis = rlogis;

});

var logis = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logistic = void 0;





function Logistic(rng = new mersenneTwister.MersenneTwister(0)) {
    function rlogis(N, location = 0, scale = 1) {
        return rlogis_1.rlogis(N, location, scale, rng);
    }
    return {
        dlogis: dlogis_1.dlogis,
        plogis: plogis_1.plogis,
        qlogis: qlogis_1.qlogis,
        rlogis
    };
}
exports.Logistic = Logistic;

});

var dlnorm_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dlnorm = void 0;



const { isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF } = Number;
const { log, exp } = Math;
const printer = src('dlnorm');
function dlnorm(x, meanlog, sdlog, give_log) {
    return rFunc.map(x)(fx => {
        if (ISNAN(fx) || ISNAN(meanlog) || ISNAN(sdlog)) {
            return fx + meanlog + sdlog;
        }
        if (sdlog <= 0) {
            if (sdlog < 0) {
                return _general.ML_ERR_return_NAN(printer);
            }
            return log(fx) === meanlog ? ML_POSINF : _general.R_D__0(give_log);
        }
        if (fx <= 0) {
            return _general.R_D__0(give_log);
        }
        let y = (log(fx) - meanlog) / sdlog;
        return give_log
            ? -(_general.M_LN_SQRT_2PI + 0.5 * y * y + log(fx * sdlog))
            : _general.M_1_SQRT_2PI * exp(-0.5 * y * y) / (fx * sdlog);
    });
}
exports.dlnorm = dlnorm;

});

var plnorm_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.plnorm = void 0;




const { isNaN: ISNAN } = Number;
const { log } = Math;
const printer = src('plnorm');
function plnorm(x, meanlog = 0, sdlog = 1, lower_tail = true, log_p = false) {
    return rFunc.map(x)(fx => {
        if (ISNAN(fx) || ISNAN(meanlog) || ISNAN(sdlog))
            return fx + meanlog + sdlog;
        if (sdlog < 0)
            return _general.ML_ERR_return_NAN(printer);
        if (fx > 0)
            return pnorm.pnorm5(log(fx), meanlog, sdlog, lower_tail, log_p);
        return _general.R_DT_0(lower_tail, log_p);
    });
}
exports.plnorm = plnorm;

});

var qlnorm_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qlnorm = void 0;



const { exp } = Math;
const { isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF } = Number;
function qlnorm(pp, meanlog = 0, sdlog = 1, lower_tail = true, log_p = false) {
    return rFunc.map(pp)(p => {
        if (ISNAN(p) || ISNAN(meanlog) || ISNAN(sdlog))
            return p + meanlog + sdlog;
        _general.R_Q_P01_boundaries(lower_tail, log_p, p, 0, ML_POSINF);
        return exp(qnorm_1.qnorm(p, meanlog, sdlog, lower_tail, log_p));
    });
}
exports.qlnorm = qlnorm;

});

var rnorm_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rnorm = void 0;



const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer = src('rnorm');
const seq = rFunc.seq()();
function rnorm(n = 1, mu = 0, sigma = 1, rng) {
    let result = rFunc.multiplexer(seq(n))(() => {
        if (ISNAN(mu) || !R_FINITE(sigma) || sigma < 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (sigma === 0 || !R_FINITE(mu)) {
            return mu;
        }
        return mu + sigma * rng.norm_rand();
    });
    return result.length === 1 ? result[0] : result;
}
exports.rnorm = rnorm;

});

var rlnorm_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rlnorm = void 0;




const exp = rFunc.arrayrify(Math.exp);
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer = src('rlnorm');
const sequence = rFunc.seq()();
function rlnorm(N, meanlog = 0, sdlog = 1, rng) {
    if (ISNAN(meanlog) || !R_FINITE(sdlog) || sdlog < 0) {
        return rFunc.map(sequence(N))(() => _general.ML_ERR_return_NAN(printer));
    }
    return exp(rnorm_1.rnorm(N, meanlog, sdlog, rng));
}
exports.rlnorm = rlnorm;

});

var lognormal = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogNormal = void 0;





function LogNormal(rng = new normal$1.Inversion()) {
    return {
        dlnorm: dlnorm_1.dlnorm,
        plnorm: plnorm_1.plnorm,
        qlnorm: qlnorm_1.qlnorm,
        rlnorm: (n, meanlog = 0, sdlog = 1) => rlnorm_1.rlnorm(n, meanlog, sdlog, rng)
    };
}
exports.LogNormal = LogNormal;

});

var dmultinom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dmultinom = void 0;


const { isFinite } = Number;
const div = rFunc.arrayrify((a, b) => a / b);
const { lgamma } = gamma.special;
const add = rFunc.arrayrify((a, b) => a + b);
const log = rFunc.arrayrify(Math.log);
function dmultinom(o) {
    o.asLog = !!o.asLog;
    let x = rFunc.flatten(o.x).filter(f => !!f);
    let prob = rFunc.flatten(o.prob);
    let badProb = !!prob.find(f => !isFinite(f) || f < 0);
    let s = rFunc.sum(prob);
    if (badProb || s === 0) {
        throw new Error('probabilities must be finite, non-negative and not all 0');
    }
    prob = rFunc.flatten(div(prob, s));
    x = x.map(Math.round);
    if (rFunc.any(x)(v => v < 0)) {
        throw new Error('probabilities must be finite, non-negative and not all 0');
    }
    const N = rFunc.sum(x);
    const size = !!o.size ? o.size : N;
    if (size !== N) {
        throw new Error(`size:${size} != sum(x):${N}, i.e. one is wrong`);
    }
    const i0 = prob.map(p => p === 0);
    if (rFunc.any(i0)(v => !!v)) {
        if (i0.find((_v, i) => x[i] !== 0)) {
            return o.asLog ? -Infinity : 0;
        }
        x = x.filter((_v, i) => i0[i]);
        prob = prob.filter((_v, i) => i0[i]);
    }
    const errMsg = [];
    if (prob.length <= 1) {
        errMsg.push(`number of propabilities need to be at least 2, it is:${prob.length}`);
    }
    if (x.length <= 1) {
        errMsg.push(`number of quantiles need to be at least 2, it is :${x.length}`);
    }
    if (x.length !== prob.length) {
        errMsg.push(`number of effective quantiles:${x.length} is not equal to number of effective probabilities:${prob.length}.`);
    }
    if (errMsg.length) {
        throw new Error(errMsg.join('\n'));
    }
    const s1 = lgamma(add(x, 1));
    const s2 = log(prob);
    const s3 = x.map((v, i) => v * s2[i] - s1[i]);
    const r = lgamma(size + 1) + rFunc.sum(s3);
    return o.asLog ? r : Math.exp(r);
}
exports.dmultinom = dmultinom;

});

var rmultinom_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rmultinom = void 0;

const { isFinite: R_FINITE } = Number;
const { abs: fabs } = Math;


const printer_rmultinom = src('rmultinom');
function rmultinom(n, size, prob, rng) {
    const result = Array.from({ length: n }).map(() => _rmultinom(size, prob, rng));
    return rFunc.possibleScalar(result);
}
exports.rmultinom = rmultinom;
function _rmultinom(size, prob, rng) {
    const rN = [];
    let p = rFunc.flatten(prob);
    const K = p.length;
    if (p.length === 0) {
        printer_rmultinom('list of probabilities cannot be empty');
        return rN;
    }
    if (size < 0) {
        printer_rmultinom('Illegal Argument:size is negative');
        rN.splice(0);
        return rN;
    }
    if (p.find(pp => !R_FINITE(pp) || pp < 0)) {
        printer_rmultinom('some propbabilities are invalid or negative numbers');
        rN.splice(0);
        return rN;
    }
    rN.splice(0, rN.length, ...new Array(K).fill(0));
    if (size === 0) {
        return rN;
    }
    let _size = size;
    let p_tot = rFunc.sum(p);
    printer_rmultinom('%o', { p, p_tot, _size, K, rN });
    for (let k = 0; k < K - 1; k++) {
        if (fabs(p_tot) < Number.EPSILON) {
            rN[k] = _size;
            _size = 0;
            p_tot = 0;
            continue;
        }
        const pp = p[k] / p_tot;
        if (pp === 0) {
            rN[k] = 0;
            continue;
        }
        if (_size === 0) {
            rN[k] = 0;
            continue;
        }
        rN[k] = pp < 1 ? rbinom_1.rbinom(1, _size, pp, rng) : _size;
        _size -= rN[k];
        p_tot -= p[k];
        printer_rmultinom('%o', { p_tot, _size, k, rN });
    }
    rN[K - 1] = _size;
    return rN;
}

});

var multinom = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Multinomial = void 0;



function Multinomial(rng = new mersenneTwister.MersenneTwister(0)) {
    function rmultinom(n, size, prob) {
        return rmultinom_1.rmultinom(n, size, prob, rng);
    }
    return {
        rmultinom,
        dmultinom: dmultinom_1.dmultinom
    };
}
exports.Multinomial = Multinomial;

});

var normal = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Normal = void 0;





const { normal: { Inversion } } = rng.rng;
function Normal(prng = new Inversion()) {
    return {
        rnorm: (n = 1, mu = 0, sigma = 1) => rnorm_1.rnorm(n, mu, sigma, prng),
        dnorm: dnorm.dnorm4,
        pnorm: pnorm.pnorm5,
        qnorm: qnorm_1.qnorm,
        rng: prng,
    };
}
exports.Normal = Normal;

});

var ppois_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.do_search = exports.ppois = void 0;

const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const { floor, max: fmax2 } = Math;



const printer = src('ppois');
function ppois(_x, lambda, lowerTail = true, logP = false) {
    return rFunc.map(_x)(x => {
        if (ISNAN(x) || ISNAN(lambda))
            return x + lambda;
        if (lambda < 0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (x < 0)
            return _general.R_DT_0(lowerTail, logP);
        if (lambda === 0)
            return _general.R_DT_1(lowerTail, logP);
        if (!R_FINITE(x))
            return _general.R_DT_1(lowerTail, logP);
        x = floor(x + 1e-7);
        return pgamma_1.pgamma(lambda, x + 1, 1, !lowerTail, logP);
    });
}
exports.ppois = ppois;
function do_search(y, z, p, lambda, incr) {
    if (z.val >= p) {
        while (true) {
            if (y === 0 ||
                (z.val = ppois(y - incr, lambda, true, false)) < p)
                return y;
            y = fmax2(0, y - incr);
        }
    }
    else {
        while (true) {
            y = y + incr;
            if ((z.val = ppois(y, lambda, true, false)) >= p)
                return y;
        }
    }
}
exports.do_search = do_search;

});

var qpois_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qpois = void 0;







const { max: fmax2, sqrt, floor, round: nearbyint } = Math;
const { isNaN: ISNAN, EPSILON: DBL_EPSILON, POSITIVE_INFINITY: ML_POSINF, isFinite: R_FINITE } = Number;
function do_search(y, z, p, lambda, incr) {
    if (z.val >= p) {
        while (true) {
            if (y === 0 || (z.val = ppois_1.ppois(y - incr, lambda, true, false)) < p)
                return y;
            y = fmax2(0, y - incr);
        }
    }
    else {
        while (true) {
            y = y + incr;
            if ((z.val = ppois_1.ppois(y, lambda, true, false)) >= p)
                return y;
        }
    }
}
function qpois(pp, lambda, lower_tail = true, log_p = false) {
    return rFunc.map(pp)(p => {
        return _qpois(p, lambda, lower_tail, log_p);
    });
}
exports.qpois = qpois;
const printer_qpois = src('_qpois');
function _qpois(p, lambda, lower_tail, log_p) {
    let mu;
    let sigma;
    let gamma;
    let y;
    let z = new toms708.NumberW(0);
    if (ISNAN(p) || ISNAN(lambda))
        return p + lambda;
    if (!R_FINITE(lambda)) {
        return _general.ML_ERR_return_NAN(printer_qpois);
    }
    if (lambda < 0)
        return _general.ML_ERR_return_NAN(printer_qpois);
    if (lambda === 0)
        return 0;
    let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, 0, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    mu = lambda;
    sigma = sqrt(lambda);
    gamma = 1.0 / sigma;
    if (!lower_tail || log_p) {
        p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
        if (p === 0)
            return 0;
        if (p === 1)
            return ML_POSINF;
    }
    if (p + 1.01 * DBL_EPSILON >= 1)
        return ML_POSINF;
    z.val = qnorm_1.qnorm(p, 0, 1, true, false);
    y = nearbyint(mu + sigma * (z.val + gamma * (z.val * z.val - 1) / 6));
    z.val = ppois_1.ppois(y, lambda, true, false);
    p *= 1 - 64 * DBL_EPSILON;
    if (lambda < 1e5)
        return do_search(y, z, p, lambda, 1);
    {
        let incr = floor(y * 0.001);
        let oldincr;
        do {
            oldincr = incr;
            y = do_search(y, z, p, lambda, incr);
            incr = fmax2(1, floor(incr / 100));
        } while (oldincr > 1 && incr > lambda * 1e-15);
        return y;
    }
}

});

var poisson = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Poisson = void 0;





function Poisson(rng = new normal$1.Inversion()) {
    return {
        dpois: dpois_1.dpois,
        ppois: ppois_1.ppois,
        qpois: qpois_1.qpois,
        rpois: (n, lambda) => rpois_1.rpois(n, lambda, rng)
    };
}
exports.Poisson = Poisson;

});

var csignrank_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.csignrank = void 0;

function csignrank(k, n, u, c, w) {
    if (k < 0 || k > u)
        return 0;
    if (k > c)
        k = u - k;
    if (n === 1)
        return 1;
    if (w[0] === 1)
        return w[k];
    w[0] = w[1] = 1;
    for (let j = 2; j < n + 1; ++j) {
        let i;
        let end = _general.imin2(j * (j + 1) / 2, c);
        for (i = end; i >= j; --i)
            w[i] += w[i - j];
    }
    return w[k];
}
exports.csignrank = csignrank;

});

var dsign = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dsignrank = void 0;



const { round, trunc, abs: fabs, log, LN2: M_LN2 } = Math;
const { isNaN: ISNAN } = Number;
const printer_dsignrank = src('dsignrank');
function dsignrank(xx, n, logX = false) {
    const rn = round(n);
    const u = rn * (rn + 1) / 2;
    const c = trunc(u / 2);
    const w = new Array(c + 1).fill(0);
    const fx = (Array.isArray(xx) ? xx : [xx]);
    const result = fx.map(x => {
        if (ISNAN(x) || ISNAN(n))
            return x + n;
        if (n <= 0) {
            return _general.ML_ERR_return_NAN(printer_dsignrank);
        }
        if (fabs(x - round(x)) > 1e-7) {
            return _general.R_D__0(logX);
        }
        x = round(x);
        if (x < 0 || x > n * (n + 1) / 2) {
            return _general.R_D__0(logX);
        }
        let d = _general.R_D_exp(logX, log(csignrank_1.csignrank(trunc(x), n, u, c, w)) - n * M_LN2);
        return d;
    });
    return (result.length === 1 ? result[0] : result);
}
exports.dsignrank = dsignrank;

});

var signrank$1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rsignrank = exports.qsignrank = exports.psignrank = exports.dsignrank = exports.csignrank = void 0;



const { isFinite: R_FINITE, EPSILON: DBL_EPSILON, isNaN: ISNAN } = Number;
const { LN2: M_LN2, abs: fabs, trunc, log, exp, floor, round } = Math;
const printer_dsignrank = src('dsignrank');
const printer_psignrank = src('psignrank');
const printer_qsignrank = src('qsignrank');
const printer_rsignrank = src('rsignrank');
function csignrank(k, n, u, c, w) {
    if (k < 0 || k > u)
        return 0;
    if (k > c)
        k = u - k;
    if (n === 1)
        return 1;
    if (w[0] === 1)
        return w[k];
    w[0] = w[1] = 1;
    for (let j = 2; j < n + 1; ++j) {
        let i;
        let end = _general.imin2(j * (j + 1) / 2, c);
        for (i = end; i >= j; --i)
            w[i] += w[i - j];
    }
    return w[k];
}
exports.csignrank = csignrank;
function dsignrank(xx, n, logX = false) {
    const rn = round(n);
    const u = rn * (rn + 1) / 2;
    const c = trunc(u / 2);
    const w = new Array(c + 1).fill(0);
    const fx = (Array.isArray(xx) ? xx : [xx]);
    const result = fx.map(x => {
        if (ISNAN(x) || ISNAN(n))
            return x + n;
        if (n <= 0) {
            return _general.ML_ERR_return_NAN(printer_dsignrank);
        }
        if (fabs(x - round(x)) > 1e-7) {
            return _general.R_D__0(logX);
        }
        x = round(x);
        if (x < 0 || x > n * (n + 1) / 2) {
            return _general.R_D__0(logX);
        }
        let d = _general.R_D_exp(logX, log(csignrank(trunc(x), n, u, c, w)) - n * M_LN2);
        return d;
    });
    return (result.length === 1 ? result[0] : result);
}
exports.dsignrank = dsignrank;
function psignrank(xx, n, lowerTail = true, logP = false) {
    const roundN = round(n);
    const u = roundN * (roundN + 1) / 2;
    const c = trunc(u / 2);
    const w = new Array(c + 1).fill(0);
    const fx = (Array.isArray(xx) ? xx : [xx]);
    const result = fx.map(x => round(x + 1e-7)).map(x => {
        let lowerT = lowerTail;
        if (ISNAN(x) || ISNAN(n))
            return x + n;
        if (!R_FINITE(n))
            return _general.ML_ERR_return_NAN(printer_psignrank);
        if (n <= 0)
            return _general.ML_ERR_return_NAN(printer_psignrank);
        if (x < 0.0) {
            return _general.R_DT_0(lowerTail, logP);
        }
        if (x >= u) {
            return _general.R_DT_1(lowerTail, logP);
        }
        let f = exp(-roundN * M_LN2);
        let p = 0;
        if (x <= u / 2) {
            for (let i = 0; i <= x; i++) {
                p += csignrank(i, roundN, u, c, w) * f;
            }
        }
        else {
            x = n * (n + 1) / 2 - x;
            for (let i = 0; i < x; i++) {
                p += csignrank(i, roundN, u, c, w) * f;
            }
            lowerT = !lowerT;
        }
        return _general.R_DT_val(lowerT, logP, p);
    });
    return (result.length === 1 ? result[0] : result);
}
exports.psignrank = psignrank;
function qsignrank(xx, n, lowerTail = true, logP = false) {
    const roundN = round(n);
    const u = roundN * (roundN + 1) / 2;
    const c = trunc(u / 2);
    const w = new Array(c + 1).fill(0);
    const fx = (Array.isArray(xx) ? xx : [xx]);
    const result = fx.map(x => {
        if (ISNAN(x) || ISNAN(n)) {
            return x + n;
        }
        if (!R_FINITE(x) || !R_FINITE(n)) {
            return _general.ML_ERR_return_NAN(printer_qsignrank);
        }
        let rc = _general.R_Q_P01_check(logP, x);
        if (rc !== undefined) {
            return rc;
        }
        if (roundN <= 0) {
            return _general.ML_ERR_return_NAN(printer_qsignrank);
        }
        if (x === _general.R_DT_0(lowerTail, logP)) {
            return 0;
        }
        if (x === _general.R_DT_1(lowerTail, logP)) {
            return u;
        }
        if (logP || !lowerTail)
            x = expm1_1.R_DT_qIv(lowerTail, logP, x);
        let f = exp(-n * M_LN2);
        let p = 0;
        let q = 0;
        if (x <= 0.5) {
            x = x - 10 * DBL_EPSILON;
            while (true) {
                p += csignrank(q, roundN, u, c, w) * f;
                if (p >= x)
                    break;
                q++;
            }
        }
        else {
            x = 1 - x + 10 * DBL_EPSILON;
            while (true) {
                p += csignrank(q, roundN, u, c, w) * f;
                if (p > x) {
                    q = trunc(u - q);
                    break;
                }
                q++;
            }
        }
        return q;
    });
    return (result.length === 1 ? result[0] : result);
}
exports.qsignrank = qsignrank;
function rsignrank(nn, n, rng) {
    const result = new Array(nn).fill(0).map(() => {
        if (ISNAN(n))
            return n;
        const nRound = round(n);
        if (nRound < 0)
            return _general.ML_ERR_return_NAN(printer_rsignrank);
        if (nRound === 0)
            return 0;
        let r = 0.0;
        let k = floor(nRound);
        for (let i = 0; i < k;) {
            r += ++i * floor(rng.unif_rand() + 0.5);
        }
        return r;
    });
    return result.length === 1 ? result[0] : result;
}
exports.rsignrank = rsignrank;

});

var psign = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.psignrank = void 0;




const { round, trunc, LN2: M_LN2, exp } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer_psignrank = src('psignrank');
function psignrank(xx, n, lowerTail = true, logP = false) {
    const roundN = round(n);
    const u = roundN * (roundN + 1) / 2;
    const c = trunc(u / 2);
    const w = new Array(c + 1).fill(0);
    return rFunc.map(xx)(x => {
        x = round(x + 1e-7);
        let lowerT = lowerTail;
        if (ISNAN(x) || ISNAN(n))
            return NaN;
        if (!R_FINITE(n))
            return _general.ML_ERR_return_NAN(printer_psignrank);
        if (n <= 0)
            return _general.ML_ERR_return_NAN(printer_psignrank);
        if (x < 0.0) {
            return _general.R_DT_0(lowerTail, logP);
        }
        if (x >= u) {
            return _general.R_DT_1(lowerTail, logP);
        }
        let f = exp(-roundN * M_LN2);
        let p = 0;
        if (x <= u / 2) {
            for (let i = 0; i <= x; i++) {
                p += signrank$1.csignrank(i, roundN, u, c, w) * f;
            }
        }
        else {
            x = n * (n + 1) / 2 - x;
            for (let i = 0; i < x; i++) {
                p += signrank$1.csignrank(i, roundN, u, c, w) * f;
            }
            lowerT = !lowerT;
        }
        return _general.R_DT_val(lowerT, logP, p);
    });
}
exports.psignrank = psignrank;

});

var qsign = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qsignrank = void 0;





const { round, trunc, LN2: M_LN2, exp } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, EPSILON: DBL_EPSILON } = Number;
const printer_qsignrank = src('qsignrank');
function qsignrank(xx, n, lowerTail = true, logP = false) {
    const roundN = round(n);
    const u = roundN * (roundN + 1) / 2;
    const c = trunc(u / 2);
    const w = new Array(c + 1).fill(0);
    return rFunc.map(xx)(x => {
        if (ISNAN(x) || ISNAN(n)) {
            return NaN;
        }
        if (!R_FINITE(n)) {
            return _general.ML_ERR_return_NAN(printer_qsignrank);
        }
        let rc = _general.R_Q_P01_check(logP, x);
        if (rc !== undefined) {
            return rc;
        }
        if (roundN <= 0) {
            return _general.ML_ERR_return_NAN(printer_qsignrank);
        }
        if (x === _general.R_DT_0(lowerTail, logP)) {
            return 0;
        }
        if (x === _general.R_DT_1(lowerTail, logP)) {
            return u;
        }
        if (logP || !lowerTail) {
            x = expm1_1.R_DT_qIv(lowerTail, logP, x);
        }
        let f = exp(-n * M_LN2);
        let p = 0;
        let q = 0;
        if (x <= 0.5) {
            x = x - 10 * DBL_EPSILON;
            while (true) {
                p += signrank$1.csignrank(q, roundN, u, c, w) * f;
                if (p >= x)
                    break;
                q++;
            }
        }
        else {
            x = 1 - x + 10 * DBL_EPSILON;
            while (true) {
                p += signrank$1.csignrank(q, roundN, u, c, w) * f;
                if (p > x) {
                    q = trunc(u - q);
                    break;
                }
                q++;
            }
        }
        return q;
    });
}
exports.qsignrank = qsignrank;

});

var rsign = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rsignrank = void 0;



const { isNaN: ISNAN } = Number;
const { floor, round } = Math;
const printer_rsignrank = src('rsignrank');
const sequence = rFunc.seq()();
function rsignrank(nn, n, rng) {
    return rFunc.map(sequence(nn))(() => {
        if (ISNAN(n))
            return n;
        const nRound = round(n);
        if (nRound < 0)
            return _general.ML_ERR_return_NAN(printer_rsignrank);
        if (nRound === 0)
            return 0;
        let r = 0.0;
        let k = floor(nRound);
        for (let i = 0; i < k;) {
            r += ++i * floor(rng.unif_rand() + 0.5);
        }
        return r;
    });
}
exports.rsignrank = rsignrank;

});

var signrank = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignRank = void 0;





const { MersenneTwister } = rng.rng;
function SignRank(rng = new MersenneTwister(0)) {
    function rsignrank(N, n) {
        return rsign.rsignrank(N, n, rng);
    }
    return {
        dsignrank: dsign.dsignrank,
        psignrank: psign.psignrank,
        qsignrank: qsign.qsignrank,
        rsignrank
    };
}
exports.SignRank = SignRank;

});

var dt_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dt = void 0;






const { log1p, abs: fabs, exp, log, sqrt } = Math;
const { isNaN: ISNAN, EPSILON: DBL_EPSILON, isFinite: R_FINITE } = Number;
const printer_dt = src('dt');
function dt(xx, n, giveLog = false) {
    return rFunc.map(xx)(x => {
        if (ISNAN(x) || ISNAN(n)) {
            return x + n;
        }
        if (n <= 0) {
            return _general.ML_ERR_return_NAN(printer_dt);
        }
        if (!R_FINITE(x)) {
            return _general.R_D__0(giveLog);
        }
        if (!R_FINITE(n)) {
            return dnorm.dnorm4(x, 0, 1, giveLog);
        }
        let u;
        let t = -bd0_1.bd0(n / 2, (n + 1) / 2) + stirlerror.stirlerr((n + 1) / 2) - stirlerror.stirlerr(n / 2);
        let x2n = x * x / n;
        let ax = 0;
        let l_x2n;
        let lrg_x2n = x2n > 1 / DBL_EPSILON;
        if (lrg_x2n) {
            ax = fabs(x);
            l_x2n = log(ax) - log(n) / 2;
            u =
                n * l_x2n;
        }
        else if (x2n > 0.2) {
            l_x2n = log(1 + x2n) / 2;
            u = n * l_x2n;
        }
        else {
            l_x2n = log1p(x2n) / 2;
            u = -bd0_1.bd0(n / 2, (n + x * x) / 2) + x * x / 2;
        }
        if (giveLog)
            return t - u - (_general.M_LN_SQRT_2PI + l_x2n);
        let I_sqrt_ = lrg_x2n ? sqrt(n) / ax : exp(-l_x2n);
        return exp(t - u) * _general.M_1_SQRT_2PI * I_sqrt_;
    });
}
exports.dt = dt;

});

var pt_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pt = void 0;






const { log1p, sqrt, log, abs: fabs, exp } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer = src('pt');
function pt(xx, n, lowerTail = true, log_p = false) {
    return rFunc.map(xx)(x => {
        let val;
        let nx;
        let lower_tail = lowerTail;
        if (ISNAN(x) || ISNAN(n))
            return x + n;
        if (n <= 0.0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (!R_FINITE(x)) {
            return x < 0 ? _general.R_DT_0(lower_tail, log_p) : _general.R_DT_1(lower_tail, log_p);
        }
        if (!R_FINITE(n)) {
            return pnorm.pnorm5(x, 0.0, 1.0, lower_tail, log_p);
        }
        if (n > 4e5) {
            val = 1 / (4 * n);
            return pnorm.pnorm5(x * (1 - val) / sqrt(1 + x * x * 2 * val), 0.0, 1.0, lower_tail, log_p);
        }
        nx = 1 + x / n * x;
        if (nx > 1e100) {
            let lval;
            lval =
                -0.5 * n * (2 * log(fabs(x)) - log(n)) -
                    lbeta_1.internal_lbeta(0.5 * n, 0.5) -
                    log(0.5 * n);
            val = log_p ? lval : exp(lval);
        }
        else {
            val =
                n > x * x
                    ? pbeta_1.pbeta(x * x / (n + x * x), 0.5, n / 2, false, log_p)
                    : pbeta_1.pbeta(1 / nx, n / 2, 0.5, true, log_p);
        }
        if (x <= 0) {
            lower_tail = !lower_tail;
        }
        if (log_p) {
            if (lower_tail) {
                return log1p(-0.5 * exp(val));
            }
            else {
                return val - _general.M_LN2;
            }
        }
        else {
            val /= 2;
            return _general.R_D_Cval(lower_tail, val);
        }
    });
}
exports.pt = pt;

});

var pnt_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pnt = void 0;







const { isFinite: R_FINITE, EPSILON: DBL_EPSILON } = Number;
const { sqrt, exp, pow, log, expm1, abs: fabs, min: fmin2 } = Math;
const printer_pnt = src('pnt');
const DBL_MIN_EXP = -1021;
const M_LN2 = 0.693147180559945309417;
function pnt(tt, df, ncp, lowerTail = true, logP = false) {
    return rFunc.map(tt)(t => _pnt(t, df, ncp, lowerTail, logP));
}
exports.pnt = pnt;
function _pnt(_t, df, ncp, lower_tail = true, log_p = false) {
    let errbd;
    let rxb;
    let x;
    let geven;
    let godd;
    let p;
    let q;
    let s;
    let tnc = 0;
    let xeven;
    let xodd;
    const itrmax = 1000;
    const errmax = 1e-12;
    if (df <= 0.0) {
        return _general.ML_ERR_return_NAN(printer_pnt);
    }
    if (ncp === 0.0) {
        return pt_1.pt(_t, df, lower_tail, log_p);
    }
    if (!R_FINITE(_t)) {
        return _t < 0 ? _general.R_DT_0(lower_tail, log_p) : _general.R_DT_1(lower_tail, log_p);
    }
    const negdel = _t < 0;
    const tt = fabs(_t);
    const del = _t >= 0 ? ncp : -ncp;
    if (_t < 0 && ncp > 40 && (!log_p || !lower_tail)) {
        printer_pnt('if x <=0 and solution for edge ncp > 40');
        return _general.R_DT_0(lower_tail, log_p);
    }
    if (df > 4e5 || del * del > 2 * M_LN2 * -DBL_MIN_EXP) {
        printer_pnt('Abramowitz & Stegun 26.7.10 ncp:%d, del:%d, ncp2:%d, del2:%d, D:%d', ncp, del, ncp * ncp, del * del, 2 * M_LN2 * -DBL_MIN_EXP);
        const _s = 1 / (4 * df);
        return pnorm.pnorm5(tt * (1 - _s), del, sqrt(1 + tt * tt * 2 * _s), lower_tail !== negdel, log_p);
    }
    x = _t * _t;
    rxb = df / (x + df);
    x = x / (x + df);
    printer_pnt('pnt(t=%d, df=%d, ncp=%d, rxb=%d) ==> x= %d', _t, df, ncp, rxb, x);
    if (x > 0) {
        printer_pnt('x > 0 branch');
        const lambda = del * del;
        p = 0.5 * exp(-0.5 * lambda);
        printer_pnt('p=%d', p);
        if (p === 0) {
            printer_pnt('p=%d, underflow protection', p);
            _general.ML_ERROR(_general.ME.ME_UNDERFLOW, 'pnt', printer_pnt);
            _general.ML_ERROR(_general.ME.ME_RANGE, 'pnt', printer_pnt);
            return _general.R_DT_0(lower_tail, log_p);
        }
        printer_pnt('it  1e5*(godd,   geven)|          p           q           s' +
            '        pnt(*)     errbd');
        q = _general.M_SQRT_2dPI * p * del;
        s = 0.5 - p;
        if (s < 1e-7)
            s = -0.5 * expm1(-0.5 * lambda);
        let a = 0.5;
        let b = 0.5 * df;
        rxb = pow(rxb, b);
        const albeta = _general.M_LN_SQRT_PI + lgamma_fn.lgammafn(b) - lgamma_fn.lgammafn(0.5 + b);
        xodd = pbeta_1.pbeta(x, a, b, true, false);
        printer_pnt('return from pbeta:%d', xodd);
        godd = 2 * rxb * exp(a * log(x) - albeta);
        tnc = b * x;
        xeven = tnc < DBL_EPSILON ? tnc : 1 - rxb;
        geven = tnc * rxb;
        tnc = p * xodd + q * xeven;
        let gotoFinis = false;
        for (let it = 1; it <= itrmax; it++) {
            a += 1;
            xodd -= godd;
            xeven -= geven;
            godd *= x * (a + b - 1) / a;
            geven *= x * (a + b - 0.5) / (a + 0.5);
            p *= lambda / (2 * it);
            q *= lambda / (2 * it + 1);
            tnc += p * xodd + q * xeven;
            s -= p;
            if (s < -1e-10) {
                _general.ML_ERROR(_general.ME.ME_PRECISION, 'pnt', printer_pnt);
                printer_pnt('goto:true, s = %d < 0 !!! ---> non-convergence!!', s);
                gotoFinis = true;
                break;
            }
            if (s <= 0) {
                printer_pnt('goto:true, s:%d < 0 && it:%d>1', s, it);
                gotoFinis = true;
                break;
            }
            errbd = 2 * s * (xodd - godd);
            printer_pnt('%d %d %d|%d %d %d %d %d', it, 1e5 * godd, 1e5 * geven, p, q, s, tnc, errbd);
            if (fabs(errbd) < errmax) {
                printer_pnt('goto:true, errbd:%d < errmax:%d', errbd, errmax);
                gotoFinis = true;
                break;
            }
            gotoFinis = false;
        }
        if (!gotoFinis) {
            _general.ML_ERROR(_general.ME.ME_NOCONV, 'pnt', printer_pnt);
        }
    }
    tnc += pnorm.pnorm5(-del, 0, 1, true, false);
    lower_tail = lower_tail !== negdel;
    if (tnc > 1 - 1e-10 && lower_tail) {
        _general.ML_ERROR(_general.ME.ME_PRECISION, 'pnt{final}', printer_pnt);
    }
    const rc = _general.R_DT_val(lower_tail, log_p, fmin2(tnc, 1));
    printer_pnt('rc:%d, tnc:%d, log_p:%s, lower_tail:%s', rc, tnc, log_p, lower_tail);
    return rc;
}

});

var dnt_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dnt = void 0;







const { isNaN: ISNAN, isFinite: R_FINITE, EPSILON: DBL_EPSILON } = Number;
const { abs: fabs, sqrt, log, exp } = Math;
const printer_dnt = src('dnt');
function dnt(xx, df, ncp = 0, giveLog = false) {
    return rFunc.map(xx)(x => {
        if (ISNAN(x) || ISNAN(df))
            return x + df;
        if (df <= 0.0)
            return _general.ML_ERR_return_NAN(printer_dnt);
        if (ncp === 0.0)
            return dt_1.dt(x, df, giveLog);
        if (!R_FINITE(x))
            return _general.R_D__0(giveLog);
        if (!R_FINITE(df) || df > 1e8)
            return dnorm.dnorm4(x, ncp, 1, giveLog);
        const u = function () {
            if (fabs(x) > sqrt(df * DBL_EPSILON)) {
                printer_dnt('fabs(x:%d)>sqrt(df*espsilon):%d', fabs(x), sqrt(df * DBL_EPSILON));
                return (log(df) -
                    log(fabs(x)) +
                    log(fabs(pnt_1.pnt(x * sqrt((df + 2) / df), df + 2, ncp, true, false) -
                        pnt_1.pnt(x, df, ncp, true, false))));
            }
            else {
                printer_dnt('fabs(x:%d)<=sqrt(df*espsilon):%d', fabs(x), sqrt(df * DBL_EPSILON));
                return (lgamma_fn.lgammafn((df + 1) / 2) -
                    lgamma_fn.lgammafn(df / 2) -
                    (_general.M_LN_SQRT_PI + 0.5 * (log(df) + ncp * ncp)));
            }
        }();
        printer_dnt('u=%d, giveLog=%s', u, giveLog);
        return giveLog ? u : exp(u);
    });
}
exports.dnt = dnt;

});

var qt_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qt = void 0;








const { LN2: M_LN2, PI: M_PI, SQRT2: M_SQRT2, sqrt, pow, log, exp, min: fmin2, abs: fabs, expm1 } = Math;
const { isNaN: ISNAN, EPSILON: DBL_EPSILON, MAX_VALUE: DBL_MAX, MIN_VALUE: DBL_MIN, POSITIVE_INFINITY: ML_POSINF, NEGATIVE_INFINITY: ML_NEGINF, isFinite: R_FINITE } = Number;
const printer_qt = src('qt');
function qt(pp, ndf, lowerTail, logP) {
    return rFunc.map(pp)(p => _qt(p, ndf, lowerTail, logP));
}
exports.qt = qt;
function _qt(p, ndf, lower_tail, log_p) {
    const eps = 1e-12;
    let P;
    let q;
    const accu = 1e-13;
    const Eps = 1e-11;
    if (ISNAN(p) || ISNAN(ndf))
        return p + ndf;
    let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, ML_NEGINF, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    if (ndf <= 0)
        return _general.ML_ERR_return_NAN(printer_qt);
    if (ndf < 1) {
        let ux;
        let lx;
        let nx;
        let pp;
        let iter = 0;
        p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
        if (p > 1 - DBL_EPSILON)
            return ML_POSINF;
        pp = fmin2(1 - DBL_EPSILON, p * (1 + Eps));
        for (ux = 1; ux < DBL_MAX && pt_1.pt(ux, ndf, true, false) < pp; ux *= 2)
            ;
        pp = p * (1 - Eps);
        for (lx = -1; lx > -DBL_MAX && pt_1.pt(lx, ndf, true, false) > pp; lx *= 2)
            ;
        do {
            nx = 0.5 * (lx + ux);
            if (pt_1.pt(nx, ndf, true, false) > p)
                ux = nx;
            else
                lx = nx;
        } while ((ux - lx) / fabs(nx) > accu && ++iter < 1000);
        if (iter >= 1000) {
            _general.ML_ERROR(_general.ME.ME_PRECISION, 'qt', printer_qt);
        }
        return 0.5 * (lx + ux);
    }
    if (ndf > 1e20)
        return qnorm_1.qnorm(p, 0, 1, lower_tail, log_p);
    P = _general.R_D_qIv(log_p, p);
    let neg = (!lower_tail || P < 0.5) && (lower_tail || P > 0.5);
    let is_neg_lower = lower_tail === neg;
    if (neg)
        P = 2 * (log_p ? (lower_tail ? P : -expm1(p)) : _general.R_D_Lval(lower_tail, p));
    else
        P = 2 * (log_p ? (lower_tail ? -expm1(p) : P) : _general.R_D_Cval(lower_tail, p));
    if (fabs(ndf - 2) < eps) {
        if (P > DBL_MIN) {
            if (3 * P < DBL_EPSILON)
                q = 1 / sqrt(P);
            else if (P > 0.9)
                q = (1 - P) * sqrt(2 / (P * (2 - P)));
            else
                q = sqrt(2 / (P * (2 - P)) - 2);
        }
        else {
            if (log_p)
                q = is_neg_lower ? exp(-p / 2) / M_SQRT2 : 1 / sqrt(-expm1(p));
            else
                q = ML_POSINF;
        }
    }
    else if (ndf < 1 + eps) {
        if (P === 1)
            q = 0;
        else if (P > 0)
            q = 1 / cospi_1.tanpi(P / 2);
        else {
            if (log_p)
                q = is_neg_lower ? _general.M_1_PI * exp(-p) : -1 / (M_PI * expm1(p));
            else
                q = ML_POSINF;
        }
    }
    else {
        let x = 0;
        let y = 0;
        let log_P2 = 0;
        let a = 1 / (ndf - 0.5);
        let b = 48 / (a * a);
        let c = ((20700 * a / b - 98) * a - 16) * a + 96.36;
        let d = ((94.5 / (b + c) - 3) / b + 1) * sqrt(a * _general.M_PI_2) * ndf;
        let P_ok1 = P > DBL_MIN || !log_p;
        let P_ok = P_ok1;
        if (P_ok1) {
            y = pow(d * P, 2.0 / ndf);
            P_ok = y >= DBL_EPSILON;
        }
        if (!P_ok) {
            log_P2 = is_neg_lower
                ? _general.R_D_log(log_p, p)
                : expm1_1.R_D_LExp(log_p, p);
            x = (log(d) + M_LN2 + log_P2) / ndf;
            y = exp(2 * x);
        }
        if ((ndf < 2.1 && P > 0.5) || y > 0.05 + a) {
            if (P_ok)
                x = qnorm_1.qnorm(0.5 * P, 0, 1, false, false);
            else
                x = qnorm_1.qnorm(log_P2, 0, 1, lower_tail, true);
            y = x * x;
            if (ndf < 5)
                c += 0.3 * (ndf - 4.5) * (x + 0.6);
            c = (((0.05 * d * x - 5) * x - 7) * x - 2) * x + b + c;
            y = (((((0.4 * y + 6.3) * y + 36) * y + 94.5) / c - y - 3) / b + 1) * x;
            y = expm1(a * y * y);
            q = sqrt(ndf * y);
        }
        else if (!P_ok && x < -M_LN2 * _general.DBL_MANT_DIG) {
            q = sqrt(ndf) * exp(-x);
        }
        else {
            y =
                ((1 / (((ndf + 6) / (ndf * y) - 0.089 * d - 0.822) * (ndf + 2) * 3) +
                    0.5 / (ndf + 4)) *
                    y -
                    1) *
                    (ndf + 1) /
                    (ndf + 2) +
                    1 / y;
            q = sqrt(ndf * y);
        }
        if (P_ok1) {
            let it = 0;
            while (it++ < 10 &&
                (y = dt_1.dt(q, ndf, false)) > 0 &&
                R_FINITE((x = (pt_1.pt(q, ndf, false, false) - P / 2) / y)) &&
                fabs(x) > 1e-14 * fabs(q))
                q += x * (1 + x * q * (ndf + 1) / (2 * (q * q + ndf)));
        }
    }
    if (neg)
        q = -q;
    return q;
}

});

var qnt_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qnt = void 0;







const { abs: fabs, max: fmax2, min: fmin2 } = Math;
const { MAX_VALUE: DBL_MAX, EPSILON: DBL_EPSILON, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF, NEGATIVE_INFINITY: ML_NEGINF, isNaN: ISNAN } = Number;
const printer = src('qnt');
function qnt(pp, df, ncp, lowerTail, logP) {
    return rFunc.map(pp)(p => _qnt(p, df, ncp, lowerTail, logP));
}
exports.qnt = qnt;
function _qnt(p, df, ncp, lower_tail, log_p) {
    const accu = 1e-13;
    const Eps = 1e-11;
    let ux;
    let lx;
    let nx;
    let pp;
    if (ISNAN(p) || ISNAN(df) || ISNAN(ncp))
        return p + df + ncp;
    if (df <= 0.0)
        return _general.ML_ERR_return_NAN(printer);
    if (ncp === 0.0 && df >= 1.0)
        return qt_1.qt(p, df, lower_tail, log_p);
    let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, ML_NEGINF, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    if (!R_FINITE(df))
        return qnorm_1.qnorm(p, ncp, 1, lower_tail, log_p);
    p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
    if (p > 1 - DBL_EPSILON)
        return ML_POSINF;
    pp = fmin2(1 - DBL_EPSILON, p * (1 + Eps));
    for (ux = fmax2(1, ncp); ux < DBL_MAX && pnt_1.pnt(ux, df, ncp, true, false) < pp; ux *= 2)
        ;
    pp = p * (1 - Eps);
    for (lx = fmin2(-1, -ncp); lx > -DBL_MAX && pnt_1.pnt(lx, df, ncp, true, false) > pp; lx *= 2)
        ;
    do {
        nx = 0.5 * (lx + ux);
        if (pnt_1.pnt(nx, df, ncp, true, false) > p)
            ux = nx;
        else
            lx = nx;
    } while (ux - lx > accu * fmax2(fabs(lx), fabs(ux)));
    return 0.5 * (lx + ux);
}

});

var rt_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rt = void 0;




const { sqrt } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const sequence = rFunc.seq()();
const printer = src('rt');
function rt(n, df, rng) {
    return rFunc.map(sequence(n))(() => {
        if (ISNAN(df) || df <= 0.0) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (!R_FINITE(df))
            return rng.norm_rand();
        else {
            let num = rng.norm_rand();
            return num / sqrt(rchisq_1.rchisq(1, df, rng) / df);
        }
    });
}
exports.rt = rt;

});

var studentT = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.StudentT = void 0;











function StudentT(rng = new inversion.Inversion()) {
    function dt(x, df, ncp, asLog = false) {
        if (ncp === undefined) {
            return dt_1.dt(x, df, asLog);
        }
        return dnt_1.dnt(x, df, ncp, asLog);
    }
    function pt(q, df, ncp, lowerTail = true, logP = false) {
        if (ncp === undefined) {
            return pt_1.pt(q, df, lowerTail, logP);
        }
        return pnt_1.pnt(q, df, ncp, lowerTail, logP);
    }
    function qt(pp, df, ncp, lowerTail = true, logP = false) {
        if (ncp === undefined) {
            return qt_1.qt(pp, df, lowerTail, logP);
        }
        return qnt_1.qnt(pp, df, ncp, lowerTail, logP);
    }
    function rt(n, df, ncp) {
        if (ncp === undefined) {
            return rt_1.rt(n, df, rng);
        }
        else if (Number.isNaN(ncp)) {
            return new Array(n).fill(NaN);
        }
        else {
            const div = rFunc.arrayrify((a, b) => a / b);
            const sqrt = rFunc.arrayrify(Math.sqrt);
            const norm = rFunc.flatten(rnorm_1.rnorm(n, ncp, 1, rng));
            const chisq = rFunc.flatten(sqrt(div(rchisq_1.rchisq(n, df, rng), df)));
            const result = norm.map((n, i) => n / chisq[i]);
            return result.length === 1 ? result[0] : result;
        }
    }
    return {
        dt,
        pt,
        qt,
        rt
    };
}
exports.StudentT = StudentT;

});

var wprob_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.wprob = void 0;


const { exp, pow } = Math;
const bb = 8;
const C2 = -50;
const wlar = 3;
const wincr1 = 2;
const wincr2 = 3;
const nleg = 12;
const ihalf = 6;
const xleg = [
    0.981560634246719250690549090149,
    0.904117256370474856678465866119,
    0.769902674194304687036893833213,
    0.587317954286617447296702418941,
    0.367831498998180193752691536644,
    0.125233408511468915472441369464
];
const aleg = [
    0.047175336386511827194615961485,
    0.106939325995318430960254718194,
    0.160078328543346226334652529543,
    0.20316742672306592174906445581,
    0.233492536538354808760849898925,
    0.249147045813402785000562436043
];
const C3 = 60;
const C1 = -30;
function wprob(w, rr, cc) {
    let a;
    let ac;
    let pr_w;
    let b;
    let binc;
    let c;
    let cc1;
    let pminus;
    let pplus;
    let qexpo;
    let qsqz;
    let rinsum;
    let wi;
    let wincr;
    let xx;
    let blb;
    let bub;
    let einsum;
    let elsum;
    let j;
    qsqz = w * 0.5;
    if (qsqz >= bb) {
        return 1.0;
    }
    pr_w =
        2 * pnorm.pnorm5(qsqz, 0, 1, true, false) - 1;
    if (pr_w >= exp(C2 / cc))
        pr_w = pow(pr_w, cc);
    else
        pr_w = 0.0;
    if (w > wlar)
        wincr = wincr1;
    else
        wincr = wincr2;
    blb = qsqz;
    binc = (bb - qsqz) / wincr;
    bub = blb + binc;
    einsum = 0.0;
    cc1 = cc - 1.0;
    for (wi = 1; wi <= wincr; wi++) {
        elsum = 0.0;
        a = 0.5 * (bub + blb);
        b = 0.5 * (bub - blb);
        for (let jj = 1; jj <= nleg; jj++) {
            if (ihalf < jj) {
                j = nleg - jj + 1;
                xx = xleg[j - 1];
            }
            else {
                j = jj;
                xx = -xleg[j - 1];
            }
            c = b * xx;
            ac = a + c;
            qexpo = ac * ac;
            if (qexpo > C3)
                break;
            pplus = 2 * pnorm.pnorm5(ac, 0, 1, true, false);
            pminus = 2 * pnorm.pnorm5(ac, w, 1, true, false);
            rinsum = pplus * 0.5 - pminus * 0.5;
            if (rinsum >= exp(C1 / cc1)) {
                rinsum = aleg[j - 1] * exp(-(0.5 * qexpo)) * pow(rinsum, cc1);
                elsum += rinsum;
            }
        }
        elsum *= 2.0 * b * cc * _general.M_1_SQRT_2PI;
        einsum += elsum;
        blb = bub;
        bub += binc;
    }
    pr_w += einsum;
    if (pr_w <= exp(C1 / rr))
        return 0;
    pr_w = pow(pr_w, rr);
    if (pr_w >= 1)
        return 1;
    return pr_w;
}
exports.wprob = wprob;

});

var ptukey_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports._ptukey = exports.ptukey = void 0;



const _general_2 = _general;


const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const { exp, sqrt, log, LN2: M_LN2 } = Math;
const printer_ptukey = src('_ptukey');
function ptukey(qq, rr, cc, df, lower_tail = true, log_p = false) {
    return rFunc.map(qq)(q => _ptukey(q, rr, cc, df, lower_tail, log_p));
}
exports.ptukey = ptukey;
function _ptukey(q, rr, cc, df, lower_tail, log_p) {
    const nlegq = 16;
    const ihalfq = 8;
    const eps1 = -30.0;
    const eps2 = 1.0e-14;
    const dhaf = 100.0;
    const dquar = 800.0;
    const deigh = 5000.0;
    const dlarg = 25000.0;
    const ulen1 = 1.0;
    const ulen2 = 0.5;
    const ulen3 = 0.25;
    const ulen4 = 0.125;
    const xlegq = [
        0.98940093499164993259615417345,
        0.944575023073232576077988415535,
        0.865631202387831743880467897712,
        0.755404408355003033895101194847,
        0.617876244402643748446671764049,
        0.458016777657227386342419442984,
        0.28160355077925891323046050146,
        0.95012509837637440185319335425e-1
    ];
    const alegq = [
        0.27152459411754094851780572456e-1,
        0.622535239386478928628438369944e-1,
        0.951585116824927848099251076022e-1,
        0.124628971255533872052476282192,
        0.149595988816576732081501730547,
        0.16915651939500253818931207903,
        0.182603415044923588866763667969,
        0.189450610455068496285396723208
    ];
    let ans;
    let f2;
    let f21;
    let f2lf;
    let ff4;
    let otsum;
    let qsqz;
    let rotsum;
    let twa1;
    let ulen;
    let wprb;
    if (ISNAN(q) || ISNAN(rr) || ISNAN(cc) || ISNAN(df)) {
        return _general.ML_ERR_return_NAN(printer_ptukey);
    }
    if (q <= 0) {
        return _general.R_DT_0(lower_tail, log_p);
    }
    if (df < 2 || rr < 1 || cc < 2)
        return _general.ML_ERR_return_NAN(printer_ptukey);
    if (!R_FINITE(q))
        return _general.R_DT_1(lower_tail, log_p);
    if (df > dlarg)
        return _general_2.R_DT_val(lower_tail, log_p, wprob_1.wprob(q, rr, cc));
    f2 = df * 0.5;
    f2lf = f2 * log(df) - df * M_LN2 - lgamma_fn.lgammafn(f2);
    f21 = f2 - 1.0;
    ff4 = df * 0.25;
    if (df <= dhaf)
        ulen = ulen1;
    else if (df <= dquar)
        ulen = ulen2;
    else if (df <= deigh)
        ulen = ulen3;
    else
        ulen = ulen4;
    f2lf += log(ulen);
    ans = 0.0;
    otsum = 0.0;
    for (let i = 1; i <= 50; i++) {
        otsum = 0.0;
        twa1 = (2 * i - 1) * ulen;
        for (let jj = 1; jj <= nlegq; jj++) {
            const j = ihalfq < jj ? jj - ihalfq - 1 : jj - 1;
            const t1 = ihalfq < jj
                ? f2lf +
                    f21 * log(twa1 + xlegq[j] * ulen) -
                    (xlegq[j] * ulen + twa1) * ff4
                : f2lf +
                    f21 * log(twa1 - xlegq[j] * ulen) +
                    (xlegq[j] * ulen - twa1) * ff4;
            if (t1 >= eps1) {
                if (ihalfq < jj) {
                    qsqz = q * sqrt((xlegq[j] * ulen + twa1) * 0.5);
                }
                else {
                    qsqz = q * sqrt((-(xlegq[j] * ulen) + twa1) * 0.5);
                }
                wprb = wprob_1.wprob(qsqz, rr, cc);
                rotsum = wprb * alegq[j] * exp(t1);
                otsum += rotsum;
            }
        }
        if (i * ulen >= 1.0 && otsum <= eps2)
            break;
        ans += otsum;
    }
    if (otsum > eps2) {
        _general.ML_ERROR(_general.ME.ME_PRECISION, 'ptukey', printer_ptukey);
    }
    if (ans > 1)
        ans = 1;
    return _general_2.R_DT_val(lower_tail, log_p, ans);
}
exports._ptukey = _ptukey;

});

var qtukey_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qtukey = void 0;
const { sqrt, log } = Math;
function qinv(p, c, v) {
    const p0 = 0.322232421088;
    const q0 = 0.99348462606e-1;
    const p1 = -1.0;
    const q1 = 0.588581570495;
    const p2 = -0.342242088547;
    const q2 = 0.531103462366;
    const p3 = -0.204231210125;
    const q3 = 0.10353775285;
    const p4 = -0.453642210148e-4;
    const q4 = 0.38560700634e-2;
    const c1 = 0.8832;
    const c2 = 0.2368;
    const c3 = 1.214;
    const c4 = 1.208;
    const c5 = 1.4142;
    const vmax = 120.0;
    let ps;
    let q;
    let t;
    let yi;
    ps = 0.5 - 0.5 * p;
    yi = sqrt(log(1.0 / (ps * ps)));
    t =
        yi +
            ((((yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0) /
                ((((yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);
    if (v < vmax)
        t += (t * t * t + t) / v / 4.0;
    q = c1 - c2 * t;
    if (v < vmax)
        q += -c3 / v + c4 * t / v;
    return t * (q * log(c - 1.0) + c5);
}





const { isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF } = Number;
const { abs: fabs, max: fmax2 } = Math;
const printer = src('qtukey');
function qtukey(pp, rr, cc, df, lower_tail = true, log_p = false) {
    return rFunc.map(pp)(p => _qtukey(p, rr, cc, df, lower_tail, log_p));
}
exports.qtukey = qtukey;
function _qtukey(p, rr, cc, df, lower_tail, log_p) {
    const eps = 0.0001;
    const maxiter = 50;
    let ans = 0.0;
    let valx0;
    let valx1;
    let x0;
    let x1;
    let xabs;
    let iter;
    if (ISNAN(p) || ISNAN(rr) || ISNAN(cc) || ISNAN(df)) {
        _general.ML_ERROR(_general.ME.ME_DOMAIN, 'qtukey', printer);
        return NaN;
    }
    if (df < 2 || rr < 1 || cc < 2)
        return _general.ML_ERR_return_NAN(printer);
    let rc = _general.R_Q_P01_boundaries(lower_tail, log_p, p, 0, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
    x0 = qinv(p, cc, df);
    valx0 = ptukey_1._ptukey(x0, rr, cc, df, true, false) - p;
    if (valx0 > 0.0)
        x1 = fmax2(0.0, x0 - 1.0);
    else
        x1 = x0 + 1.0;
    valx1 = ptukey_1._ptukey(x1, rr, cc, df, true, false) - p;
    for (iter = 1; iter < maxiter; iter++) {
        ans = x1 - valx1 * (x1 - x0) / (valx1 - valx0);
        valx0 = valx1;
        x0 = x1;
        if (ans < 0.0) {
            ans = 0.0;
            valx1 = -p;
        }
        valx1 =
            ptukey_1._ptukey(ans, rr, cc, df, true, false) - p;
        x1 = ans;
        xabs = fabs(x1 - x0);
        if (xabs < eps)
            return ans;
    }
    _general.ML_ERROR(_general.ME.ME_NOCONV, 'qtukey', printer);
    return ans;
}

});

var tukey = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tukey = void 0;


function Tukey() {
    function ptukey(q, nmeans, df, nranges = 1, lowerTail = true, logP = false) {
        return ptukey_1.ptukey(q, nranges, nmeans, df, lowerTail, logP);
    }
    function qtukey(q, nmeans, df, nranges = 1, lowerTail = true, logP = false) {
        return qtukey_1.qtukey(q, nranges, nmeans, df, lowerTail, logP);
    }
    return {
        ptukey,
        qtukey
    };
}
exports.Tukey = Tukey;

});

var dunif_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dunif = void 0;


const { isNaN: ISNAN } = Number;
const { log } = Math;
function dunif(x, min = 0, max = 1, logP = false) {
    return rFunc.map(x)(fx => {
        if (ISNAN(fx) || ISNAN(min) || ISNAN(max)) {
            return fx + min + max;
        }
        if (min <= fx && fx <= max) {
            return logP ? -log(max - min) : 1 / (max - min);
        }
        return _general.R_D__0(logP);
    });
}
exports.dunif = dunif;

});

var punif_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.punif = void 0;

const printer = src('punif');


const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
function punif(q, min = 0, max = 1, lowerTail = true, logP = false) {
    return rFunc.map(q)(fx => {
        if (ISNAN(fx) || ISNAN(min) || ISNAN(max)) {
            return fx + min + max;
        }
        if (max < min) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (!R_FINITE(min) || !R_FINITE(max)) {
            return _general.ML_ERR_return_NAN(printer);
        }
        if (fx >= max) {
            return _general.R_DT_1(lowerTail, logP);
        }
        if (fx <= min) {
            return _general.R_DT_0(lowerTail, logP);
        }
        if (lowerTail) {
            return _general.R_D_val(logP, (fx - min) / (max - min));
        }
        return _general.R_D_val(logP, (max - fx) / (max - min));
    });
}
exports.punif = punif;

});

var qunif_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qunif = void 0;




const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer = src('qunif');
function qunif(p, min = 0, max = 1, lowerTail = true, logP = false) {
    return rFunc.map(p)(fp => {
        if (ISNAN(fp) || ISNAN(min) || ISNAN(max))
            return NaN;
        let rc = _general.R_Q_P01_check(logP, fp);
        if (rc !== undefined) {
            return rc;
        }
        if (!R_FINITE(min) || !R_FINITE(max))
            return _general.ML_ERR_return_NAN(printer);
        if (max < min)
            return _general.ML_ERR_return_NAN(printer);
        if (max === min)
            return min;
        return min + expm1_1.R_DT_qIv(lowerTail, logP, fp) * (max - min);
    });
}
exports.qunif = qunif;

});

var runif_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.runif = void 0;


const { isFinite: R_FINITE } = Number;
const printer = src('runif');
function runif(n = 1, min = 0, max = 1, u) {
    if (!(R_FINITE(min) && R_FINITE(max) && max > min)) {
        return _general.ML_ERR_return_NAN(printer);
    }
    let result = new Array(n).fill(0).map(() => {
        const s = u.unif_rand();
        return (max - min) * s + min;
    });
    return result.length === 1 ? result[0] : result;
}
exports.runif = runif;

});

var uniform = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uniform = void 0;





const { MersenneTwister } = rng.rng;
function Uniform(rng = new MersenneTwister(0)) {
    return {
        dunif: dunif_1.dunif,
        punif: punif_1.punif,
        qunif: qunif_1.qunif,
        rng,
        runif: (n = 1, min = 0, max = 1) => runif_1.runif(n, min, max, rng)
    };
}
exports.Uniform = Uniform;

});

var dweibull_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dweibull = void 0;



const { pow, log, exp } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer = src('dweilbull');
function dweibull(xx, shape, scale = 1, give_log = false) {
    return rFunc.map(xx)(x => {
        if (ISNAN(x) || ISNAN(shape) || ISNAN(scale))
            return x + shape + scale;
        if (shape <= 0 || scale <= 0)
            return _general.ML_ERR_return_NAN(printer);
        if (x < 0)
            return _general.R_D__0(give_log);
        if (!R_FINITE(x))
            return _general.R_D__0(give_log);
        if (x === 0 && shape < 1)
            return ML_POSINF;
        let tmp1 = pow(x / scale, shape - 1);
        let tmp2 = tmp1 * (x / scale);
        return give_log
            ? -tmp2 + log(shape * tmp1 / scale)
            : shape * tmp1 * exp(-tmp2) / scale;
    });
}
exports.dweibull = dweibull;

});

var pweibull_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pweibull = void 0;




const { expm1, pow } = Math;
const { isNaN: ISNAN } = Number;
const printer = src('pweibull');
function pweibull(xx, shape, scale = 1, lower_tail = true, log_p = false) {
    return rFunc.map(xx)(x => {
        if (ISNAN(x) || ISNAN(shape) || ISNAN(scale))
            return x + shape + scale;
        if (shape <= 0 || scale <= 0)
            return _general.ML_ERR_return_NAN(printer);
        if (x <= 0) {
            return _general.R_DT_0(lower_tail, log_p);
        }
        x = -pow(x / scale, shape);
        return lower_tail ? (log_p ? expm1_1.R_Log1_Exp(x) : -expm1(x)) : _general.R_D_exp(log_p, x);
    });
}
exports.pweibull = pweibull;

});

var qweibull_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qweibull = void 0;




const { pow } = Math;
const { isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer = src('qweibull');
function qweibull(pp, shape, scale = 1, lowerTail = true, logP = false) {
    return rFunc.map(pp)(p => {
        if (ISNAN(p) || ISNAN(shape) || ISNAN(scale))
            return p + shape + scale;
        if (shape <= 0 || scale <= 0)
            return _general.ML_ERR_return_NAN(printer);
        let rc = _general.R_Q_P01_boundaries(lowerTail, logP, p, 0, ML_POSINF);
        if (rc !== undefined) {
            return rc;
        }
        return scale * pow(-expm1_1.R_DT_Clog(lowerTail, logP, p), 1 / shape);
    });
}
exports.qweibull = qweibull;

});

var rweibull_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rweibull = void 0;



const { log, pow } = Math;
const { isFinite: R_FINITE } = Number;
const printer = src('rweibull');
function rweibull(n, shape, scale = 1, rng) {
    const result = new Array(n).fill(0).map(() => {
        if (!R_FINITE(shape) || !R_FINITE(scale) || shape <= 0 || scale <= 0) {
            if (scale === 0)
                return 0;
            return _general.ML_ERR_return_NAN(printer);
        }
        return scale * pow(-log(rng.unif_rand()), 1.0 / shape);
    });
    return rFunc.possibleScalar(result);
}
exports.rweibull = rweibull;

});

var weibull = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Weibull = void 0;





function Weibull(rng$1 = new rng.rng.MersenneTwister(0)) {
    function rweibull(n, shape, scale = 1) {
        return rweibull_1.rweibull(n, shape, scale, rng$1);
    }
    return {
        dweibull: dweibull_1.dweibull,
        pweibull: pweibull_1.pweibull,
        qweibull: qweibull_1.qweibull,
        rweibull
    };
}
exports.Weibull = Weibull;

});

var choose_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.internal_choose = exports.internal_lchoose = exports.lchoose = exports.choose = void 0;


const { abs: fabs, log, exp, round } = Math;
const { isInteger, NEGATIVE_INFINITY: ML_NEGINF, isNaN: ISNAN } = Number;




function lfastchoose(n, k) {
    return -log(n + 1) - lbeta_1.internal_lbeta(n - k + 1, k + 1);
}
function lfastchoose2(n, k, sChoose) {
    let r;
    r = lgammafn_sign_1.lgammafn_sign(n - k + 1, sChoose);
    return lgamma_fn.lgammafn(n + 1) - lgamma_fn.lgammafn(k + 1) - r;
}
function choose(_n, _k) {
    return rFunc.multiplexer(_n, _k)((n, k) => internal_choose(n, k));
}
exports.choose = choose;
function lchoose(_n, _k) {
    return rFunc.multiplexer(_n, _k)((n, k) => internal_lchoose(n, k));
}
exports.lchoose = lchoose;
const printer_lchoose = src('lchoose');
function internal_lchoose(n, k) {
    let k0 = k;
    k = Math.round(k);
    if (ISNAN(n) || ISNAN(k))
        return n + k;
    if (fabs(k - k0) > 1e-7)
        printer_lchoose('"k" (%d) must be integer, rounded to %d', k0, k);
    if (k < 2) {
        if (k < 0)
            return ML_NEGINF;
        if (k === 0)
            return 0;
        return log(fabs(n));
    }
    if (n < 0) {
        return internal_lchoose(-n + k - 1, k);
    }
    else if (isInteger(n)) {
        n = round(n);
        if (n < k)
            return ML_NEGINF;
        if (n - k < 2)
            return internal_lchoose(n, n - k);
        return lfastchoose(n, k);
    }
    if (n < k - 1) {
        return lfastchoose2(n, k);
    }
    return lfastchoose(n, k);
}
exports.internal_lchoose = internal_lchoose;
const k_small_max = 30;
const printer_choose = src('choose');
function internal_choose(n, k) {
    let r;
    let k0 = k;
    k = round(k);
    if (ISNAN(n) || ISNAN(k))
        return n + k;
    if (fabs(k - k0) > 1e-7)
        printer_choose('k (%d) must be integer, rounded to %d', k0, k);
    if (k < k_small_max) {
        let j;
        if (n - k < k && n >= 0 && isInteger(n))
            k = n - k;
        if (k < 0)
            return 0;
        if (k === 0)
            return 1;
        r = n;
        for (j = 2; j <= k; j++)
            r *= (n - j + 1) / j;
        return isInteger(n) ? round(r) : r;
    }
    if (n < 0) {
        r = internal_choose(-n + k - 1, k);
        if (_general.isOdd(k))
            r = -r;
        return r;
    }
    else if (isInteger(n)) {
        n = round(n);
        if (n < k)
            return 0;
        if (n - k < k_small_max)
            return internal_choose(n, n - k);
        return round(exp(lfastchoose(n, k)));
    }
    if (n < k - 1) {
        let schoose = [0];
        r = lfastchoose2(n, k, schoose);
        return schoose[0] * exp(r);
    }
    return exp(lfastchoose(n, k));
}
exports.internal_choose = internal_choose;

});

var cwilcox_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.cwilcox = void 0;
const { trunc } = Math;
function cwilcox(k, m, n, w) {
    let i;
    let j;
    const u = m * n;
    const c = trunc(u / 2);
    if (k < 0 || k > u) {
        return 0;
    }
    if (k > c) {
        k = u - k;
    }
    if (m < n) {
        i = m;
        j = n;
    }
    else {
        i = n;
        j = m;
    }
    if (j > 0 && k < j) {
        return cwilcox(k, i, k, w);
    }
    if (w.get(i, j, k) === undefined) {
        if (j === 0) {
            w.set(i, j, k, k === 0 ? 1 : 0);
        }
        else {
            const c1 = cwilcox(k - j, i - 1, j, w);
            const c2 = cwilcox(k, i, j - 1, w);
            w.set(i, j, k, c1 + c2);
        }
    }
    const result = w.get(i, j, k);
    if (result === undefined) {
        throw new Error('WilcoxonCache not set');
    }
    return result;
}
exports.cwilcox = cwilcox;

});

var WilcoxonCache_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.WilcoxonCache = void 0;
class WilcoxonCache {
    constructor() {
        this._map2 = {};
    }
    get(i, j, k) {
        const jstruct = this._map2[i];
        if (jstruct !== undefined) {
            const kstruct = jstruct[j];
            if (kstruct !== undefined) {
                return kstruct[k];
            }
        }
        return undefined;
    }
    set(i, j, k, value) {
        let jstruct = this._map2[i];
        if (jstruct === undefined) {
            jstruct = {};
            this._map2[i] = jstruct;
        }
        let kstruct = jstruct[j];
        if (kstruct === undefined) {
            kstruct = {};
            jstruct[j] = kstruct;
        }
        kstruct[k] = value;
    }
}
exports.WilcoxonCache = WilcoxonCache;

});

var dwilcox_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dwilcox = void 0;






const { round: R_forceint, abs: fabs, log } = Math;
const { isNaN: ISNAN } = Number;
const printer_dwilcox = src('dwilcox');
function dwilcox(xx, m, n, giveLog = false) {
    m = R_forceint(m);
    n = R_forceint(n);
    return rFunc.map(xx)(x => {
        const w = new WilcoxonCache_1.WilcoxonCache();
        if (ISNAN(x) || ISNAN(m) || ISNAN(n)) {
            return (x + m + n);
        }
        if (m <= 0 || n <= 0) {
            return _general.ML_ERR_return_NAN(printer_dwilcox);
        }
        if (fabs(x - R_forceint(x)) > 1e-7) {
            return _general.R_D__0(giveLog);
        }
        x = R_forceint(x);
        if (x < 0 || x > m * n) {
            return _general.R_D__0(giveLog);
        }
        return giveLog
            ? log(cwilcox_1.cwilcox(x, m, n, w)) - choose_1.internal_lchoose(m + n, n)
            : cwilcox_1.cwilcox(x, m, n, w) / choose_1.internal_choose(m + n, n);
    });
}
exports.dwilcox = dwilcox;

});

var pwilcox_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.pwilcox = void 0;






const { round: R_forceint, floor } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE } = Number;
const printer_pwilcox = src('pwilcox');
function pwilcox(qq, m, n, lowerTail = true, logP = false) {
    m = R_forceint(m);
    n = R_forceint(n);
    return rFunc.map(qq)(q => {
        const w = new WilcoxonCache_1.WilcoxonCache();
        let lower_tail = lowerTail;
        if (ISNAN(q) || ISNAN(m) || ISNAN(n))
            return q + m + n;
        if (!R_FINITE(m) || !R_FINITE(n))
            return _general.ML_ERR_return_NAN(printer_pwilcox);
        if (m <= 0 || n <= 0)
            return _general.ML_ERR_return_NAN(printer_pwilcox);
        q = floor(q + 1e-7);
        if (q < 0.0)
            return _general.R_DT_0(lower_tail, logP);
        if (q >= m * n)
            return _general.R_DT_1(lower_tail, logP);
        let c = choose_1.internal_choose(m + n, n);
        let p = 0;
        if (q <= m * n / 2) {
            for (let i = 0; i <= q; i++)
                p += cwilcox_1.cwilcox(i, m, n, w) / c;
        }
        else {
            q = m * n - q;
            for (let i = 0; i < q; i++)
                p += cwilcox_1.cwilcox(i, m, n, w) / c;
            lower_tail = !lower_tail;
        }
        return _general.R_DT_val(lower_tail, logP, p);
    });
}
exports.pwilcox = pwilcox;

});

var qwilcox_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.qwilcox = void 0;







const { round: R_forceint, trunc } = Math;
const { isNaN: ISNAN, isFinite: R_FINITE, EPSILON: DBL_EPSILON } = Number;
const printer_qwilcox = src('qwilcox');
function qwilcox(xx, m, n, lowerTail = true, logP = false) {
    m = R_forceint(m);
    n = R_forceint(n);
    const w = new WilcoxonCache_1.WilcoxonCache();
    return rFunc.map(xx)(x => {
        if (ISNAN(x) || ISNAN(m) || ISNAN(n))
            return x + m + n;
        if (!R_FINITE(x) || !R_FINITE(m) || !R_FINITE(n))
            return _general.ML_ERR_return_NAN(printer_qwilcox);
        _general.R_Q_P01_check(logP, x);
        if (m <= 0 || n <= 0)
            return _general.ML_ERR_return_NAN(printer_qwilcox);
        if (x === _general.R_DT_0(lowerTail, logP))
            return 0;
        if (x === _general.R_DT_1(lowerTail, logP))
            return m * n;
        if (logP || !lowerTail)
            x = expm1_1.R_DT_qIv(lowerTail, logP, x);
        let c = choose_1.internal_choose(m + n, n);
        let p = 0;
        let q = 0;
        if (x <= 0.5) {
            x = x - 10 * DBL_EPSILON;
            while (true) {
                p += cwilcox_1.cwilcox(q, m, n, w) / c;
                if (p >= x)
                    break;
                q++;
            }
        }
        else {
            x = 1 - x + 10 * DBL_EPSILON;
            while (true) {
                p += cwilcox_1.cwilcox(q, m, n, w) / c;
                if (p > x) {
                    q = trunc(m * n - q);
                    break;
                }
                q++;
            }
        }
        return q;
    });
}
exports.qwilcox = qwilcox;

});

var rwilcox_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rwilcox = void 0;



const printer_rwilcox = src('rwilcox');
const { round: R_forceint, trunc, floor } = Math;
const { isNaN: ISNAN } = Number;
function rwilcox(N, m, n, rng) {
    const result = new Array(N).fill(0).map(() => {
        if (ISNAN(m) || ISNAN(n))
            return m + n;
        m = R_forceint(m);
        n = R_forceint(n);
        if (m < 0 || n < 0)
            return _general.ML_ERR_return_NAN(printer_rwilcox);
        if (m === 0 || n === 0)
            return 0;
        let r = 0.0;
        let k = trunc(m + n);
        let x = rFunc.seq()()(0, k - 1);
        printer_rwilcox(`------v`);
        for (let i = 0; i < n; i++) {
            let j = floor(k * rng.unif_rand());
            r += x[j];
            x[j] = x[--k];
            printer_rwilcox('i:%d,\tn:%d\tj:%d\tk:%d\tr:%d\tx:%o', i, n, j, k, x);
        }
        return r - n * (n - 1) / 2;
    });
    return rFunc.possibleScalar(result);
}
exports.rwilcox = rwilcox;

});

var wilcoxon = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wilcoxon = void 0;





function Wilcoxon(rng = new mersenneTwister.MersenneTwister(0)) {
    function rwilcox(nn, m, n) {
        return rwilcox_1.rwilcox(nn, m, n, rng);
    }
    return {
        dwilcox: dwilcox_1.dwilcox,
        pwilcox: pwilcox_1.pwilcox,
        qwilcox: qwilcox_1.qwilcox,
        rwilcox
    };
}
exports.Wilcoxon = Wilcoxon;

});

var besselConstants = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.M_eps_sinc = exports.sqxmin_BESS_K = exports.xmax_BESS_K = exports.thresh_BESS_Y = exports.xlrg_BESS_Y = exports.xlrg_BESS_IJ = exports.exparg_BESS = exports.enten_BESS = exports.enmten_BESS = exports.rtnsig_BESS = exports.ensig_BESS = exports.nsig_BESS = void 0;
exports.nsig_BESS = 16;
exports.ensig_BESS = 1e16;
exports.rtnsig_BESS = 1e-4;
exports.enmten_BESS = 8.9e-308;
exports.enten_BESS = 1e308;
exports.exparg_BESS = 709.;
exports.xlrg_BESS_IJ = 1e5;
exports.xlrg_BESS_Y = 1e8;
exports.thresh_BESS_Y = 16.;
exports.xmax_BESS_K = 705.342;
exports.sqxmin_BESS_K = 1.49e-154;
exports.M_eps_sinc = 2.149e-8;

});

var Kbessel = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.K_bessel = void 0;



const M_SQRT_2dPI = 0.797884560802865355879892119869;
const { min, log, exp, abs: fabs, sinh, trunc, sqrt, max } = Math;
const { MAX_VALUE: DBL_MAX, EPSILON: DBL_EPSILON, MIN_VALUE: DBL_MIN } = Number;
const printer = src('K_bessel');
const ML_POSINF = Infinity;
function K_bessel(x, alpha, nb, ize) {
    const a = .11593151565841244881;
    const p = [.805629875690432845, 20.4045500205365151,
        157.705605106676174, 536.671116469207504, 900.382759291288778,
        730.923886650660393, 229.299301509425145, .822467033424113231];
    const q = [29.4601986247850434, 277.577868510221208,
        1206.70325591027438, 2762.91444159791519, 3443.74050506564618,
        2210.63190113378647, 572.267338359892221];
    const r = [-.48672575865218401848, 13.079485869097804016,
        -101.96490580880537526, 347.65409106507813131,
        3.495898124521934782e-4];
    const s = [-25.579105509976461286, 212.57260432226544008,
        -610.69018684944109624, 422.69668805777760407];
    const t = [1.6125990452916363814e-10,
        2.5051878502858255354e-8, 2.7557319615147964774e-6,
        1.9841269840928373686e-4, .0083333333333334751799,
        .16666666666666666446];
    const estm = [52.0583, 5.7607, 2.7782, 14.4303, 185.3004, 9.3715];
    const estf = [41.8341, 7.1075, 6.4306, 42.511, 1.35633, 84.5096, 20.];
    let iend;
    let i;
    let j;
    let k;
    let m;
    let ii;
    let mplus1;
    let x2by4;
    let twox;
    let c;
    let blpha;
    let ratio;
    let wminf;
    let d1;
    let d2;
    let d3;
    let f0;
    let f1;
    let f2;
    let p0;
    let q0;
    let t1;
    let t2;
    let twonu;
    let dm;
    let ex;
    let bk1;
    let bk2;
    let nu;
    let bk = new Array(nb).fill(0);
    ii = 0;
    ex = x;
    nu = alpha;
    let ncalc = min(nb, 0) - 2;
    if (nb > 0 && (0. <= nu && nu < 1.) && (1 <= ize && ize <= 2)) {
        for (let cnt = 0; cnt < 1; cnt++) {
            if (ex <= 0 || (ize === 1 && ex > besselConstants.xmax_BESS_K)) {
                if (ex <= 0) {
                    if (ex < 0)
                        _general.ML_ERROR(_general.ME.ME_RANGE, 'K_bessel', printer);
                    bk[0] = ML_POSINF;
                }
                else
                    bk[0] = 0.;
                ncalc = nb;
                return { x: bk[0], nb, ncalc };
            }
            k = 0;
            if (nu < besselConstants.sqxmin_BESS_K) {
                nu = 0.;
            }
            else if (nu > .5) {
                k = 1;
                nu -= 1.;
            }
            twonu = nu + nu;
            iend = nb + k - 1;
            c = nu * nu;
            d3 = -c;
            if (ex <= 1.) {
                d1 = 0.;
                d2 = p[0];
                t1 = 1.;
                t2 = q[0];
                for (i = 2; i <= 7; i += 2) {
                    d1 = c * d1 + p[i - 1];
                    d2 = c * d2 + p[i];
                    t1 = c * t1 + q[i - 1];
                    t2 = c * t2 + q[i];
                }
                d1 = nu * d1;
                t1 = nu * t1;
                f1 = log(ex);
                f0 = a + nu * (p[7] - nu * (d1 + d2) / (t1 + t2)) - f1;
                q0 = exp(-nu * (a - nu * (p[7] + nu * (d1 - d2) / (t1 - t2)) - f1));
                f1 = nu * f0;
                p0 = exp(f1);
                d1 = r[4];
                t1 = 1.;
                for (i = 0; i < 4; ++i) {
                    d1 = c * d1 + r[i];
                    t1 = c * t1 + s[i];
                }
                if (fabs(f1) <= .5) {
                    f1 *= f1;
                    d2 = 0.;
                    for (i = 0; i < 6; ++i) {
                        d2 = f1 * d2 + t[i];
                    }
                    d2 = f0 + f0 * f1 * d2;
                }
                else {
                    d2 = sinh(f1) / nu;
                }
                f0 = d2 - nu * d1 / (t1 * p0);
                if (ex <= 1e-10) {
                    bk[0] = f0 + ex * f0;
                    if (ize === 1) {
                        bk[0] -= ex * bk[0];
                    }
                    ratio = p0 / f0;
                    c = ex * DBL_MAX;
                    if (k !== 0) {
                        ncalc = -1;
                        if (bk[0] >= c / ratio) {
                            return { x: bk[nb - 1], nb, ncalc };
                        }
                        bk[0] = ratio * bk[0] / ex;
                        twonu += 2.;
                        ratio = twonu;
                    }
                    ncalc = 1;
                    if (nb === 1)
                        return { x: bk[nb - 1], nb, ncalc };
                    ncalc = -1;
                    for (i = 1; i < nb; ++i) {
                        if (ratio >= c)
                            return { x: bk[nb - 1], nb, ncalc };
                        bk[i] = ratio / ex;
                        twonu += 2.;
                        ratio = twonu;
                    }
                    ncalc = 1;
                    break;
                }
                else {
                    c = 1.;
                    x2by4 = ex * ex / 4.;
                    p0 = .5 * p0;
                    q0 = .5 * q0;
                    d1 = -1.;
                    d2 = 0.;
                    bk1 = 0.;
                    bk2 = 0.;
                    f1 = f0;
                    f2 = p0;
                    do {
                        d1 += 2.;
                        d2 += 1.;
                        d3 = d1 + d3;
                        c = x2by4 * c / d2;
                        f0 = (d2 * f0 + p0 + q0) / d3;
                        p0 /= d2 - nu;
                        q0 /= d2 + nu;
                        t1 = c * f0;
                        t2 = c * (p0 - d2 * f0);
                        bk1 += t1;
                        bk2 += t2;
                    } while (fabs(t1 / (f1 + bk1)) > DBL_EPSILON ||
                        fabs(t2 / (f2 + bk2)) > DBL_EPSILON);
                    bk1 = f1 + bk1;
                    bk2 = 2. * (f2 + bk2) / ex;
                    if (ize === 2) {
                        d1 = exp(ex);
                        bk1 *= d1;
                        bk2 *= d1;
                    }
                    wminf = estf[0] * ex + estf[1];
                }
            }
            else if (DBL_EPSILON * ex > 1.) {
                ncalc = nb;
                bk1 = 1. / (M_SQRT_2dPI * sqrt(ex));
                return { x: bk1, nb, ncalc };
            }
            else {
                twox = ex + ex;
                blpha = 0.;
                ratio = 0.;
                if (ex <= 4.) {
                    d2 = trunc(estm[0] / ex + estm[1]);
                    m = trunc(d2);
                    d1 = d2 + d2;
                    d2 -= .5;
                    d2 *= d2;
                    for (i = 2; i <= m; ++i) {
                        d1 -= 2.;
                        d2 -= d1;
                        ratio = (d3 + d2) / (twox + d1 - ratio);
                    }
                    d2 = trunc(estm[2] * ex + estm[3]);
                    m = trunc(d2);
                    c = fabs(nu);
                    d3 = c + c;
                    d1 = d3 - 1.;
                    f1 = DBL_MIN;
                    f0 = (2. * (c + d2) / ex + .5 * ex / (c + d2 + 1.)) * DBL_MIN;
                    for (i = 3; i <= m; ++i) {
                        d2 -= 1.;
                        f2 = (d3 + d2 + d2) * f0;
                        blpha = (1. + d1 / d2) * (f2 + blpha);
                        f2 = f2 / ex + f1;
                        f1 = f0;
                        f0 = f2;
                    }
                    f1 = (d3 + 2.) * f0 / ex + f1;
                    d1 = 0.;
                    t1 = 1.;
                    for (i = 1; i <= 7; ++i) {
                        d1 = c * d1 + p[i - 1];
                        t1 = c * t1 + q[i - 1];
                    }
                    p0 = exp(c * (a + c * (p[7] - c * d1 / t1) - log(ex))) / ex;
                    f2 = (c + .5 - ratio) * f1 / ex;
                    bk1 = p0 + (d3 * f0 - f2 + f0 + blpha) / (f2 + f1 + f0) * p0;
                    if (ize === 1) {
                        bk1 *= exp(-ex);
                    }
                    wminf = estf[2] * ex + estf[3];
                }
                else {
                    dm = trunc(estm[4] / ex + estm[5]);
                    m = trunc(dm);
                    d2 = dm - .5;
                    d2 *= d2;
                    d1 = dm + dm;
                    for (i = 2; i <= m; ++i) {
                        dm -= 1.;
                        d1 -= 2.;
                        d2 -= d1;
                        ratio = (d3 + d2) / (twox + d1 - ratio);
                        blpha = (ratio + ratio * blpha) / dm;
                    }
                    bk1 = 1. / ((M_SQRT_2dPI + M_SQRT_2dPI * blpha) * sqrt(ex));
                    if (ize === 1)
                        bk1 *= exp(-ex);
                    wminf = estf[4] * (ex - fabs(ex - estf[6])) + estf[5];
                }
                bk2 = bk1 + bk1 * (nu + .5 - ratio) / ex;
            }
            ncalc = nb;
            bk[0] = bk1;
            if (iend === 0)
                return { x: bk[nb - 1], nb, ncalc };
            j = 1 - k;
            if (j >= 0)
                bk[j] = bk2;
            if (iend === 1)
                return { x: bk[nb - 1], nb, ncalc };
            m = min(trunc(wminf - nu), iend);
            for (i = 2; i <= m; ++i) {
                t1 = bk1;
                bk1 = bk2;
                twonu += 2.;
                if (ex < 1.) {
                    if (bk1 >= DBL_MAX / twonu * ex)
                        break;
                }
                else {
                    if (bk1 / ex >= DBL_MAX / twonu)
                        break;
                }
                bk2 = twonu / ex * bk1 + t1;
                ii = i;
                ++j;
                if (j >= 0) {
                    bk[j] = bk2;
                }
            }
            m = ii;
            if (m === iend) {
                return { x: bk[nb - 1], nb, ncalc };
            }
            ratio = bk2 / bk1;
            mplus1 = m + 1;
            ncalc = -1;
            for (i = mplus1; i <= iend; ++i) {
                twonu += 2.;
                ratio = twonu / ex + 1. / ratio;
                ++j;
                if (j >= 1) {
                    bk[j] = ratio;
                }
                else {
                    if (bk2 >= DBL_MAX / ratio)
                        return { x: bk[nb - 1], nb, ncalc };
                    bk2 *= ratio;
                }
            }
            ncalc = max(1, mplus1 - k);
            if (ncalc === 1)
                bk[0] = bk2;
            if (nb === 1) {
                return { x: bk2, nb, ncalc };
            }
        }
        for (i = ncalc; i < nb; ++i) {
            bk[i] *= bk[i - 1];
            (ncalc)++;
        }
    }
    return { x: bk[nb - 1], nb, ncalc };
}
exports.K_bessel = K_bessel;

});

var besselK = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.internal_bessel_k = exports.bessel_k = void 0;




const { isNaN: ISNAN } = Number;
const { floor } = Math;
const printer = src('bessel_k');
function bessel_k(_x, _alpha, _expo) {
    return rFunc.multiplexer(_x, _alpha, _expo)((x, alpha, expo) => internal_bessel_k(x, alpha, expo));
}
exports.bessel_k = bessel_k;
function internal_bessel_k(x, alpha, expo = false) {
    let nb;
    let ize;
    if (ISNAN(x) || ISNAN(alpha))
        return x + alpha;
    if (x < 0) {
        _general.ML_ERROR(_general.ME.ME_RANGE, 'bessel_k', printer);
        return NaN;
    }
    ize = expo ? 2 : 1;
    if (alpha < 0)
        alpha = -alpha;
    nb = 1 + floor(alpha);
    alpha -= (nb - 1);
    const rc = Kbessel.K_bessel(x, alpha, nb, ize);
    if (rc.ncalc !== rc.nb) {
        if (rc.ncalc < 0)
            printer('bessel_k(%d): ncalc (=%d) != nb (=%d); alpha=%d. Arg. out of range?\n', rc.x, rc.ncalc, rc.nb, alpha);
        else
            printer('bessel_k(%d,nu=%d): precision lost in result\n', rc.x, alpha + rc.nb - 1);
    }
    x = rc.x;
    return x;
}
exports.internal_bessel_k = internal_bessel_k;

});

var gamma_cody = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rf_gamma_cody = void 0;

const { PI: M_PI, log, exp, trunc } = Math;
const { EPSILON: DBL_EPSILON, MIN_VALUE: DBL_MIN, POSITIVE_INFINITY: ML_POSINF } = Number;
function Rf_gamma_cody(x) {
    const sqrtpi = 0.9189385332046727417803297;
    const xbig = 171.624;
    const p = [
        -1.71618513886549492533811,
        24.7656508055759199108314,
        -379.804256470945635097577,
        629.331155312818442661052,
        866.966202790413211295064,
        -31451.2729688483675254357,
        -36144.4134186911729807069,
        66456.1438202405440627855
    ];
    const q = [
        -30.8402300119738975254353,
        315.350626979604161529144,
        -1015.15636749021914166146,
        -3107.77167157231109440444,
        22538.1184209801510330112,
        4755.84627752788110767815,
        -134659.959864969306392456,
        -115132.259675553483497211
    ];
    const c = [
        -0.001910444077728,
        8.4171387781295e-4,
        -5.952379913043012e-4,
        7.93650793500350248e-4,
        -0.002777777777777681622553,
        0.08333333333333333331554247,
        0.0057083835261
    ];
    let i;
    let n;
    let parity;
    let fact;
    let xden;
    let xnum;
    let y;
    let z;
    let yi;
    let res;
    let sum;
    let ysq;
    parity = 0;
    fact = 1;
    n = 0;
    y = x;
    if (y <= 0) {
        y = -x;
        yi = trunc(y);
        res = y - yi;
        if (res !== 0) {
            if (yi !== trunc(yi * 0.5) * 2) {
                parity = 1;
            }
            fact = -M_PI / trigonometry.sinpi(res);
            y += 1;
        }
        else {
            return ML_POSINF;
        }
    }
    if (y < DBL_EPSILON) {
        if (y >= DBL_MIN) {
            res = 1 / y;
        }
        else {
            return ML_POSINF;
        }
    }
    else if (y < 12) {
        yi = y;
        if (y < 1) {
            z = y;
            y += 1;
        }
        else {
            n = trunc(y) - 1;
            y -= n;
            z = y - 1;
        }
        xnum = 0;
        xden = 1;
        for (i = 0; i < 8; ++i) {
            xnum = (xnum + p[i]) * z;
            xden = xden * z + q[i];
        }
        res = xnum / xden + 1;
        if (yi < y) {
            res /= yi;
        }
        else if (yi > y) {
            for (i = 0; i < n; ++i) {
                res *= y;
                y += 1;
            }
        }
    }
    else {
        if (y <= xbig) {
            ysq = y * y;
            sum = c[6];
            for (i = 0; i < 6; ++i) {
                sum = sum / ysq + c[i];
            }
            sum = sum / y - y + sqrtpi;
            sum += (y - 0.5) * log(y);
            res = exp(sum);
        }
        else {
            return ML_POSINF;
        }
    }
    if (parity)
        res = -res;
    if (fact !== 1)
        res = fact / res;
    return res;
}
exports.Rf_gamma_cody = Rf_gamma_cody;

});

var IBessel = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.I_bessel = void 0;



const { sqrt, pow, min, max: fmax, exp, trunc } = Math;
const { POSITIVE_INFINITY: ML_POSINF } = Number;
const printer = src('I_bessel');
function I_bessel(x, alpha, nb, ize) {
    const const__ = 1.585;
    let nend;
    let intx;
    let nbmx;
    let k;
    let l;
    let n;
    let nstart;
    let pold;
    let test;
    let p;
    let em;
    let en;
    let empal;
    let emp2al;
    let halfx;
    let aa;
    let bb;
    let cc;
    let psave;
    let plast;
    let tover;
    let psavel;
    let sum;
    let nu;
    let twonu;
    let ncalc = nb;
    let bi2 = new Array(nb).fill(0);
    nu = alpha;
    twonu = nu + nu;
    if (nb > 0 && x >= 0. && (0. <= nu && nu < 1.) &&
        (1 <= ize && ize <= 2)) {
        ncalc = nb;
        if (ize === 1 && x > besselConstants.exparg_BESS) {
            return { x: ML_POSINF, nb, ncalc };
        }
        if (ize === 2 && x > besselConstants.xlrg_BESS_IJ) {
            return { x: 0., nb, ncalc };
        }
        intx = trunc(x);
        if (x >= besselConstants.rtnsig_BESS) {
            nbmx = nb - intx;
            n = intx + 1;
            en = (n + n) + twonu;
            plast = 1.;
            p = en / x;
            test = besselConstants.ensig_BESS + besselConstants.ensig_BESS;
            if (intx * 2 > besselConstants.nsig_BESS * 5) {
                test = sqrt(test * p);
            }
            else {
                test /= pow(const__, intx);
            }
            let gotoL120 = false;
            if (nbmx >= 3) {
                tover = besselConstants.enten_BESS / besselConstants.ensig_BESS;
                nstart = intx + 2;
                nend = nb - 1;
                for (k = nstart; k <= nend; ++k) {
                    n = k;
                    en += 2.;
                    pold = plast;
                    plast = p;
                    p = en * plast / x + pold;
                    if (p > tover) {
                        tover = besselConstants.enten_BESS;
                        p /= tover;
                        plast /= tover;
                        psave = p;
                        psavel = plast;
                        nstart = n + 1;
                        do {
                            ++n;
                            en += 2.;
                            pold = plast;
                            plast = p;
                            p = en * plast / x + pold;
                        } while (p <= 1.);
                        bb = en / x;
                        test = pold * plast / besselConstants.ensig_BESS;
                        test *= .5 - .5 / (bb * bb);
                        p = plast * tover;
                        --n;
                        en -= 2.;
                        nend = min(nb, n);
                        for (l = nstart; l <= nend; ++l) {
                            ncalc = l - 1;
                            pold = psavel;
                            psavel = psave;
                            psave = en * psavel / x + pold;
                            if (psave * psavel > test) {
                                break;
                            }
                            ncalc = nend;
                        }
                        gotoL120 = true;
                        break;
                    }
                }
                if (gotoL120 === false) {
                    n = nend;
                    en = (n + n) + twonu;
                    test = fmax(test, sqrt(plast * besselConstants.ensig_BESS) * sqrt(p + p));
                }
            }
            if (gotoL120 === false) {
                do {
                    ++n;
                    en += 2.;
                    pold = plast;
                    plast = p;
                    p = en * plast / x + pold;
                } while (p < test);
            }
            ++n;
            en += 2.;
            bb = 0.;
            aa = 1. / p;
            em = n - 1.;
            empal = em + nu;
            emp2al = em - 1. + twonu;
            sum = aa * empal * emp2al / em;
            nend = n - nb;
            let gotoL230 = false;
            for (let cnt = 0; cnt < 1; cnt++) {
                if (nend < 0) {
                    bi2[n - 1] = aa;
                    nend = -nend;
                    for (l = 1; l <= nend; ++l) {
                        bi2[n + l - 1] = 0.;
                    }
                }
                else {
                    if (nend > 0) {
                        for (l = 1; l <= nend; ++l) {
                            --n;
                            en -= 2.;
                            cc = bb;
                            bb = aa;
                            if (nend > 100 && aa > 1e200) {
                                let pow05_to_900 = pow(2, -900);
                                cc = cc * pow05_to_900;
                                bb = bb * pow05_to_900;
                                sum = sum * pow05_to_900;
                            }
                            aa = en * bb / x + cc;
                            em -= 1.;
                            emp2al -= 1.;
                            if (n === 1) {
                                break;
                            }
                            if (n === 2) {
                                emp2al = 1.;
                            }
                            empal -= 1.;
                            sum = (sum + aa * empal) * emp2al / em;
                        }
                    }
                    bi2[n - 1] = aa;
                    if (nb <= 1) {
                        sum = sum + sum + aa;
                        gotoL230 = true;
                        break;
                    }
                    --n;
                    en -= 2.;
                    bi2[n - 1] = en * aa / x + bb;
                    if (n === 1) {
                        break;
                    }
                    em -= 1.;
                    if (n === 2)
                        emp2al = 1.;
                    else
                        emp2al -= 1.;
                    empal -= 1.;
                    sum = (sum + bi2[n - 1] * empal) * emp2al / em;
                }
                nend = n - 2;
                if (nend > 0) {
                    for (l = 1; l <= nend; ++l) {
                        --n;
                        en -= 2.;
                        bi2[n - 1] = en * bi2[n] / x + bi2[n + 1];
                        em -= 1.;
                        if (n === 2)
                            emp2al = 1.;
                        else
                            emp2al -= 1.;
                        empal -= 1.;
                        sum = (sum + bi2[n - 1] * empal) * emp2al / em;
                    }
                }
                bi2[0] = 2. * empal * bi2[1] / x + bi2[2];
            }
            if (gotoL230 === false) {
                sum = sum + sum + bi2[0];
            }
            if (nu !== 0.)
                sum *= (gamma_cody.Rf_gamma_cody(1. + nu) * pow(x * .5, -nu));
            if (ize === 1)
                sum *= exp(-(x));
            aa = besselConstants.enmten_BESS;
            if (sum > 1.)
                aa *= sum;
            for (n = 1; n <= nb; ++n) {
                if (bi2[n - 1] < aa)
                    bi2[n - 1] = 0.;
                else
                    bi2[n - 1] /= sum;
            }
            const rc = { x: bi2[nb - 1], nb, ncalc };
            printer('normalize, devide all  Bi[N] by sum, result:%o', rc);
            return rc;
        }
        else {
            aa = 1.;
            empal = 1. + nu;
            halfx = .5 * x;
            if (nu !== 0.)
                aa = pow(halfx, nu) / gamma_cody.Rf_gamma_cody(empal);
            if (ize === 2)
                aa *= exp(-(x));
            bb = halfx * halfx;
            bi2[0] = aa + aa * bb / empal;
            if (x !== 0. && bi2[0] === 0.)
                ncalc = 0;
            if (nb > 1) {
                if (x === 0.) {
                    for (n = 2; n <= nb; ++n)
                        bi2[n - 1] = 0.;
                }
                else {
                    cc = halfx;
                    tover = (besselConstants.enmten_BESS + besselConstants.enmten_BESS) / x;
                    if (bb !== 0.)
                        tover = besselConstants.enmten_BESS / bb;
                    for (n = 2; n <= nb; ++n) {
                        aa /= empal;
                        empal += 1.;
                        aa *= cc;
                        if (aa <= tover * empal)
                            bi2[n - 1] = aa = 0.;
                        else
                            bi2[n - 1] = aa + aa * bb / empal;
                        if (bi2[n - 1] === 0. && ncalc > n)
                            ncalc = n - 1;
                    }
                }
            }
        }
    }
    else {
        ncalc = min(nb, 0) - 1;
    }
    const rc = { x: bi2[nb - 1], nb, ncalc };
    printer('drop off, result:%o', rc);
    return rc;
}
exports.I_bessel = I_bessel;

});

var besselI = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.internal_bessel_i = exports.bessel_i = void 0;






const { isNaN: ISNAN } = Number;
const { exp, trunc, floor, PI: M_PI } = Math;
const printer = src('bessel_i');
function bessel_i(_x, _alpha, _expo) {
    return rFunc.multiplexer(_x, _alpha, _expo)((x, alpha, expo) => internal_bessel_i(x, alpha, expo));
}
exports.bessel_i = bessel_i;
function internal_bessel_i(x, alpha, expo = false) {
    let nb;
    let ize;
    let na;
    if (ISNAN(x) || ISNAN(alpha))
        return x + alpha;
    if (x < 0) {
        _general.ML_ERROR(_general.ME.ME_RANGE, 'bessel_i', printer);
        return NaN;
    }
    ize = expo ? 2 : 1;
    na = floor(alpha);
    if (alpha < 0) {
        return (internal_bessel_i(x, -alpha, expo) +
            ((alpha === na) ? 0 :
                besselK.internal_bessel_k(x, -alpha, expo) *
                    ((ize === 1) ? 2. : 2. * exp(-2. * x)) / M_PI * sinpi_1.sinpi(-alpha)));
    }
    nb = 1 + trunc(na);
    alpha -= (nb - 1);
    const rc = IBessel.I_bessel(x, alpha, nb, ize);
    if (rc.ncalc !== rc.nb) {
        if (rc.ncalc < 0)
            printer('bessel_i(%d): ncalc (=%d) != nb (=%d); alpha=%d. Arg. out of range?', x, rc.ncalc, rc.nb, alpha);
        else
            printer('bessel_i(%d,nu=%d): precision lost in result\n', rc.x, alpha + rc.nb - 1);
    }
    x = rc.x;
    return x;
}
exports.internal_bessel_i = internal_bessel_i;

});

var Ybessel = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Y_bessel = void 0;




const M_SQRT_2dPI = 0.797884560802865355879892119869;
const M_1_PI = 0.3183098861837907;
const M_PI_2 = 1.5707963267948966;
const { min, trunc, sqrt, sin, cos, log, abs, pow, PI: M_PI } = Math;
const { MIN_VALUE: DBL_MIN, EPSILON: DBL_EPSILON, NEGATIVE_INFINITY: ML_NEGINF, MAX_VALUE: DBL_MAX } = Number;
const printer = src('Y_bessel');
function Y_bessel(x, alpha, nb) {
    const fivpi = 15.707963267948966192;
    const pim5 = .70796326794896619231;
    const ch = [-6.7735241822398840964e-24,
        -6.1455180116049879894e-23, 2.9017595056104745456e-21,
        1.3639417919073099464e-19, 2.3826220476859635824e-18,
        -9.0642907957550702534e-18, -1.4943667065169001769e-15,
        -3.3919078305362211264e-14, -1.7023776642512729175e-13,
        9.1609750938768647911e-12, 2.4230957900482704055e-10,
        1.7451364971382984243e-9, -3.3126119768180852711e-8,
        -8.6592079961391259661e-7, -4.9717367041957398581e-6,
        7.6309597585908126618e-5, .0012719271366545622927,
        .0017063050710955562222, -.07685284084478667369,
        -.28387654227602353814, .92187029365045265648];
    let i;
    let k;
    let na;
    let ncalc;
    let alfa;
    let div;
    let ddiv;
    let even;
    let gamma;
    let term;
    let cosmu;
    let sinmu;
    let b;
    let c;
    let d;
    let e;
    let f;
    let g;
    let h;
    let p;
    let q;
    let r;
    let s;
    let d1;
    let d2;
    let q0;
    let pa;
    let pa1;
    let qa;
    let qa1;
    let en;
    let ya;
    let ya1;
    let twobyx;
    let den;
    let odd;
    let aye;
    let dmu;
    let x2;
    let xna;
    let en1 = ya = ya1 = 0;
    let ex = x;
    let nu = alpha;
    let by = new Array(nb).fill(0);
    if (!(nb > 0 && 0. <= nu && nu < 1.)) {
        printer('violaton: abort nb=%d, nu=%d', nb, nu);
        by[0] = 0.;
        ncalc = min(nb, 0) - 1;
        return { x: 0, nb, ncalc };
    }
    if (ex < DBL_MIN || ex > besselConstants.xlrg_BESS_Y) {
        printer('range issue: x < DBL_MIN but still bigger then 1e8 x=(%d)', ex);
        ncalc = nb;
        if (ex > besselConstants.xlrg_BESS_Y)
            by[0] = 0.;
        else if (ex < DBL_MIN)
            by[0] = ML_NEGINF;
        return { x: by[0], nb, ncalc };
    }
    xna = trunc(nu + .5);
    na = trunc(xna);
    if (na === 1) {
        nu -= xna;
    }
    if (nu === -.5) {
        p = M_SQRT_2dPI / sqrt(ex);
        ya = p * sin(ex);
        ya1 = -p * cos(ex);
    }
    else if (ex < 3.) {
        b = ex * .5;
        d = -log(b);
        f = nu * d;
        e = pow(b, -nu);
        if (abs(nu) < besselConstants.M_eps_sinc)
            c = M_1_PI;
        else
            c = nu / sinpi_1.sinpi(nu);
        if (abs(f) < 1.) {
            x2 = f * f;
            en = 19.;
            s = 1.;
            for (i = 1; i <= 9; ++i) {
                s = s * x2 / en / (en - 1.) + 1.;
                en -= 2.;
            }
        }
        else {
            s = (e - 1. / e) * .5 / f;
        }
        x2 = nu * nu * 8.;
        aye = ch[0];
        even = 0.;
        alfa = ch[1];
        odd = 0.;
        for (i = 3; i <= 19; i += 2) {
            even = -(aye + aye + even);
            aye = -even * x2 - aye + ch[i - 1];
            odd = -(alfa + alfa + odd);
            alfa = -odd * x2 - alfa + ch[i];
        }
        even = (even * .5 + aye) * x2 - aye + ch[20];
        odd = (odd + alfa) * 2.;
        gamma = odd * nu + even;
        g = e * gamma;
        e = (e + 1. / e) * .5;
        f = 2. * c * (odd * e + even * s * d);
        e = nu * nu;
        p = g * c;
        q = M_1_PI / g;
        c = nu * M_PI_2;
        if (abs(c) < besselConstants.M_eps_sinc)
            r = 1.;
        else
            r = sinpi_1.sinpi(nu / 2) / c;
        r = M_PI * c * r * r;
        c = 1.;
        d = -b * b;
        h = 0.;
        ya = f + r * q;
        ya1 = p;
        en = 1.;
        while (abs(g / (1. + abs(ya))) +
            abs(h / (1. + abs(ya1))) > DBL_EPSILON) {
            f = (f * en + p + q) / (en * en - e);
            c *= (d / en);
            p /= en - nu;
            q /= en + nu;
            g = c * (f + r * q);
            h = c * p - en * g;
            ya += g;
            ya1 += h;
            en += 1.;
        }
        ya = -ya;
        ya1 = -ya1 / b;
    }
    else if (ex < besselConstants.thresh_BESS_Y) {
        c = (.5 - nu) * (.5 + nu);
        b = ex + ex;
        e = ex * M_1_PI * cospi_1.cospi(nu) / DBL_EPSILON;
        e *= e;
        p = 1.;
        q = -ex;
        r = 1. + ex * ex;
        s = r;
        en = 2.;
        while (r * en * en < e) {
            en1 = en + 1.;
            d = (en - 1. + c / en) / s;
            p = (en + en - p * d) / en1;
            q = (-b + q * d) / en1;
            s = p * p + q * q;
            r *= s;
            en = en1;
        }
        f = p / s;
        p = f;
        g = -q / s;
        q = g;
        for (;;) {
            en -= 1.;
            if (en > 0.) {
                r = en1 * (2. - p) - 2.;
                s = b + en1 * q;
                d = (en - 1. + c / en) / (r * r + s * s);
                p = d * r;
                q = d * s;
                e = f + 1.;
                f = p * e - g * q;
                g = q * e + p * g;
                en1 = en;
                continue;
            }
            break;
        }
        f = 1. + f;
        d = f * f + g * g;
        pa = f / d;
        qa = -g / d;
        d = nu + .5 - p;
        q += ex;
        pa1 = (pa * q - qa * d) / ex;
        qa1 = (qa * q + pa * d) / ex;
        b = ex - M_PI_2 * (nu + .5);
        c = cos(b);
        s = sin(b);
        d = M_SQRT_2dPI / sqrt(ex);
        ya = d * (pa * s + qa * c);
        ya1 = d * (qa1 * s - pa1 * c);
    }
    else {
        na = 0;
        d1 = trunc(ex / fivpi);
        i = trunc(d1);
        dmu = ex - 15. * d1 - d1 * pim5 - (alpha + .5) * M_PI_2;
        if (i - (i / 2 << 1) === 0) {
            cosmu = cos(dmu);
            sinmu = sin(dmu);
        }
        else {
            cosmu = -cos(dmu);
            sinmu = -sin(dmu);
        }
        ddiv = 8. * ex;
        dmu = alpha;
        den = sqrt(ex);
        for (k = 1; k <= 2; ++k) {
            p = cosmu;
            cosmu = sinmu;
            sinmu = -p;
            d1 = (2. * dmu - 1.) * (2. * dmu + 1.);
            d2 = 0.;
            div = ddiv;
            p = 0.;
            q = 0.;
            q0 = d1 / div;
            term = q0;
            for (i = 2; i <= 20; ++i) {
                d2 += 8.;
                d1 -= d2;
                div += ddiv;
                term = -term * d1 / div;
                p += term;
                d2 += 8.;
                d1 -= d2;
                div += ddiv;
                term *= (d1 / div);
                q += term;
                if (abs(term) <= DBL_EPSILON) {
                    break;
                }
            }
            p += 1.;
            q += q0;
            if (k === 1)
                ya = M_SQRT_2dPI * (p * cosmu - q * sinmu) / den;
            else
                ya1 = M_SQRT_2dPI * (p * cosmu - q * sinmu) / den;
            dmu += 1.;
        }
    }
    if (na === 1) {
        h = 2. * (nu + 1.) / ex;
        if (h > 1.) {
            if (abs(ya1) > DBL_MAX / h) {
                h = 0.;
                ya = 0.;
            }
        }
        h = h * ya1 - ya;
        ya = ya1;
        ya1 = h;
    }
    by[0] = ya;
    ncalc = 1;
    if (nb > 1) {
        by[1] = ya1;
        if (ya1 !== 0.) {
            aye = 1. + alpha;
            twobyx = 2. / ex;
            ncalc = 2;
            for (i = 2; i < nb; ++i) {
                if (twobyx < 1.) {
                    if (abs(by[i - 1]) * twobyx >= DBL_MAX / aye)
                        break;
                }
                else {
                    if (abs(by[i - 1]) >= DBL_MAX / aye / twobyx)
                        break;
                }
                by[i] = twobyx * aye * by[i - 1] - by[i - 2];
                aye += 1.;
                ++(ncalc);
            }
        }
    }
    return { x: by[ncalc - 1], nb, ncalc };
}
exports.Y_bessel = Y_bessel;

});

var besselJ_1 = besselJ;

var besselY = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.internal_bessel_y = exports.bessel_y = void 0;







const { floor } = Math;
const { isNaN: ISNAN, POSITIVE_INFINITY: ML_POSINF } = Number;
const printer = src('bessel_y');
function bessel_y(_x, _alpha) {
    return rFunc.multiplexer(_x, _alpha)((x, alpha) => internal_bessel_y(x, alpha));
}
exports.bessel_y = bessel_y;
function internal_bessel_y(x, alpha) {
    if (ISNAN(x) || ISNAN(alpha))
        return x + alpha;
    if (x < 0) {
        _general.ML_ERROR(_general.ME.ME_RANGE, 'bessel_y', printer);
        return NaN;
    }
    const na = floor(alpha);
    if (alpha < 0) {
        return (((alpha - na === 0.5) ? 0 : internal_bessel_y(x, -alpha) * cospi_1.cospi(alpha)) -
            ((alpha === na) ? 0 : besselJ_1.internal_bessel_j(x, -alpha) * sinpi_1.sinpi(alpha)));
    }
    else if (alpha > 1e7) {
        printer('besselY(x, nu): nu=%d too large for bessel_y() algorithm', alpha);
        return NaN;
    }
    const nb = 1 + na;
    alpha -= (nb - 1);
    const rc = Ybessel.Y_bessel(x, alpha, nb);
    if (rc.ncalc !== nb) {
        if (rc.ncalc === -1) {
            return ML_POSINF;
        }
        else if (rc.ncalc < -1)
            printer('bessel_y(%d): ncalc (=%d) != nb (=%d); alpha=%d. Arg. out of range?\n', rc.x, rc.ncalc, nb, alpha);
        else
            printer('bessel_y(%d,nu=%d): precision lost in result\n', rc.x, alpha + nb - 1);
    }
    x = rc.x;
    return x;
}
exports.internal_bessel_y = internal_bessel_y;

});

var Jbessel = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.J_bessel = void 0;




const { min, trunc, pow, sqrt, sin, cos, max, abs } = Math;
const printer = src('J_bessel');
function J_bessel(x, alpha, nb) {
    const pi2 = .636619772367581343075535;
    const twopi1 = 6.28125;
    const twopi2 = .001935307179586476925286767;
    const fact = [1., 1., 2., 6., 24., 120., 720., 5040., 40320.,
        362880., 3628800., 39916800., 479001600., 6227020800., 87178291200.,
        1.307674368e12, 2.0922789888e13, 3.55687428096e14, 6.402373705728e15,
        1.21645100408832e17, 2.43290200817664e18, 5.109094217170944e19,
        1.12400072777760768e21, 2.585201673888497664e22,
        6.2044840173323943936e23];
    let b2 = new Array(nb).fill(0);
    let i_nend;
    let nbmx;
    let i;
    let j;
    let l;
    let i_m;
    let n;
    let nstart;
    let capp;
    let capq;
    let pold;
    let vcos;
    let test;
    let vsin;
    let p;
    let s;
    let t;
    let z;
    let alpem;
    let halfx;
    let aa;
    let bb;
    let cc;
    let psave;
    let plast;
    let tover;
    let t1;
    let alp2em;
    let em;
    let en;
    let xc;
    let xk;
    let xm;
    let psavel;
    let gnu;
    let xin;
    let sum;
    let ncalc;
    let gotoL190 = false;
    let nu = alpha;
    let twonu = nu + nu;
    if (!(nb > 0 && x >= 0. && 0. <= nu && nu < 1.)) {
        b2[0] = 0.;
        ncalc = min(nb, 0) - 1;
        return { x, nb, ncalc };
    }
    ncalc = nb;
    if (x > besselConstants.xlrg_BESS_IJ) {
        _general.ML_ERROR(_general.ME.ME_RANGE, 'J_bessel', printer);
        return { x: 0, nb, ncalc };
    }
    let intxj = trunc(x);
    if (x < 1 / 10000) {
        printer('x < 0.0001 , x=%d, nb=%d', x, nb);
        alpem = 1. + nu;
        halfx = (x > besselConstants.enmten_BESS) ? .5 * x : 0.;
        aa = (nu !== 0.) ? pow(halfx, nu) / (nu * gamma_cody.Rf_gamma_cody(nu)) : 1.;
        bb = (x + 1. > 1.) ? -halfx * halfx : 0.;
        b2[0] = aa + aa * bb / alpem;
        if (x !== 0. && b2[0] === 0.)
            ncalc = 0;
        if (nb !== 1) {
            if (x <= 0.) {
                for (n = 2; n <= nb; ++n)
                    b2[n - 1] = 0.;
            }
            else {
                if (bb === 0.)
                    tover = (besselConstants.enmten_BESS + besselConstants.enmten_BESS) / x;
                else
                    tover = besselConstants.enmten_BESS / bb;
                cc = halfx;
                for (n = 2; n <= nb; ++n) {
                    aa /= alpem;
                    alpem += 1.;
                    aa *= cc;
                    if (aa <= tover * alpem)
                        aa = 0.;
                    b2[n - 1] = aa + aa * bb / alpem;
                    if (b2[n - 1] === 0. && ncalc > n)
                        ncalc = n - 1;
                }
            }
        }
    }
    else if (x > 25. && nb <= intxj + 1) {
        printer('x > 25 and nb < int(x+1) :x=%d, nb=%d', x, nb);
        xc = sqrt(pi2 / x);
        xin = 1 / (64 * x * x);
        if (x >= 130.)
            i_m = 4;
        else if (x >= 35.)
            i_m = 8;
        else
            i_m = 11;
        xm = 4. * i_m;
        t = trunc(x / (twopi1 + twopi2) + .5);
        z = (x - t * twopi1) - t * twopi2 - (nu + .5) / pi2;
        vsin = sin(z);
        vcos = cos(z);
        gnu = twonu;
        for (i = 1; i <= 2; ++i) {
            s = (xm - 1. - gnu) * (xm - 1. + gnu) * xin * .5;
            t = (gnu - (xm - 3.)) * (gnu + (xm - 3.));
            t1 = (gnu - (xm + 1.)) * (gnu + (xm + 1.));
            let k = i_m + i_m;
            capp = s * t / fact[k];
            capq = s * t1 / fact[k + 1];
            xk = xm;
            for (; k >= 4; k -= 2) {
                xk -= 4.;
                s = (xk - 1. - gnu) * (xk - 1. + gnu);
                t1 = t;
                t = (gnu - (xk - 3.)) * (gnu + (xk - 3.));
                capp = (capp + 1. / fact[k - 2]) * s * t * xin;
                capq = (capq + 1. / fact[k - 1]) * s * t1 * xin;
            }
            capp += 1.;
            capq = (capq + 1.) * (gnu * gnu - 1.) * (.125 / x);
            b2[i - 1] = xc * (capp * vcos - capq * vsin);
            if (nb === 1) {
                return { x: b2[nb - 1], nb, ncalc };
            }
            t = vsin;
            vsin = -vcos;
            vcos = t;
            gnu += 2.;
        }
        if (nb > 2)
            for (gnu = twonu + 2., j = 3; j <= nb; j++, gnu += 2.)
                b2[j - 1] = gnu * b2[j - 1 - 1] / x - b2[j - 2 - 1];
    }
    else {
        printer('rest: x=%d, nb=%d\t', x, nb);
        nbmx = nb - intxj;
        n = intxj + 1;
        en = (n + n) + twonu;
        plast = 1.;
        p = en / x;
        test = besselConstants.ensig_BESS + besselConstants.ensig_BESS;
        if (nbmx >= 3) {
            tover = besselConstants.enten_BESS / besselConstants.ensig_BESS;
            nstart = intxj + 2;
            i_nend = nb - 1;
            en = (nstart + nstart) - 2. + twonu;
            for (let k = nstart; k <= i_nend; ++k) {
                n = k;
                en += 2.;
                pold = plast;
                plast = p;
                p = en * plast / x - pold;
                if (p > tover) {
                    tover = besselConstants.enten_BESS;
                    p /= tover;
                    plast /= tover;
                    psave = p;
                    psavel = plast;
                    nstart = n + 1;
                    do {
                        ++n;
                        en += 2.;
                        pold = plast;
                        plast = p;
                        p = en * plast / x - pold;
                    } while (p <= 1.);
                    bb = en / x;
                    test = pold * plast * (.5 - .5 / (bb * bb));
                    test /= besselConstants.ensig_BESS;
                    p = plast * tover;
                    --n;
                    en -= 2.;
                    i_nend = min(nb, n);
                    for (l = nstart; l <= i_nend; ++l) {
                        pold = psavel;
                        psavel = psave;
                        psave = en * psavel / x - pold;
                        if (psave * psavel > test) {
                            ncalc = l - 1;
                            break;
                        }
                        ncalc = l;
                    }
                    gotoL190 = true;
                    break;
                }
            }
            n = i_nend;
            en = (n + n) + twonu;
            test = max(test, sqrt(plast * besselConstants.ensig_BESS) * sqrt(p + p));
        }
        if (!gotoL190) {
            do {
                ++n;
                en += 2.;
                pold = plast;
                plast = p;
                p = en * plast / x - pold;
            } while (p < test);
        }
        ++n;
        en += 2.;
        bb = 0.;
        aa = 1. / p;
        em = i_m = n >> 1;
        i_m = (n << 1) - (i_m << 2);
        if (i_m === 0)
            sum = 0.;
        else {
            alpem = em - 1. + nu;
            alp2em = em + em + nu;
            sum = aa * alpem * alp2em / em;
        }
        i_nend = n - nb;
        for (l = 1; l <= i_nend; ++l) {
            --n;
            en -= 2.;
            cc = bb;
            bb = aa;
            aa = en * bb / x - cc;
            i_m = i_m ? 0 : 2;
            if (i_m !== 0) {
                em -= 1.;
                alp2em = em + em + nu;
                if (n === 1)
                    break;
                alpem = em - 1. + nu;
                if (alpem === 0.)
                    alpem = 1.;
                sum = (sum + aa * alp2em) * alpem / em;
            }
        }
        b2[n - 1] = aa;
        let gotoL240 = false;
        let gotoL250 = false;
        for (let cnt = 1; cnt > 0; cnt--) {
            if (i_nend >= 0) {
                if (nb <= 1) {
                    if (nu + 1. === 1.)
                        alp2em = 1.;
                    else
                        alp2em = nu;
                    sum += b2[0] * alp2em;
                    gotoL250 = true;
                    break;
                }
                else {
                    --n;
                    en -= 2.;
                    b2[n - 1] = en * aa / x - bb;
                    if (n === 1) {
                        gotoL240 = true;
                        break;
                    }
                    i_m = i_m ? 0 : 2;
                    if (i_m !== 0) {
                        em -= 1.;
                        alp2em = em + em + nu;
                        alpem = em - 1. + nu;
                        if (alpem === 0.)
                            alpem = 1.;
                        sum = (sum + b2[n - 1] * alp2em) * alpem / em;
                    }
                }
            }
        }
        if (gotoL250 === false && gotoL240 === false) {
            for (n = n - 1; n >= 2; n--) {
                en -= 2.;
                b2[n - 1] = en * b2[n + 1 - 1] / x - b2[n + 2 - 1];
                i_m = i_m ? 0 : 2;
                if (i_m !== 0) {
                    em -= 1.;
                    alp2em = em + em + nu;
                    alpem = em - 1. + nu;
                    if (alpem === 0.)
                        alpem = 1.;
                    sum = (sum + b2[n - 1] * alp2em) * alpem / em;
                }
            }
            b2[0] = 2. * (nu + 1.) * b2[1] / x - b2[2];
        }
        if (gotoL250 === false) {
            em -= 1.;
            alp2em = em + em + nu;
            if (alp2em === 0.)
                alp2em = 1.;
            sum += b2[0] * alp2em;
        }
        if (abs(nu) > 1e-15)
            sum *= (gamma_cody.Rf_gamma_cody(nu) * pow(.5 * x, -nu));
        aa = besselConstants.enmten_BESS;
        if (sum > 1.)
            aa *= sum;
        for (n = 1; n <= nb; ++n) {
            if (abs(b2[n - 1]) < aa)
                b2[n - 1] = 0.;
            else
                b2[n - 1] /= sum;
        }
    }
    return { x: b2[nb - 1], nb, ncalc };
}
exports.J_bessel = J_bessel;

});

var besselJ = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.internal_bessel_j = exports.bessel_j = void 0;







const { isNaN: ISNAN } = Number;
const { floor, trunc } = Math;
const printer = src('bessel_j');
function bessel_j(_x, _alpha) {
    return rFunc.multiplexer(_x, _alpha)((x, alpha) => internal_bessel_j(x, alpha));
}
exports.bessel_j = bessel_j;
function internal_bessel_j(x, alpha) {
    let nb;
    let na;
    if (ISNAN(x) || ISNAN(alpha))
        return x + alpha;
    if (x < 0) {
        _general.ML_ERROR(_general.ME.ME_RANGE, 'bessel_j', printer);
        return NaN;
    }
    na = floor(alpha);
    if (alpha < 0) {
        return (((alpha - na === 0.5) ? 0 : internal_bessel_j(x, -alpha) * cospi_1.cospi(alpha)) +
            ((alpha === na) ? 0 : besselY.internal_bessel_y(x, -alpha) * sinpi_1.sinpi(alpha)));
    }
    else if (alpha > 1e7) {
        printer('besselJ(x, nu): nu=%d too large for bessel_j() algorithm', alpha);
        return NaN;
    }
    nb = 1 + trunc(na);
    alpha -= (nb - 1);
    const rc = Jbessel.J_bessel(x, alpha, nb);
    if (rc.ncalc !== nb) {
        if (rc.ncalc < 0)
            printer('bessel_j(%d): ncalc (=%d) != nb (=%d); alpha=%d. Arg. out of range?', x, rc.ncalc, rc.nb, alpha);
        else
            printer('bessel_j(%d,nu=%d): precision lost in result', x, alpha + nb - 1);
    }
    x = rc.x;
    return x;
}
exports.internal_bessel_j = internal_bessel_j;

});

var bessel = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.special = void 0;




exports.special = Object.freeze({
    besselJ: besselJ_1.bessel_j,
    besselY: besselY.bessel_y,
    besselK: besselK.bessel_k,
    besselI: besselI.bessel_i
});

});

var common = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.special = void 0;

exports.special = {
    choose: choose_1.choose,
    lchoose: choose_1.lchoose
};

});

var dist$1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.R = exports.special = exports.Wilcoxon = exports.Weibull = exports.Uniform = exports.Tukey = exports.StudentT = exports.SignRank = exports.IRNGNormal = exports.IRNG = exports.rng = exports.Poisson = exports.Normal = exports.Multinomial = exports.LogNormal = exports.Logistic = exports.HyperGeometric = exports.Geometric = exports.Gamma = exports.FDist = exports.Exponential = exports.ChiSquared = exports.ChebyshevSeries = exports.Cauchy = exports.NegativeBinomial = exports.Binomial = exports.Beta = void 0;

Object.defineProperty(exports, "Beta", { enumerable: true, get: function () { return beta.Beta; } });

Object.defineProperty(exports, "Binomial", { enumerable: true, get: function () { return binomial.Binomial; } });

Object.defineProperty(exports, "NegativeBinomial", { enumerable: true, get: function () { return binomialNegative.NegativeBinomial; } });

Object.defineProperty(exports, "Cauchy", { enumerable: true, get: function () { return cauchy.Cauchy; } });

Object.defineProperty(exports, "ChebyshevSeries", { enumerable: true, get: function () { return chebyshev.ChebyshevSeries; } });

Object.defineProperty(exports, "ChiSquared", { enumerable: true, get: function () { return chi2.ChiSquared; } });

Object.defineProperty(exports, "Exponential", { enumerable: true, get: function () { return exp.Exponential; } });

Object.defineProperty(exports, "FDist", { enumerable: true, get: function () { return fDistro.FDist; } });

Object.defineProperty(exports, "Gamma", { enumerable: true, get: function () { return gamma.Gamma; } });

Object.defineProperty(exports, "Geometric", { enumerable: true, get: function () { return geometric.Geometric; } });

Object.defineProperty(exports, "HyperGeometric", { enumerable: true, get: function () { return hypergeometric.HyperGeometric; } });

Object.defineProperty(exports, "Logistic", { enumerable: true, get: function () { return logis.Logistic; } });

Object.defineProperty(exports, "LogNormal", { enumerable: true, get: function () { return lognormal.LogNormal; } });

Object.defineProperty(exports, "Multinomial", { enumerable: true, get: function () { return multinom.Multinomial; } });

Object.defineProperty(exports, "Normal", { enumerable: true, get: function () { return normal.Normal; } });

Object.defineProperty(exports, "Poisson", { enumerable: true, get: function () { return poisson.Poisson; } });

Object.defineProperty(exports, "rng", { enumerable: true, get: function () { return rng.rng; } });
Object.defineProperty(exports, "IRNG", { enumerable: true, get: function () { return rng.IRNG; } });
Object.defineProperty(exports, "IRNGNormal", { enumerable: true, get: function () { return rng.IRNGNormal; } });

Object.defineProperty(exports, "SignRank", { enumerable: true, get: function () { return signrank.SignRank; } });

Object.defineProperty(exports, "StudentT", { enumerable: true, get: function () { return studentT.StudentT; } });

Object.defineProperty(exports, "Tukey", { enumerable: true, get: function () { return tukey.Tukey; } });

Object.defineProperty(exports, "Uniform", { enumerable: true, get: function () { return uniform.Uniform; } });

Object.defineProperty(exports, "Weibull", { enumerable: true, get: function () { return weibull.Weibull; } });

Object.defineProperty(exports, "Wilcoxon", { enumerable: true, get: function () { return wilcoxon.Wilcoxon; } });

const beta_2 = beta;

const gamma_2 = gamma;
exports.special = Object.freeze(Object.assign(Object.assign(Object.assign(Object.assign({}, gamma_2.special), beta_2.special), common.special), bessel.special));

exports.R = {
    any: rFunc.any,
    arrayrify: rFunc.arrayrify,
    asArray: rFunc.asArray,
    div: rFunc.div,
    flatten: rFunc.flatten,
    isOdd: rFunc.isOdd,
    map: rFunc.map,
    each: rFunc.each,
    mult: rFunc.mult,
    multiplex: rFunc.multiplex,
    multiplexer: rFunc.multiplexer,
    numberPrecision: rFunc.numberPrecision,
    selector: rFunc.selector,
    seq: rFunc.seq,
    sum: rFunc.sum,
    summary: rFunc.summary,
    Welch_Satterthwaite: rFunc.Welch_Satterthwaite,
    c: rFunc.flatten
};

});

var DistributionType_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var DistributionType;
(function (DistributionType) {
    DistributionType[DistributionType["Beta"] = 0] = "Beta";
    DistributionType[DistributionType["BimodalTruncatedNormal"] = 1] = "BimodalTruncatedNormal";
    DistributionType[DistributionType["Constant"] = 2] = "Constant";
    DistributionType[DistributionType["Discrete"] = 3] = "Discrete";
    DistributionType[DistributionType["Gamma"] = 4] = "Gamma";
    DistributionType[DistributionType["LogNormal"] = 5] = "LogNormal";
    DistributionType[DistributionType["LogUniform"] = 6] = "LogUniform";
    DistributionType[DistributionType["Normal"] = 7] = "Normal";
    DistributionType[DistributionType["Pert"] = 8] = "Pert";
    DistributionType[DistributionType["PiecewiseUniform"] = 9] = "PiecewiseUniform";
    DistributionType[DistributionType["ScaledBeta"] = 10] = "ScaledBeta";
    DistributionType[DistributionType["ScaledTruncatedBeta"] = 11] = "ScaledTruncatedBeta";
    DistributionType[DistributionType["Triangle"] = 12] = "Triangle";
    DistributionType[DistributionType["TruncatedBeta"] = 13] = "TruncatedBeta";
    DistributionType[DistributionType["TruncatedGamma"] = 14] = "TruncatedGamma";
    DistributionType[DistributionType["TruncatedLogNormal"] = 15] = "TruncatedLogNormal";
    DistributionType[DistributionType["TruncatedNormal"] = 16] = "TruncatedNormal";
    DistributionType[DistributionType["Uniform"] = 17] = "Uniform";
    DistributionType[DistributionType["Weibull"] = 18] = "Weibull";
})(DistributionType || (DistributionType = {}));
exports.default = DistributionType;

});

var BetaDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.Beta)(), dbeta = _a.dbeta, pbeta = _a.pbeta, qbeta = _a.qbeta;
var BetaDistribution = /** @class */ (function () {
    function BetaDistribution(alpha, beta) {
        this.Type = DistributionType_1$1.default.Beta;
        this.Min = 0.0;
        this.Max = 1.0;
        this.Alpha = alpha;
        this.Beta = beta;
    }
    Object.defineProperty(BetaDistribution.prototype, "Mean", {
        get: function () {
            return this.Alpha / (this.Alpha + this.Beta);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BetaDistribution.prototype, "Mode", {
        get: function () {
            if (this.Alpha > 1 && this.Beta > 1) {
                return (this.Alpha - 1) / (this.Alpha + this.Beta - 2);
            }
            if (this.Alpha <= 1 && this.Beta > 1) {
                return 0.0;
            }
            if (this.Alpha < 1 && this.Beta < 1) {
                return 0.0; // this case is bimodal, 0.0 or 1.0 would be valid
            }
            if (this.Beta <= 1 && this.Alpha > 1) {
                return 1.0;
            }
            return 0.5;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BetaDistribution.prototype, "StdDev", {
        get: function () {
            return Math.sqrt(((this.Alpha * this.Beta) / Math.pow((this.Alpha + this.Beta), 2)) * (this.Alpha + this.Beta + 1));
        },
        enumerable: false,
        configurable: true
    });
    BetaDistribution.prototype.PDF = function (x) {
        if (this.Alpha === undefined || this.Beta === undefined) {
            throw new Error('Trying to get PDF from undefined distribution');
        }
        if (x < 0.0) {
            return 0.0;
        }
        if (x > 1.0) {
            return 0.0;
        }
        var val = dbeta(x, this.Alpha, this.Beta, 0);
        if (val == undefined) {
            throw new Error('Multiple return numbers from beta function call');
        }
        return val;
    };
    BetaDistribution.prototype.CDF = function (x) {
        if (this.Alpha === undefined || this.Beta === undefined) {
            throw new Error('Trying to get CDF from undefined distribution');
        }
        if (x < 0.0) {
            return 0.0;
        }
        if (x > 1.0) {
            return 1.0;
        }
        return pbeta(x, this.Alpha, this.Beta);
    };
    BetaDistribution.prototype.PPF = function (percentile) {
        if (this.Alpha === undefined || this.Beta === undefined) {
            throw new Error('Trying to get PPF from undefined distribution');
        }
        if (percentile < 0.0) {
            return 0.0;
        }
        if (percentile > 1.0) {
            return 1.0;
        }
        return qbeta(percentile, this.Alpha, this.Beta);
    };
    Object.defineProperty(BetaDistribution.prototype, "IsValid", {
        get: function () {
            return this.Alpha > 0 && this.Beta > 0;
        },
        enumerable: false,
        configurable: true
    });
    return BetaDistribution;
}());
exports.default = BetaDistribution;

});

var BimodalTruncatedNormalDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.Normal)(), dnorm = _a.dnorm, pnorm = _a.pnorm, qnorm = _a.qnorm;
var BimodalTruncatedNormalDistribution = /** @class */ (function () {
    function BimodalTruncatedNormalDistribution(mean1, stdDev1, mean2, stdDev2, min, max) {
        this.Type = DistributionType_1$1.default.BimodalTruncatedNormal;
        this.Mean = mean1;
        this.StdDev = stdDev1;
        this.Mean2 = mean2;
        this.StdDev2 = stdDev2;
        this.Min = min;
        this.Max = max;
    }
    Object.defineProperty(BimodalTruncatedNormalDistribution.prototype, "Mode", {
        get: function () {
            if (this.Mean < this.Min)
                return this.Min;
            if (this.Mean > this.Max)
                return this.Max;
            return this.Mean;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BimodalTruncatedNormalDistribution.prototype, "Mode2", {
        get: function () {
            if (this.Mean2 < this.Min)
                return this.Min;
            if (this.Mean2 > this.Max)
                return this.Max;
            return this.Mean2;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BimodalTruncatedNormalDistribution.prototype, "IsValid", {
        get: function () {
            return this.StdDev > 0 && this.StdDev2 > 0 && this.Max > this.Min;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BimodalTruncatedNormalDistribution.prototype, "PMin", {
        get: function () {
            if (this._PMin === undefined) {
                this._PMin = pnorm(this.Min, this.Mean, this.StdDev);
            }
            return this._PMin;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BimodalTruncatedNormalDistribution.prototype, "PMax", {
        get: function () {
            if (this._PMax === undefined) {
                this._PMax = pnorm(this.Max, this.Mean, this.StdDev);
            }
            return this._PMax;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BimodalTruncatedNormalDistribution.prototype, "PMin2", {
        get: function () {
            if (this._PMin2 === undefined) {
                this._PMin2 = pnorm(this.Min, this.Mean2, this.StdDev2);
            }
            return this._PMin2;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BimodalTruncatedNormalDistribution.prototype, "PMax2", {
        get: function () {
            if (this._PMax2 === undefined) {
                this._PMax2 = pnorm(this.Max, this.Mean2, this.StdDev2);
            }
            return this._PMax2;
        },
        enumerable: false,
        configurable: true
    });
    BimodalTruncatedNormalDistribution.prototype.PDF = function (x) {
        if (x < this.Min || x > this.Max) {
            return 0.0;
        }
        var firstNorm = dnorm(x, this.Mean, this.StdDev, false) / (this.PMax - this.PMin);
        var secondNorm = dnorm(x, this.Mean2, this.StdDev2, false) / (this.PMax2 - this.PMin2);
        // assumes distributions are of equal weight
        return (firstNorm + secondNorm) / 2.0;
    };
    BimodalTruncatedNormalDistribution.prototype.CDF = function (x) {
        if (x <= this.Min) {
            return 0.0;
        }
        if (x >= this.Max) {
            return 1.0;
        }
        var firstNorm = (pnorm(x, this.Mean, this.StdDev) - this.PMin) / (this.PMax - this.PMin);
        var secondNorm = (pnorm(x, this.Mean2, this.StdDev2) - this.PMin2) / (this.PMax2 - this.PMin2);
        // assumes distributions are of equal weight
        return (firstNorm + secondNorm) / 2.0;
    };
    BimodalTruncatedNormalDistribution.prototype.PPF = function (percentile) {
        if (percentile <= 0.0) {
            return this.Min;
        }
        if (percentile >= 1.0) {
            return this.Max;
        }
        var firstNorm = qnorm(percentile * (this.PMax - this.PMin) + this.PMin, this.Mean, this.StdDev);
        var secondNorm = qnorm(percentile * (this.PMax2 - this.PMin2) + this.PMin2, this.Mean2, this.StdDev2);
        // assumes distributions are of equal weight
        return (firstNorm + secondNorm) / 2.0;
    };
    return BimodalTruncatedNormalDistribution;
}());
exports.default = BimodalTruncatedNormalDistribution;

});

var ConstantDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var ConstantDistribution = /** @class */ (function () {
    function ConstantDistribution(value) {
        this.Type = DistributionType_1$1.default.Constant;
        this.IsValid = true;
        this.value = value;
    }
    Object.defineProperty(ConstantDistribution.prototype, "Min", {
        get: function () {
            return this.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConstantDistribution.prototype, "Max", {
        get: function () {
            return this.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConstantDistribution.prototype, "Mean", {
        get: function () {
            return this.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConstantDistribution.prototype, "Mode", {
        get: function () {
            return this.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConstantDistribution.prototype, "StdDev", {
        get: function () {
            if (this.value === 0.0) {
                return 1.0;
            }
            return Math.abs(this.value) / ConstantDistribution.DeviationModifier;
        },
        enumerable: false,
        configurable: true
    });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ConstantDistribution.prototype.PPF = function (percentile) {
        if (this.value === undefined) {
            throw new Error('Trying to get value from undefined distribution');
        }
        return this.value;
    };
    ConstantDistribution.prototype.PDF = function (x) {
        if (this.value === undefined) {
            throw new Error('Trying to get value from undefined distribution');
        }
        return x === this.value ? 1.0 : 0.0;
    };
    ConstantDistribution.prototype.CDF = function (x) {
        if (this.value === undefined) {
            throw new Error('Trying to get value from undefined distribution');
        }
        return x >= this.value ? 1.0 : 0.0;
    };
    ConstantDistribution.DeviationModifier = 5.0;
    return ConstantDistribution;
}());
exports.default = ConstantDistribution;

});

var DiscreteDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var DiscreteDistribution = /** @class */ (function () {
    function DiscreteDistribution(values, probabilities) {
        this.Type = DistributionType_1$1.default.Discrete;
        this.StdDev = 1;
        this.Values = values;
        this.Probabilities = probabilities;
        this.CumulativeProbabilities = [];
        this.NormalizeProbabilities();
        this.Sort();
        this.CumulateSum();
    }
    Object.defineProperty(DiscreteDistribution.prototype, "Mode", {
        get: function () {
            throw new Error('Method not implemented');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DiscreteDistribution.prototype, "IsValid", {
        get: function () {
            return this.Values.length === this.Probabilities.length && this.Values.length >= 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DiscreteDistribution.prototype, "Max", {
        get: function () {
            return this.Values.reduce(function (a, b) {
                return Math.max(a, b);
            });
            //if values have been sorted then this.Values[this.Values.length -1] would be the max
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DiscreteDistribution.prototype, "Min", {
        get: function () {
            return this.Values.reduce(function (a, b) {
                return Math.min(a, b);
            });
            //if values have been sorted then this.Values[0] would be the min
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DiscreteDistribution.prototype, "Mean", {
        get: function () {
            var mean = 0.0;
            for (var i = 0; i < this.Values.length; i++) {
                mean += this.Values[i] * this.Probabilities[i];
            }
            return mean;
        },
        enumerable: false,
        configurable: true
    });
    DiscreteDistribution.prototype.PDF = function (x) {
        for (var i = 0; i < this.Values.length; i++) {
            if (Math.abs(this.Values[i] - x) < 1e-6)
                return this.Probabilities[i];
        }
        throw new Error('Value ' + x + 'is not in the discrete distribution');
    };
    DiscreteDistribution.prototype.CDF = function (x) {
        if (x < this.Values[0]) {
            return 0.0;
        }
        for (var i = 0; i < this.CumulativeProbabilities.length; i++) {
            if (this.Values[i] >= x)
                return this.CumulativeProbabilities[i];
        }
        return 1.0;
    };
    DiscreteDistribution.prototype.PPF = function (percentile) {
        for (var i = 0; i < this.CumulativeProbabilities.length; i++) {
            if (this.CumulativeProbabilities[i] >= percentile)
                return this.Values[i];
        }
        return this.Values[this.Values.length - 1];
    };
    DiscreteDistribution.prototype.CumulateSum = function () {
        var cumulativeSum = (function (sum) { return function (value) { return (sum += value); }; })(0);
        this.CumulativeProbabilities = this.Probabilities.map(cumulativeSum);
    };
    DiscreteDistribution.prototype.NormalizeProbabilities = function () {
        var _this = this;
        var sum = this.Probabilities.reduce(function (a, b) {
            return a + b;
        }, 0);
        var normalize = function (value, index) { return (_this.Probabilities[index] = value / sum); };
        this.Probabilities.forEach(normalize);
    };
    DiscreteDistribution.prototype.Sort = function () {
        var _this = this;
        var valueSort = function (a, b) {
            return a - b;
        };
        var probabilitySort = function (a, b) {
            return _this.Values[_this.Probabilities.indexOf(a)] - _this.Values[_this.Probabilities.indexOf(b)];
        };
        this.Probabilities.sort(probabilitySort);
        this.Values.sort(valueSort);
    };
    return DiscreteDistribution;
}());
exports.default = DiscreteDistribution;

});

var GammaDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.Gamma)(), dgamma = _a.dgamma, pgamma = _a.pgamma, qgamma = _a.qgamma;
var GammaDistribution = /** @class */ (function () {
    function GammaDistribution(shape, scale) {
        this.Type = DistributionType_1$1.default.Gamma;
        //Rate is undefined since Scale is used here, but it is a positional argmunet in the Rmath gamme funcitons before Scale so it must be supplied
        //If Rate is used instead of Scale, then the mean and stdDev need to be changed.
        this.Rate = undefined;
        this.Min = 0.0;
        this.Max = Infinity;
        this.Shape = shape;
        this.Scale = scale;
    }
    Object.defineProperty(GammaDistribution.prototype, "IsValid", {
        get: function () {
            return this.Shape > 0 && this.Scale > 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GammaDistribution.prototype, "Mean", {
        get: function () {
            return this.Shape * this.Scale;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GammaDistribution.prototype, "Mode", {
        get: function () {
            if (this.Shape >= 1) {
                return (this.Shape - 1) * this.Scale;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GammaDistribution.prototype, "StdDev", {
        get: function () {
            return Math.sqrt(this.Shape * Math.pow(this.Scale, 2));
        },
        enumerable: false,
        configurable: true
    });
    GammaDistribution.prototype.PDF = function (x) {
        if (x < 0.0) {
            //if x = 0, dgamma will return Infinity
            return 0.0;
        }
        return dgamma(x, this.Shape, this.Rate, this.Scale);
    };
    GammaDistribution.prototype.CDF = function (x) {
        if (x < this.Min) {
            return 0.0;
        }
        if (x >= this.Max) {
            return 1.0;
        }
        return pgamma(x, this.Shape, this.Rate, this.Scale);
    };
    GammaDistribution.prototype.PPF = function (percentile) {
        if (percentile <= 0.0) {
            return this.Min;
        }
        if (percentile >= 1.0) {
            return this.Max;
        }
        return qgamma(percentile, this.Shape, this.Rate, this.Scale);
    };
    return GammaDistribution;
}());
exports.default = GammaDistribution;

});

var LogNormalDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.LogNormal)(), dlnorm = _a.dlnorm, plnorm = _a.plnorm, qlnorm = _a.qlnorm;
var LogNormalDistribution = /** @class */ (function () {
    function LogNormalDistribution(LogMean, LogStdDev) {
        this.Type = DistributionType_1$1.default.LogNormal;
        this.Min = -Infinity;
        this.Max = Infinity;
        this.LogMean = LogMean;
        this.LogStdDev = LogStdDev;
    }
    Object.defineProperty(LogNormalDistribution.prototype, "Mean", {
        get: function () {
            return Math.exp(this.LogMean + Math.pow(this.LogStdDev, 2) / 2);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogNormalDistribution.prototype, "Mode", {
        get: function () {
            return Math.exp(this.LogMean - this.LogStdDev);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogNormalDistribution.prototype, "StdDev", {
        get: function () {
            return Math.sqrt(Math.exp(Math.pow(this.LogStdDev, 2)) - 1) * Math.exp(2 * this.LogMean + Math.pow(this.LogStdDev, 2));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogNormalDistribution.prototype, "IsDefined", {
        get: function () {
            throw new Error('Method not implemented.');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogNormalDistribution.prototype, "IsValid", {
        get: function () {
            return this.StdDev > 0 && this.Min <= this.Mode && this.Mode <= this.Max;
        },
        enumerable: false,
        configurable: true
    });
    LogNormalDistribution.prototype.PDF = function (x) {
        return dlnorm(x, this.LogMean, this.LogStdDev, false);
    };
    LogNormalDistribution.prototype.CDF = function (x) {
        return plnorm(x, this.LogMean, this.LogStdDev);
    };
    LogNormalDistribution.prototype.PPF = function (percentile) {
        if (percentile < 0.0) {
            return 0.0;
        }
        if (percentile > 1.0) {
            return 1.0;
        }
        return qlnorm(percentile, this.LogMean, this.LogStdDev);
    };
    return LogNormalDistribution;
}());
exports.default = LogNormalDistribution;

});

var LogUniformDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var LogUniformDistribution = /** @class */ (function () {
    function LogUniformDistribution(Min, Max) {
        this.Type = DistributionType_1$1.default.LogUniform;
        this.Min = Min;
        this.Max = Max;
    }
    Object.defineProperty(LogUniformDistribution.prototype, "Mean", {
        get: function () {
            return Math.pow(((Math.log10(this.Min) + Math.log10(this.Max)) * 0.5), 10);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogUniformDistribution.prototype, "Mode", {
        get: function () {
            return this.Mean;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogUniformDistribution.prototype, "StdDev", {
        get: function () {
            return Math.sqrt((Math.pow(this.Max, 2) - Math.pow(this.Min, 2)) / (2 * Math.log(this.Max / this.Min)) -
                Math.pow(((this.Max - this.Min) / Math.log(this.Max / this.Min)), 2));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogUniformDistribution.prototype, "IsValid", {
        get: function () {
            return this.Min <= this.Max;
        },
        enumerable: false,
        configurable: true
    });
    LogUniformDistribution.prototype.PDF = function (x) {
        if (x >= this.Min && x <= this.Max) {
            return 1 / (x * Math.log(this.Max / this.Min));
        }
        return 0.0;
    };
    LogUniformDistribution.prototype.CDF = function (x) {
        var Result;
        if (x >= this.Max)
            Result = 1;
        else if (x <= this.Min)
            //Needs to come after the first check.  We want the value to equal one in the case that min == max == value.
            Result = 0;
        else {
            var Difference = Math.log10(this.Max) - Math.log10(this.Min);
            Result = (Math.log10(x) - Math.log10(this.Min)) / Difference;
        }
        return Result;
    };
    LogUniformDistribution.prototype.PPF = function (percentile) {
        if (percentile <= 0)
            return this.Min;
        if (percentile >= 1)
            return this.Max;
        var Difference = Math.log10(this.Max) - Math.log10(this.Min);
        return Math.pow(10, (Difference * percentile + Math.log10(this.Min)));
    };
    return LogUniformDistribution;
}());
exports.default = LogUniformDistribution;

});

var NormalDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.Normal)(), dnorm = _a.dnorm, pnorm = _a.pnorm, qnorm = _a.qnorm;
var NormalDistribution = /** @class */ (function () {
    function NormalDistribution(Mean, StdDev) {
        this.Type = DistributionType_1$1.default.Normal;
        this.Min = -Infinity;
        this.Max = Infinity;
        this.Mean = Mean;
        this.StdDev = StdDev;
    }
    Object.defineProperty(NormalDistribution.prototype, "Mode", {
        get: function () {
            return this.Mean;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NormalDistribution.prototype, "IsValid", {
        get: function () {
            return this.StdDev > 0;
        },
        enumerable: false,
        configurable: true
    });
    NormalDistribution.prototype.PDF = function (x) {
        return dnorm(x, this.Mean, this.StdDev, false);
    };
    NormalDistribution.prototype.CDF = function (x) {
        return pnorm(x, this.Mean, this.StdDev);
    };
    NormalDistribution.prototype.PPF = function (percentile) {
        if (percentile < 0.0) {
            return 0.0;
        }
        if (percentile > 1.0) {
            return 1.0;
        }
        return qnorm(percentile, this.Mean, this.StdDev);
    };
    return NormalDistribution;
}());
exports.default = NormalDistribution;

});

var PertDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

var BetaDistribution_1$1 = tslib_es6.__importDefault(BetaDistribution_1);
var ConstantDistribution_1$1 = tslib_es6.__importDefault(ConstantDistribution_1);
var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var PertDistribution = /** @class */ (function () {
    function PertDistribution(Mode, Min, Max) {
        this.Type = DistributionType_1$1.default.Pert;
        this.Min = Min;
        this.Max = Max;
        this.Mode = Mode;
    }
    Object.defineProperty(PertDistribution.prototype, "ChildDist", {
        get: function () {
            if (this.storedChild) {
                return this.storedChild;
            }
            if (this.Min == this.Max) {
                this.storedChild = new ConstantDistribution_1$1.default(this.Min);
            }
            else {
                this.storedChild = new BetaDistribution_1$1.default(PertDistribution.Alpha(this.Mode, this.Min, this.Max), PertDistribution.Beta(this.Mode, this.Min, this.Max));
            }
            return this.storedChild;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PertDistribution.prototype, "Mean", {
        get: function () {
            return this.Min + this.ChildDist.Mean * (this.Max - this.Min);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PertDistribution.prototype, "StdDev", {
        get: function () {
            return this.ChildDist.StdDev * (this.Max - this.Min);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PertDistribution.prototype, "IsValid", {
        get: function () {
            return this.Min <= this.Mode && this.Mode <= this.Max;
        },
        enumerable: false,
        configurable: true
    });
    PertDistribution.prototype.PDF = function (x) {
        var value = this.ChildDist.PDF(this.ScaleValue(x));
        return Math.abs(this.Max - this.Min) > 1e-6 ? value / (this.Max - this.Min) : value;
    };
    PertDistribution.prototype.CDF = function (x) {
        return this.ChildDist.CDF(this.ScaleValue(x));
    };
    PertDistribution.prototype.PPF = function (percentile) {
        return this.UnscaleValue(this.ChildDist.PPF(percentile));
    };
    PertDistribution.Mu = function (mode, min, max) {
        return (min + max + PertDistribution.Scale * mode) / (PertDistribution.Scale + 2);
    };
    PertDistribution.Alpha = function (mode, min, max) {
        var mu = PertDistribution.Mu(mode, min, max);
        if (Math.abs(max - min) <= 1e-6)
            throw new Error('PERT must have difference between minimum and maximum');
        if (Math.abs(mu - mode) <= 1e-6)
            return 1 + PertDistribution.Scale / 2;
        return ((mu - min) * (2 * mode - min - max)) / (mode - mu) / (max - min);
    };
    PertDistribution.Beta = function (mode, min, max) {
        var mu = PertDistribution.Mu(mode, min, max);
        return (PertDistribution.Alpha(mode, min, max) * (max - mu)) / (mu - min);
    };
    PertDistribution.prototype.ScaleValue = function (x) {
        if (this.Min === this.Max)
            return x;
        return (x - this.Min) / (this.Max - this.Min);
    };
    PertDistribution.prototype.UnscaleValue = function (percentile) {
        if (this.Min === this.Max)
            return percentile;
        return this.Min + percentile * (this.Max - this.Min);
    };
    PertDistribution.Scale = 4.0;
    return PertDistribution;
}());
exports.default = PertDistribution;

});

var PiecewiseUniformDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var PiecewiseUniformDistribution = /** @class */ (function () {
    function PiecewiseUniformDistribution(DiffProbs, Mins, Maxes) {
        this.Type = DistributionType_1$1.default.PiecewiseUniform;
        if (DiffProbs.length !== Mins.length && DiffProbs.length !== Maxes.length) {
            throw new Error('Lengths of input probabilities much be equal!');
        }
        this.DiffProbs = DiffProbs;
        this.Mins = Mins;
        this.Maxes = Maxes;
        this.CumulProbs = Array();
        var sum = 0.0;
        this.DiffProbs.forEach(function (prob) {
            sum += prob;
        });
        if (sum === 0) {
            for (var i = 0; i < this.DiffProbs.length; i++) {
                this.DiffProbs[i] = 1 / this.DiffProbs.length;
            }
            sum = 1;
        }
        var tracker = 0.0;
        for (var i = 0; i < this.DiffProbs.length; i++) {
            tracker += this.DiffProbs[i] / sum;
            this.DiffProbs[i] /= sum;
            this.CumulProbs.push(tracker);
        }
    }
    Object.defineProperty(PiecewiseUniformDistribution.prototype, "Min", {
        get: function () {
            if (this._AbsoluteMin) {
                return this._AbsoluteMin;
            }
            var min = Infinity;
            this.Mins.forEach(function (num) {
                if (num < min)
                    min = num;
            });
            this._AbsoluteMin = min;
            return this._AbsoluteMin;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PiecewiseUniformDistribution.prototype, "Max", {
        get: function () {
            if (this._AbsoluteMax) {
                return this._AbsoluteMax;
            }
            var max = -Infinity;
            this.Maxes.forEach(function (num) {
                if (num > max)
                    max = num;
            });
            this._AbsoluteMax = max;
            return this._AbsoluteMax;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PiecewiseUniformDistribution.prototype, "Mean", {
        get: function () {
            if (this._Mean) {
                return this._Mean;
            }
            var mean = 0;
            for (var i = 0; i < this.DiffProbs.length; i++) {
                mean += (this.Maxes[i] - this.Mins[i]) * this.DiffProbs[i];
            }
            this._Mean = mean;
            return this._Mean;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PiecewiseUniformDistribution.prototype, "Mode", {
        get: function () {
            return this.Mean;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PiecewiseUniformDistribution.prototype, "StdDev", {
        get: function () {
            var piecewiseVariance = 0.0;
            var variance = 0.0;
            var sum = 0.0;
            this.DiffProbs.forEach(function (prob) {
                sum += prob;
            });
            for (var i = 0; i < this.Maxes.length; i++) {
                piecewiseVariance =
                    (1.0 / 12.0) * Math.pow(this.Maxes[i] - this.Mins[i], 2) + Math.pow(0.5 * (this.Maxes[i] + this.Mins[i]), 2);
                piecewiseVariance *= this.DiffProbs[i] / sum;
                variance += piecewiseVariance;
                piecewiseVariance = 0.0;
            }
            variance -= Math.pow(this.Mean, 2);
            return Math.sqrt(variance);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PiecewiseUniformDistribution.prototype, "IsDefined", {
        get: function () {
            throw new Error('Method not implemented.');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PiecewiseUniformDistribution.prototype, "IsValid", {
        get: function () {
            throw new Error('Method not implemented.');
        },
        enumerable: false,
        configurable: true
    });
    PiecewiseUniformDistribution.prototype.PDF = function (x) {
        if (x < this.Min)
            return 0;
        if (x > this.Max)
            return 0;
        for (var i = 0; i < this.Maxes.length; i++) {
            if (x >= this.Mins[i] && x <= this.Maxes[i]) {
                if (Math.abs(this.Maxes[i] - this.Mins[i]) > 1e-6)
                    return this.DiffProbs[i] / (this.Maxes[i] - this.Mins[i]);
                return this.DiffProbs[i];
            }
        }
        return 0.0;
    };
    PiecewiseUniformDistribution.prototype.CDF = function (x) {
        if (x < this.Min)
            return 0;
        if (x > this.Max)
            return 1;
        var Result = 0;
        for (var j = 0; j < this.CumulProbs.length; j++) {
            if (x < this.Maxes[j] && x > this.Mins[j]) {
                var Base_Quantile = 0;
                if (j != 0)
                    Base_Quantile = this.CumulProbs[j - 1];
                var Y_Differential = this.Maxes[j] - this.Mins[j];
                if (Y_Differential == 0)
                    Result = Base_Quantile + this.DiffProbs[j] / 2;
                else {
                    var Additional_Quantile = ((x - this.Mins[j]) / Y_Differential) * this.DiffProbs[j];
                    Result = Base_Quantile + Additional_Quantile;
                }
                break;
            }
            if (x == this.Maxes[j]) {
                Result = this.CumulProbs[j];
                break;
            }
            if (x == this.Mins[j]) {
                if (j != 0)
                    Result = this.CumulProbs[j - 1];
                else
                    Result = 0;
                break;
            }
        }
        return Result;
    };
    PiecewiseUniformDistribution.prototype.PPF = function (percentile) {
        if (percentile <= 0)
            return this.Min;
        if (percentile >= 1)
            return this.Max;
        var Result = -Infinity;
        for (var j = 0; j < this.CumulProbs.length; j++) {
            if (percentile == this.CumulProbs[j]) {
                Result = this.Maxes[j];
                break;
            }
            if (percentile < this.CumulProbs[j]) {
                var Previous_Quantile = 0;
                if (j != 0)
                    Previous_Quantile = this.CumulProbs[j - 1];
                var Quantile_in_Bin = (percentile - Previous_Quantile) / (this.CumulProbs[j] - Previous_Quantile);
                Result = Quantile_in_Bin * (this.Maxes[j] - this.Mins[j]) + this.Mins[j];
                break;
            }
        }
        return Result;
    };
    return PiecewiseUniformDistribution;
}());
exports.default = PiecewiseUniformDistribution;

});

var ScaledBetaDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.Beta)(), dbeta = _a.dbeta, pbeta = _a.pbeta, qbeta = _a.qbeta;
var ScaledBetaDistribution = /** @class */ (function () {
    function ScaledBetaDistribution(alpha, beta, min, max) {
        this.Type = DistributionType_1$1.default.ScaledBeta;
        this.Alpha = alpha;
        this.Beta = beta;
        this.Min = min;
        this.Max = max;
    }
    Object.defineProperty(ScaledBetaDistribution.prototype, "Mean", {
        get: function () {
            var scaled_mean = this.Alpha / (this.Alpha + this.Beta);
            return (scaled_mean - 1.0) * (this.Max - this.Min) + this.Max;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScaledBetaDistribution.prototype, "Mode", {
        get: function () {
            var scaled_mode = 0.0;
            if (this.Alpha > 1 && this.Beta > 1) {
                scaled_mode = (this.Alpha - 1) / (this.Alpha + this.Beta - 2);
            }
            else if (this.Alpha <= 1 && this.Beta > 1) {
                scaled_mode = 0.0;
            }
            else if (this.Alpha < 1 && this.Beta < 1) {
                scaled_mode = 0.0; // this case is bimodal, 0.0 or 1.0 would be valid
            }
            else if (this.Beta <= 1 && this.Alpha > 1) {
                scaled_mode = 1.0;
            }
            else {
                scaled_mode = 0.5;
            }
            return (scaled_mode - 1.0) * (this.Max - this.Min) + this.Max;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScaledBetaDistribution.prototype, "StdDev", {
        get: function () {
            var scaled_variance = (this.Alpha * this.Beta) / (Math.pow(this.Alpha + this.Beta, 2) * (this.Alpha + this.Beta + 1));
            return Math.sqrt(Math.pow(this.Max - this.Min, 2) * scaled_variance);
        },
        enumerable: false,
        configurable: true
    });
    ScaledBetaDistribution.prototype.PDF = function (x) {
        if (this.Alpha === undefined || this.Beta === undefined) {
            throw new Error('Trying to get PDF from undefined distribution');
        }
        if (x < this.Min) {
            return 0.0;
        }
        if (x > this.Max) {
            return 0.0;
        }
        var scaled_x = (1.0 / (this.Max - this.Min)) * (x - this.Max) + 1.0;
        var val = dbeta(scaled_x, this.Alpha, this.Beta, 0);
        if (val == undefined) {
            throw new Error('Multiple return numbers from beta function call');
        }
        return val;
    };
    ScaledBetaDistribution.prototype.CDF = function (x) {
        if (this.Alpha === undefined || this.Beta === undefined) {
            throw new Error('Trying to get CDF from undefined distribution');
        }
        if (x < this.Min) {
            return 0.0;
        }
        if (x > this.Max) {
            return 1.0;
        }
        var scaled_x = (1.0 / (this.Max - this.Min)) * (x - this.Max) + 1.0;
        return pbeta(scaled_x, this.Alpha, this.Beta);
    };
    ScaledBetaDistribution.prototype.PPF = function (percentile) {
        if (this.Alpha === undefined || this.Beta === undefined) {
            throw new Error('Trying to get PPF from undefined distribution');
        }
        if (percentile < 0.0) {
            return this.Min;
        }
        if (percentile > 1.0) {
            return this.Max;
        }
        var scaled_x = qbeta(percentile, this.Alpha, this.Beta);
        return (scaled_x - 1.0) * (this.Max - this.Min) + this.Max;
    };
    Object.defineProperty(ScaledBetaDistribution.prototype, "IsValid", {
        get: function () {
            return this.Alpha > 0 && this.Beta > 0;
        },
        enumerable: false,
        configurable: true
    });
    return ScaledBetaDistribution;
}());
exports.default = ScaledBetaDistribution;

});

var ScaledTruncatedBetaDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.Beta)(), dbeta = _a.dbeta, pbeta = _a.pbeta, qbeta = _a.qbeta;
var ScaledTruncatedBetaDistribution = /** @class */ (function () {
    function ScaledTruncatedBetaDistribution(alpha, beta, min, max, truncatedMin, truncatedMax) {
        this.Type = DistributionType_1$1.default.ScaledTruncatedBeta;
        this.Alpha = alpha;
        this.Beta = beta;
        this.Min = min;
        this.Max = max;
        this.TruncatedMin = truncatedMin;
        this.TruncatedMax = truncatedMax;
    }
    Object.defineProperty(ScaledTruncatedBetaDistribution.prototype, "CdfScaledMin", {
        get: function () {
            var scaled_min = (1.0 / (this.Max - this.Min)) * (this.TruncatedMin - this.Max) + 1.0;
            return pbeta(scaled_min, this.Alpha, this.Beta);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScaledTruncatedBetaDistribution.prototype, "CdfScaledMax", {
        get: function () {
            var scaled_max = (1.0 / (this.Max - this.Min)) * (this.TruncatedMax - this.Max) + 1.0;
            return pbeta(scaled_max, this.Alpha, this.Beta);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScaledTruncatedBetaDistribution.prototype, "Mean", {
        get: function () {
            var scaled_truncated_min = (1.0 / (this.Max - this.Min)) * (this.TruncatedMin - this.Max) + 1.0;
            var scaled_truncated_max = (1.0 / (this.Max - this.Min)) * (this.TruncatedMax - this.Max) + 1.0;
            var scaled_mean = ((this.Alpha / (this.Alpha + this.Beta)) *
                (pbeta(scaled_truncated_max, this.Alpha + 1, this.Beta) -
                    pbeta(scaled_truncated_min, this.Alpha + 1, this.Beta))) /
                (pbeta(scaled_truncated_max, this.Alpha, this.Beta) - pbeta(scaled_truncated_min, this.Alpha, this.Beta));
            return (scaled_mean - 1.0) * (this.Max - this.Min) + this.Max;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScaledTruncatedBetaDistribution.prototype, "Mode", {
        get: function () {
            var scaled_mode = 0.0;
            if (this.Alpha > 1 && this.Beta > 1) {
                scaled_mode = (this.Alpha - 1) / (this.Alpha + this.Beta - 2);
                if (scaled_mode >= this.TruncatedMax) {
                    return this.TruncatedMax;
                }
                else if (scaled_mode <= this.TruncatedMin) {
                    return this.TruncatedMin;
                }
                return (scaled_mode - 1.0) * (this.Max - this.Min) + this.Max;
            }
            else if (this.Alpha <= 1 && this.Beta > 1) {
                return this.TruncatedMin;
            }
            else if (this.Alpha < 1 && this.Beta < 1) {
                return this.TruncatedMin; // this case is bimodal, 0.0 or 1.0 would be valid
            }
            else if (this.Beta <= 1 && this.Alpha > 1) {
                return this.TruncatedMax;
            }
            else {
                return (this.TruncatedMax + this.TruncatedMin) / 2.0;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScaledTruncatedBetaDistribution.prototype, "StdDev", {
        get: function () {
            var scaled_truncated_min = (1.0 / (this.Max - this.Min)) * (this.TruncatedMin - this.Max) + 1.0;
            var scaled_truncated_max = (1.0 / (this.Max - this.Min)) * (this.TruncatedMax - this.Max) + 1.0;
            var scaled_mean = (1.0 / (this.Max - this.Min)) * (this.Mean - this.Max) + 1.0;
            var scaled_variance = ((((this.Alpha + 1) * this.Alpha) / ((this.Alpha + this.Beta + 1) * (this.Alpha + this.Beta))) *
                (pbeta(scaled_truncated_max, this.Alpha + 2, this.Beta) -
                    pbeta(scaled_truncated_min, this.Alpha + 2, this.Beta))) /
                (pbeta(scaled_truncated_max, this.Alpha, this.Beta) - pbeta(scaled_truncated_min, this.Alpha, this.Beta)) -
                Math.pow(scaled_mean, 2);
            return Math.sqrt(Math.pow(this.Max - this.Min, 2) * scaled_variance);
        },
        enumerable: false,
        configurable: true
    });
    ScaledTruncatedBetaDistribution.prototype.PDF = function (x) {
        if (this.Alpha === undefined || this.Beta === undefined) {
            throw new Error('Trying to get PDF from undefined distribution');
        }
        if (x < this.TruncatedMin) {
            return 0.0;
        }
        if (x > this.TruncatedMax) {
            return 0.0;
        }
        var difference = this.CdfScaledMax - this.CdfScaledMin;
        var scaled_x = (1.0 / (this.Max - this.Min)) * (x - this.Max) + 1.0;
        var val = dbeta(scaled_x, this.Alpha, this.Beta);
        if (val == undefined) {
            throw new Error('Multiple return numbers from beta function call');
        }
        return val / difference;
    };
    ScaledTruncatedBetaDistribution.prototype.CDF = function (x) {
        if (this.Alpha === undefined || this.Beta === undefined) {
            throw new Error('Trying to get CDF from undefined distribution');
        }
        if (x < this.TruncatedMin) {
            return 0.0;
        }
        if (x > this.TruncatedMax) {
            return 1.0;
        }
        var difference = this.CdfScaledMax - this.CdfScaledMin;
        var scaled_x = (1.0 / (this.Max - this.Min)) * (x - this.Max) + 1.0;
        var uncorrected_quantile = pbeta(scaled_x, this.Alpha, this.Beta);
        if (uncorrected_quantile > this.CdfScaledMax) {
            return 1.0;
        }
        if (uncorrected_quantile < this.CdfScaledMin) {
            return 0.0;
        }
        var corrected_quantile = (uncorrected_quantile - this.CdfScaledMin) / difference;
        return corrected_quantile;
    };
    ScaledTruncatedBetaDistribution.prototype.PPF = function (percentile) {
        if (this.Alpha === undefined || this.Beta === undefined) {
            throw new Error('Trying to get PPF from undefined distribution');
        }
        if (percentile < 0.0) {
            return this.TruncatedMin;
        }
        if (percentile > 1.0) {
            return this.TruncatedMax;
        }
        var difference = this.CdfScaledMax - this.CdfScaledMin;
        var fractile = percentile * difference + this.CdfScaledMin;
        var scaled_x = qbeta(fractile, this.Alpha, this.Beta);
        return (scaled_x - 1.0) * (this.Max - this.Min) + this.Max;
    };
    Object.defineProperty(ScaledTruncatedBetaDistribution.prototype, "IsValid", {
        get: function () {
            return this.Alpha > 0 && this.Beta > 0;
        },
        enumerable: false,
        configurable: true
    });
    return ScaledTruncatedBetaDistribution;
}());
exports.default = ScaledTruncatedBetaDistribution;

});

var TriangleDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var TriangleDistribution = /** @class */ (function () {
    function TriangleDistribution(min, max, mode) {
        this.Type = DistributionType_1$1.default.Triangle;
        this.Min = min;
        this.Max = max;
        this.Mode = mode;
    }
    Object.defineProperty(TriangleDistribution.prototype, "IsValid", {
        get: function () {
            return this.Min < this.Max && this.Min <= this.Mode && this.Mode <= this.Max;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TriangleDistribution.prototype, "Mean", {
        get: function () {
            return (this.Min + this.Max + this.Mode) / 3;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TriangleDistribution.prototype, "StdDev", {
        get: function () {
            var variance = (Math.pow(this.Min, 2) +
                Math.pow(this.Max, 2) +
                Math.pow(this.Mode, 2) -
                this.Max * this.Min -
                this.Max * this.Mode -
                this.Min * this.Mode) /
                18;
            return Math.sqrt(variance);
        },
        enumerable: false,
        configurable: true
    });
    TriangleDistribution.prototype.PDF = function (x) {
        if (x >= this.Min && x < this.Mode) {
            return (2.0 * (x - this.Min)) / ((this.Max - this.Min) * (this.Mode - this.Min));
        }
        if (x == this.Mode) {
            return 2.0 / (this.Max - this.Min);
        }
        if (x > this.Mode && x <= this.Max) {
            return (2.0 * (this.Max - x)) / ((this.Max - this.Min) * (this.Max - this.Mode));
        }
        return 0.0; //x > max or x < min
    };
    TriangleDistribution.prototype.CDF = function (x) {
        if (x > this.Min && x <= this.Mode) {
            return Math.pow((x - this.Min), 2) / ((this.Max - this.Min) * (this.Mode - this.Min));
        }
        if (x > this.Mode && x < this.Max) {
            return 1 - Math.pow((this.Max - x), 2) / ((this.Max - this.Min) * (this.Max - this.Mode));
        }
        if (x >= this.Max) {
            return 1.0;
        }
        return 0.0; //x <= min
    };
    TriangleDistribution.prototype.PPF = function (percentile) {
        if (percentile <= 0.0) {
            return this.Min;
        }
        if (percentile >= 1.0) {
            return this.Max;
        }
        var x = Math.sqrt(percentile * ((this.Max - this.Min) * (this.Mode - this.Min))) + this.Min;
        if (x > this.Min && x <= this.Mode) {
            return x;
        }
        return this.Max - Math.sqrt((1 - percentile) * ((this.Max - this.Min) * (this.Max - this.Mode)));
    };
    return TriangleDistribution;
}());
exports.default = TriangleDistribution;

});

var TruncatedBetaDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.Beta)(), dbeta = _a.dbeta, pbeta = _a.pbeta, qbeta = _a.qbeta;
var TruncatedBetaDistribution = /** @class */ (function () {
    function TruncatedBetaDistribution(alpha, beta, min, max) {
        this.Type = DistributionType_1$1.default.TruncatedBeta;
        this.Alpha = alpha;
        this.Beta = beta;
        this.Min = min;
        this.Max = max;
    }
    Object.defineProperty(TruncatedBetaDistribution.prototype, "Mean", {
        get: function () {
            return (((this.Alpha / (this.Alpha + this.Beta)) *
                (pbeta(this.Max, this.Alpha + 1, this.Beta) - pbeta(this.Min, this.Alpha + 1, this.Beta))) /
                (pbeta(this.Max, this.Alpha, this.Beta) - pbeta(this.Min, this.Alpha, this.Beta)));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedBetaDistribution.prototype, "Mode", {
        get: function () {
            if (this.Alpha > 1 && this.Beta > 1) {
                var mode = ((this.Alpha - 1) / (this.Alpha + this.Beta - 2)) * (this.Max - this.Min);
                if (mode <= this.Min) {
                    return this.Min;
                }
                if (mode >= this.Max) {
                    return this.Max;
                }
                return mode;
            }
            if (this.Alpha <= 1 && this.Beta > 1) {
                return this.Min;
            }
            if (this.Alpha < 1 && this.Beta < 1) {
                if (0 + this.Min <= 1 - this.Max) {
                    return this.Min;
                }
                return this.Max;
            }
            if (this.Beta <= 1 && this.Alpha > 1) {
                return this.Max;
            }
            return (this.Max + this.Min) / 2.0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedBetaDistribution.prototype, "StdDev", {
        get: function () {
            var variance = ((((this.Alpha + 1) * this.Alpha) / ((this.Alpha + this.Beta + 1) * (this.Alpha + this.Beta))) *
                (pbeta(this.Max, this.Alpha + 2, this.Beta) - pbeta(this.Min, this.Alpha + 2, this.Beta))) /
                (pbeta(this.Max, this.Alpha, this.Beta) - pbeta(this.Min, this.Alpha, this.Beta)) -
                Math.pow(this.Mean, 2);
            return Math.sqrt(variance);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedBetaDistribution.prototype, "PMin", {
        get: function () {
            if (this._PMin) {
                return this._PMin;
            }
            this._PMin = pbeta(this.Min, this.Alpha, this.Beta);
            return this._PMin;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedBetaDistribution.prototype, "PMax", {
        get: function () {
            if (this._PMax) {
                return this._PMax;
            }
            this._PMax = pbeta(this.Max, this.Alpha, this.Beta);
            return this._PMax;
        },
        enumerable: false,
        configurable: true
    });
    TruncatedBetaDistribution.prototype.PDF = function (x) {
        if (x < this.Min || x > this.Max) {
            //Min and max are restricted to [0,1] so the boundaries do not need to be checked
            return 0.0;
        }
        var val = dbeta(x, this.Alpha, this.Beta, 0);
        if (val == undefined) {
            throw new Error('Multiple return numbers from beta function call');
        }
        return val / (this.PMax - this.PMin);
    };
    TruncatedBetaDistribution.prototype.CDF = function (x) {
        if (x < this.Min) {
            return 0.0;
        }
        if (x > this.Max) {
            return 1.0;
        }
        return (pbeta(x, this.Alpha, this.Beta) - this.PMin) / (this.PMax - this.PMin);
    };
    TruncatedBetaDistribution.prototype.PPF = function (percentile) {
        if (percentile < 0.0) {
            return this.Min;
        }
        if (percentile > 1.0) {
            return this.Max;
        }
        return qbeta(percentile * (this.PMax - this.PMin) + this.PMin, this.Alpha, this.Beta);
    };
    Object.defineProperty(TruncatedBetaDistribution.prototype, "IsValid", {
        get: function () {
            return this.Alpha > 0 && this.Beta > 0 && this.Min >= 0 && this.Max > this.Min && this.Max <= 1.0;
        },
        enumerable: false,
        configurable: true
    });
    return TruncatedBetaDistribution;
}());
exports.default = TruncatedBetaDistribution;

});

var TruncatedGammaDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.Gamma)(), dgamma = _a.dgamma, pgamma = _a.pgamma, qgamma = _a.qgamma;
var TruncatedGammaDistribution = /** @class */ (function () {
    function TruncatedGammaDistribution(shape, scale, min, max) {
        if (max === void 0) { max = -1.0; }
        this.Type = DistributionType_1$1.default.TruncatedGamma;
        //Rate is undefined since Scale is used here, but it is a positional argmunet in the Rmath gamme funcitons before Scale so it must be supplied
        //If Rate is used instead of Scale, then the mean and stdDev need to be changed.
        this.Rate = undefined;
        this.Shape = shape;
        this.Scale = scale;
        this.Min = min;
        this.Max = max;
    }
    Object.defineProperty(TruncatedGammaDistribution.prototype, "IsDefined", {
        get: function () {
            return this.Shape !== undefined && this.Scale !== undefined && this.Min !== undefined && this.Max !== undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedGammaDistribution.prototype, "IsValid", {
        get: function () {
            if (this.Shape === undefined || this.Scale === undefined || this.Min === undefined || this.Max === undefined) {
                return false;
            }
            //Min restricted to 0 since that is the range of the gamma distribution
            return this.Shape > 0 && this.Scale > 0 && this.Min > 0 && this.Min < this.Max;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedGammaDistribution.prototype, "Mean", {
        get: function () {
            var maxCdf = 1.0;
            var maxCdfShapePlus1 = 1.0;
            if (this.Max != -1.0) {
                maxCdf = pgamma(this.Max, this.Shape, this.Rate, this.Scale);
                maxCdfShapePlus1 = pgamma(this.Max, this.Shape + 1, this.Rate, this.Scale);
            }
            return (this.Shape *
                this.Scale *
                ((maxCdfShapePlus1 - pgamma(this.Min, this.Shape + 1, this.Rate, this.Scale)) /
                    (maxCdf - pgamma(this.Min, this.Shape, this.Rate, this.Scale))));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedGammaDistribution.prototype, "Mode", {
        get: function () {
            var mode = 0.0;
            if (this.Shape >= 1) {
                mode = (this.Shape - 1) * this.Scale;
                if (mode >= this.Max && this.Max != -1.0) {
                    return this.Max;
                }
                if (mode <= this.Min) {
                    return this.Min;
                }
                return mode;
            }
            return this.Min;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedGammaDistribution.prototype, "StdDev", {
        get: function () {
            var maxCdf = 1.0;
            var maxCDFShapePlus2 = 1.0;
            if (this.Max != -1.0) {
                maxCdf = pgamma(this.Max, this.Shape, this.Rate, this.Scale);
                maxCDFShapePlus2 = pgamma(this.Max, this.Shape + 2, this.Rate, this.Scale);
            }
            var variance = (this.Shape + 1) *
                this.Shape *
                Math.pow(this.Scale, 2) *
                ((maxCDFShapePlus2 - pgamma(this.Min, this.Shape + 2, this.Rate, this.Scale)) /
                    (maxCdf - pgamma(this.Min, this.Shape, this.Rate, this.Scale))) -
                Math.pow(this.Mean, 2);
            return Math.sqrt(variance);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedGammaDistribution.prototype, "PMin", {
        get: function () {
            if (this._PMin)
                return this._PMin;
            this._PMin = pgamma(this.Min, this.Shape, this.Rate, this.Scale);
            if (this._PMin === undefined) {
                throw new Error('Error calculating the gamma at the supplied minimum');
            }
            return this._PMin;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedGammaDistribution.prototype, "PMax", {
        get: function () {
            if (this._PMax)
                return this._PMax;
            this._PMax = pgamma(this.Max, this.Shape, this.Rate, this.Scale);
            if (this._PMax === undefined) {
                throw new Error('Error calculating the gamma at the supplied minimum');
            }
            return this._PMax;
        },
        enumerable: false,
        configurable: true
    });
    TruncatedGammaDistribution.prototype.PDF = function (x) {
        if (x < this.Min || x > this.Max) {
            //if x is outside of [min, max] then truncated pdf = 0
            return 0.0;
        }
        return dgamma(x, this.Shape, this.Rate, this.Scale) / (this.PMax - this.PMin);
    };
    TruncatedGammaDistribution.prototype.CDF = function (x) {
        if (x < this.Min) {
            return 0.0;
        }
        if (x > this.Max) {
            return 1.0;
        }
        return (pgamma(x, this.Shape, this.Rate, this.Scale) - this.PMin) / (this.PMax - this.PMin);
    };
    TruncatedGammaDistribution.prototype.PPF = function (percentile) {
        if (percentile <= 0.0) {
            return this.Min;
        }
        if (percentile >= 1.0) {
            return this.Max;
        }
        return qgamma(percentile * (this.PMax - this.PMin) + this.PMin, this.Shape, this.Rate, this.Scale);
    };
    return TruncatedGammaDistribution;
}());
exports.default = TruncatedGammaDistribution;

});

var TruncatedLogNormalDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var battelle_common_typescript_external_rmath_2 = dist$1;
var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.LogNormal)(), dlnorm = _a.dlnorm, plnorm = _a.plnorm, qlnorm = _a.qlnorm;
var pnorm = (0, battelle_common_typescript_external_rmath_2.Normal)().pnorm;
var TruncatedLogNormalDistribution = /** @class */ (function () {
    function TruncatedLogNormalDistribution(LogMean, LogStdDev, min, max) {
        this.Type = DistributionType_1$1.default.TruncatedLogNormal;
        this.LogMean = LogMean;
        this.LogStdDev = LogStdDev;
        this.Min = min;
        this.Max = max;
    }
    Object.defineProperty(TruncatedLogNormalDistribution.prototype, "Mean", {
        get: function () {
            var alpha = (Math.log(this.Min) - this.LogMean) / this.LogStdDev;
            var beta = (Math.log(this.Max) - this.LogMean) / this.LogStdDev;
            var nonTruncated1stMoment = Math.exp(this.LogMean + Math.pow(this.LogStdDev, 2) / 2.0);
            var truncated1stMoment = nonTruncated1stMoment *
                ((pnorm(this.LogStdDev - alpha, 0, 1) - pnorm(this.LogStdDev - beta, 0, 1)) /
                    (pnorm(beta, 0, 1) - pnorm(alpha, 0, 1)));
            return truncated1stMoment;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedLogNormalDistribution.prototype, "Mode", {
        get: function () {
            var sigma_squared = this.LogStdDev * this.LogStdDev;
            var mode = Math.exp(this.LogMean - sigma_squared);
            if (mode > this.Max)
                return this.Max;
            if (mode < this.Min)
                return this.Min;
            return mode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedLogNormalDistribution.prototype, "StdDev", {
        get: function () {
            var alpha = (Math.log(this.Min) - this.LogMean) / this.LogStdDev;
            var beta = (Math.log(this.Max) - this.LogMean) / this.LogStdDev;
            var nonTruncated2ndMoment = Math.exp(2.0 * this.LogMean + (4.0 * Math.pow(this.LogStdDev, 2)) / 2.0);
            var truncated2ndMoment = nonTruncated2ndMoment *
                ((pnorm(2.0 * this.LogStdDev - alpha, 0, 1) - pnorm(2.0 * this.LogStdDev - beta, 0, 1)) /
                    (pnorm(beta, 0, 1) - pnorm(alpha, 0, 1)));
            if (truncated2ndMoment == 0.0) {
                // this is to protect against too high of logMean & logStdDev values that would cause the numerator in the above fraction to round to 0
                return this.Mean;
            }
            return Math.sqrt(truncated2ndMoment - Math.pow(this.Mean, 2));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedLogNormalDistribution.prototype, "PMin", {
        get: function () {
            if (this._PMin === undefined) {
                this._PMin = plnorm(this.Min, this.LogMean, this.LogStdDev);
            }
            return this._PMin;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedLogNormalDistribution.prototype, "PMax", {
        get: function () {
            if (this._PMax === undefined) {
                this._PMax = plnorm(this.Max, this.LogMean, this.LogStdDev);
            }
            return this._PMax;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedLogNormalDistribution.prototype, "IsValid", {
        get: function () {
            return this.StdDev > 0 && this.Max > this.Min;
        },
        enumerable: false,
        configurable: true
    });
    TruncatedLogNormalDistribution.prototype.PDF = function (x) {
        if (x < this.Min || x > this.Max) {
            return 0.0;
        }
        return dlnorm(x, this.LogMean, this.LogStdDev, false) / (this.PMax - this.PMin);
    };
    TruncatedLogNormalDistribution.prototype.CDF = function (x) {
        if (x <= this.Min) {
            return 0.0;
        }
        if (x >= this.Max) {
            return 1.0;
        }
        return (plnorm(x, this.LogMean, this.LogStdDev) - this.PMin) / (this.PMax - this.PMin);
    };
    TruncatedLogNormalDistribution.prototype.PPF = function (percentile) {
        if (percentile <= 0)
            return this.Min;
        if (percentile >= 1)
            return this.Max;
        return qlnorm(percentile * (this.PMax - this.PMin) + this.PMin, this.LogMean, this.LogStdDev);
    };
    return TruncatedLogNormalDistribution;
}());
exports.default = TruncatedLogNormalDistribution;

});

var TruncatedNormalDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.Normal)(), dnorm = _a.dnorm, pnorm = _a.pnorm, qnorm = _a.qnorm;
var TruncatedNormalDistribution = /** @class */ (function () {
    function TruncatedNormalDistribution(Mean, StdDev, min, max) {
        this.Type = DistributionType_1$1.default.TruncatedNormal;
        this.Mean = Mean;
        this.StdDev = StdDev;
        this.Min = min;
        this.Max = max;
    }
    Object.defineProperty(TruncatedNormalDistribution.prototype, "TruncatedMean", {
        get: function () {
            var alpha = (this.Min - this.Mean) / this.StdDev;
            var beta = (this.Max - this.Mean) / this.StdDev;
            var truncatedMeanNumerator = this.StdDev * (dnorm(beta, 0, 1) - dnorm(alpha, 0, 1));
            var truncatedMeanDenominator = pnorm(beta, 0, 1) - pnorm(alpha, 0, 1);
            return this.Mean - truncatedMeanNumerator / truncatedMeanDenominator;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedNormalDistribution.prototype, "TruncatedStdDev", {
        get: function () {
            var alpha = (this.Min - this.Mean) / this.StdDev;
            var beta = (this.Max - this.Mean) / this.StdDev;
            var truncatedVariance = Math.pow(this.StdDev, 2) *
                (1 +
                    (alpha * dnorm(alpha, 0, 1) - beta * dnorm(beta, 0, 1)) / (pnorm(beta, 0, 1) - pnorm(alpha, 0, 1)) -
                    Math.pow((dnorm(alpha, 0, 1) - dnorm(beta, 0, 1)) / (pnorm(beta, 0, 1) - pnorm(alpha, 0, 1)), 2));
            return Math.sqrt(truncatedVariance);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedNormalDistribution.prototype, "Mode", {
        get: function () {
            if (this.Mean < this.Min)
                return this.Min;
            if (this.Mean > this.Max)
                return this.Max;
            return this.Mean;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedNormalDistribution.prototype, "IsValid", {
        get: function () {
            return this.StdDev > 0 && this.Max > this.Min;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedNormalDistribution.prototype, "PMin", {
        get: function () {
            if (this._PMin === undefined) {
                this._PMin = pnorm(this.Min, this.Mean, this.StdDev);
            }
            return this._PMin;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TruncatedNormalDistribution.prototype, "PMax", {
        get: function () {
            if (this._PMax === undefined) {
                this._PMax = pnorm(this.Max, this.Mean, this.StdDev);
            }
            return this._PMax;
        },
        enumerable: false,
        configurable: true
    });
    TruncatedNormalDistribution.prototype.PDF = function (x) {
        if (x < this.Min || x > this.Max) {
            return 0.0;
        }
        return dnorm(x, this.Mean, this.StdDev, false) / (this.PMax - this.PMin);
    };
    TruncatedNormalDistribution.prototype.CDF = function (x) {
        if (x <= this.Min) {
            return 0.0;
        }
        if (x >= this.Max) {
            return 1.0;
        }
        return (pnorm(x, this.Mean, this.StdDev) - this.PMin) / (this.PMax - this.PMin);
    };
    TruncatedNormalDistribution.prototype.PPF = function (percentile) {
        if (percentile <= 0.0) {
            return this.Min;
        }
        if (percentile >= 1.0) {
            return this.Max;
        }
        return qnorm(percentile * (this.PMax - this.PMin) + this.PMin, this.Mean, this.StdDev);
    };
    return TruncatedNormalDistribution;
}());
exports.default = TruncatedNormalDistribution;

});

var UniformDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

var ConstantDistribution_1$1 = tslib_es6.__importDefault(ConstantDistribution_1);
var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var UniformDistribution = /** @class */ (function () {
    function UniformDistribution(min, max) {
        this.Type = DistributionType_1$1.default.Uniform;
        this.Min = min;
        this.Max = max;
    }
    Object.defineProperty(UniformDistribution.prototype, "Mean", {
        get: function () {
            return (this.Max + this.Min) / 2.0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UniformDistribution.prototype, "Mode", {
        get: function () {
            return (this.Max + this.Min) / 2.0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UniformDistribution.prototype, "StdDev", {
        get: function () {
            if (Math.abs(this.Max - this.Min) < 1e-6) {
                return this.Max / ConstantDistribution_1$1.default.DeviationModifier;
            }
            return (this.Max - this.Min) / ConstantDistribution_1$1.default.DeviationModifier;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UniformDistribution.prototype, "IsValid", {
        get: function () {
            return this.Min <= this.Max;
        },
        enumerable: false,
        configurable: true
    });
    UniformDistribution.prototype.PPF = function (percentile) {
        if (percentile <= 0)
            return this.Min;
        if (percentile >= 1)
            return this.Max;
        return this.Min + percentile * (this.Max - this.Min);
    };
    UniformDistribution.prototype.PDF = function (x) {
        return x < this.Min || x > this.Max ? 0.0 : 1 / (this.Max - this.Min);
    };
    UniformDistribution.prototype.CDF = function (x) {
        if (x < this.Min) {
            return 0.0;
        }
        if (x > this.Max) {
            return 1.0;
        }
        return (x - this.Min) / (this.Max - this.Min);
    };
    return UniformDistribution;
}());
exports.default = UniformDistribution;

});

var Utilities = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.gamma = void 0;
var g = 7;
var C = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7,
];
function gamma(z) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    if (z < 0.5)
        return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    else {
        z -= 1;
        var x = C[0];
        for (var i = 1; i < g + 2; i++)
            x += C[i] / (z + i);
        var t = z + g + 0.5;
        return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
    }
}
exports.gamma = gamma;

});

var WeibullDistribution_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
var _a = (0, dist$1.Weibull)(), dweibull = _a.dweibull, pweibull = _a.pweibull, qweibull = _a.qweibull;
var WeibullDistribution = /** @class */ (function () {
    function WeibullDistribution(shape, scale) {
        this.Type = DistributionType_1$1.default.Weibull;
        this.Min = 0.0;
        this.Max = Infinity;
        this.Shape = shape;
        this.Scale = scale;
    }
    Object.defineProperty(WeibullDistribution.prototype, "IsValid", {
        get: function () {
            if (this.Shape === undefined || this.Scale === undefined) {
                return false;
            }
            return this.Shape > 0 && this.Scale > 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WeibullDistribution.prototype, "Mean", {
        get: function () {
            return this.Scale * (0, Utilities.gamma)(1.0 + 1.0 / this.Shape);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WeibullDistribution.prototype, "Mode", {
        get: function () {
            if (this.Shape <= 1.0) {
                return 0.0;
            }
            return this.Scale * Math.pow((this.Shape - 1.0) / this.Shape, 1 / this.Shape);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WeibullDistribution.prototype, "StdDev", {
        get: function () {
            var gammaLeft = (0, Utilities.gamma)(1.0 + 2.0 / this.Shape);
            var gammaRight = (0, Utilities.gamma)(1 + 1 / this.Shape);
            var variance = Math.pow(this.Scale, 2) * (gammaLeft - Math.pow(gammaRight, 2));
            return Math.sqrt(variance);
        },
        enumerable: false,
        configurable: true
    });
    WeibullDistribution.prototype.PDF = function (x) {
        if (x < 0.0) {
            return 0.0;
        }
        return dweibull(x, this.Shape, this.Scale);
    };
    WeibullDistribution.prototype.CDF = function (x) {
        if (x < this.Min) {
            return 0.0;
        }
        return pweibull(x, this.Shape, this.Scale);
    };
    WeibullDistribution.prototype.PPF = function (percentile) {
        if (percentile <= 0.0) {
            return this.Min;
        }
        if (percentile >= 1.0) {
            return this.Max;
        }
        return qweibull(percentile, this.Shape, this.Scale);
    };
    return WeibullDistribution;
}());
exports.default = WeibullDistribution;

});

var DistributionDataGenerator_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var DistributionDataGenerator = /** @class */ (function () {
    function DistributionDataGenerator(numberPoints, minimum, maximum) {
        this.numberPoints = numberPoints !== null && numberPoints !== void 0 ? numberPoints : DistributionDataGenerator.DefaultNumberPoints;
        this.minimum = minimum;
        this.maximum = maximum;
    }
    DistributionDataGenerator.prototype.CDF = function (dist) {
        return this.GenerateDataPoints(dist, dist.CDF.bind(dist));
    };
    DistributionDataGenerator.prototype.PDF = function (dist) {
        return this.GenerateDataPoints(dist, dist.PDF.bind(dist));
    };
    // min and max are always 0 and 1 so PPF has it's own generation funciton
    DistributionDataGenerator.prototype.PPF = function (dist) {
        var dataPoints = new Array(this.numberPoints);
        for (var i = 0; i < this.numberPoints; i++) {
            var x = 0 + (1 / this.numberPoints) * i; // min and max are always 0 and 1
            dataPoints[i] = { x: x, y: dist.PPF(x) };
        }
        return dataPoints;
    };
    DistributionDataGenerator.prototype.GenerateDataPoints = function (dist, generator) {
        var _a, _b;
        var dataPoints = new Array(this.numberPoints);
        var min = (_a = this.minimum) !== null && _a !== void 0 ? _a : dist.Min;
        var max = (_b = this.maximum) !== null && _b !== void 0 ? _b : dist.Max;
        for (var i = 0; i < this.numberPoints; i++) {
            var x = min + ((max - min) / this.numberPoints) * i;
            dataPoints[i] = { x: x, y: generator(x) };
        }
        return dataPoints;
    };
    DistributionDataGenerator.DefaultNumberPoints = 1000;
    return DistributionDataGenerator;
}());
exports.default = DistributionDataGenerator;

});

var dist = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.WeibullDistribution = exports.UniformDistribution = exports.TruncatedNormalDistribution = exports.TruncatedLogNormalDistribution = exports.TruncatedGammaDistribution = exports.TruncatedBetaDistribution = exports.TriangleDistribution = exports.ScaledTruncatedBetaDistribution = exports.ScaledBetaDistribution = exports.PiecewiseUniformDistribution = exports.PertDistribution = exports.NormalDistribution = exports.LogUniformDistribution = exports.LogNormalDistribution = exports.GammaDistribution = exports.DistributionType = exports.DistributionDataGenerator = exports.DiscreteDistribution = exports.BimodalTruncatedNormalDistribution = exports.BetaDistribution = exports.ConstantDistribution = void 0;

var BetaDistribution_1$1 = tslib_es6.__importDefault(BetaDistribution_1);
exports.BetaDistribution = BetaDistribution_1$1.default;
var BimodalTruncatedNormalDistribution_1$1 = tslib_es6.__importDefault(BimodalTruncatedNormalDistribution_1);
exports.BimodalTruncatedNormalDistribution = BimodalTruncatedNormalDistribution_1$1.default;
var ConstantDistribution_1$1 = tslib_es6.__importDefault(ConstantDistribution_1);
exports.ConstantDistribution = ConstantDistribution_1$1.default;
var DiscreteDistribution_1$1 = tslib_es6.__importDefault(DiscreteDistribution_1);
exports.DiscreteDistribution = DiscreteDistribution_1$1.default;
var GammaDistribution_1$1 = tslib_es6.__importDefault(GammaDistribution_1);
exports.GammaDistribution = GammaDistribution_1$1.default;
var LogNormalDistribution_1$1 = tslib_es6.__importDefault(LogNormalDistribution_1);
exports.LogNormalDistribution = LogNormalDistribution_1$1.default;
var LogUniformDistribution_1$1 = tslib_es6.__importDefault(LogUniformDistribution_1);
exports.LogUniformDistribution = LogUniformDistribution_1$1.default;
var NormalDistribution_1$1 = tslib_es6.__importDefault(NormalDistribution_1);
exports.NormalDistribution = NormalDistribution_1$1.default;
var PertDistribution_1$1 = tslib_es6.__importDefault(PertDistribution_1);
exports.PertDistribution = PertDistribution_1$1.default;
var PiecewiseUniformDistribution_1$1 = tslib_es6.__importDefault(PiecewiseUniformDistribution_1);
exports.PiecewiseUniformDistribution = PiecewiseUniformDistribution_1$1.default;
var ScaledBetaDistribution_1$1 = tslib_es6.__importDefault(ScaledBetaDistribution_1);
exports.ScaledBetaDistribution = ScaledBetaDistribution_1$1.default;
var ScaledTruncatedBetaDistribution_1$1 = tslib_es6.__importDefault(ScaledTruncatedBetaDistribution_1);
exports.ScaledTruncatedBetaDistribution = ScaledTruncatedBetaDistribution_1$1.default;
var TriangleDistribution_1$1 = tslib_es6.__importDefault(TriangleDistribution_1);
exports.TriangleDistribution = TriangleDistribution_1$1.default;
var TruncatedBetaDistribution_1$1 = tslib_es6.__importDefault(TruncatedBetaDistribution_1);
exports.TruncatedBetaDistribution = TruncatedBetaDistribution_1$1.default;
var TruncatedGammaDistribution_1$1 = tslib_es6.__importDefault(TruncatedGammaDistribution_1);
exports.TruncatedGammaDistribution = TruncatedGammaDistribution_1$1.default;
var TruncatedLogNormalDistribution_1$1 = tslib_es6.__importDefault(TruncatedLogNormalDistribution_1);
exports.TruncatedLogNormalDistribution = TruncatedLogNormalDistribution_1$1.default;
var TruncatedNormalDistribution_1$1 = tslib_es6.__importDefault(TruncatedNormalDistribution_1);
exports.TruncatedNormalDistribution = TruncatedNormalDistribution_1$1.default;
var UniformDistribution_1$1 = tslib_es6.__importDefault(UniformDistribution_1);
exports.UniformDistribution = UniformDistribution_1$1.default;
var WeibullDistribution_1$1 = tslib_es6.__importDefault(WeibullDistribution_1);
exports.WeibullDistribution = WeibullDistribution_1$1.default;
var DistributionDataGenerator_1$1 = tslib_es6.__importDefault(DistributionDataGenerator_1);
exports.DistributionDataGenerator = DistributionDataGenerator_1$1.default;
var DistributionType_1$1 = tslib_es6.__importDefault(DistributionType_1);
exports.DistributionType = DistributionType_1$1.default;

});

var LineChart = /** @class */ (function (_super) {
    __extends(LineChart, _super);
    function LineChart() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.chartFontSize = 14;
        return _this;
    }
    LineChart_1 = LineChart;
    Object.defineProperty(LineChart.prototype, "chartData", {
        get: function () {
            var _this = this;
            if (this.chartSeries.length === 0) {
                return {
                    labels: [],
                    datasets: [],
                };
            }
            return {
                labels: this.chartSeries[0].axisLabels || [],
                datasets: this.chartSeries.map(function (el) {
                    // filter out 0s for logarithmic data points. Only do this if necessary to save in efficiency.
                    // NOTE(quinton): if the values of the Data are not 'x' and 'y', this will break
                    var logFilter = el.data;
                    var isScatter = el.data[0].x !== undefined;
                    if (_this.xAxisScale === 'logarithmic' && isScatter) {
                        logFilter = logFilter.filter(function (elMember) { return elMember.x >= 0; });
                    }
                    if (_this.yAxisScale === 'logarithmic' && isScatter) {
                        logFilter = logFilter.filter(function (elMember) { return elMember.y >= 0; });
                    }
                    if (logFilter.length < el.data.length) {
                        // eslint-disable-next-line no-console
                        console.warn('Logarithmic scale was used on LineChart axes; data points with value 0 have been removed');
                    }
                    return {
                        data: logFilter,
                        label: el.label,
                        backgroundColor: el.backgroundColor,
                        borderColor: el.borderColor,
                        fill: el.fill,
                        tension: el.useStraightLines ? 0 : undefined,
                        stepped: el.stepped,
                        pointRadius: el.pointRadius,
                    };
                }),
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LineChart.prototype, "chartOptions", {
        get: function () {
            return {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        left: 0,
                    },
                },
                scales: {
                    x: this.xAxisProperties,
                    y: this.yAxisProperties,
                },
                elements: {
                    point: {
                        radius: this.dataPointSize, // Removes the data p oints
                    },
                },
                plugins: {
                    datalabels: {
                        display: false,
                    },
                    legend: {
                        display: true,
                        labels: {
                            font: {
                                size: this.chartFontSize,
                            },
                            filter: function (item) {
                                return item.text.length > 0;
                            },
                        },
                    },
                    tooltip: {
                        enabled: false,
                    },
                },
                animation: {
                    duration: 0,
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LineChart.prototype, "xAxisProperties", {
        get: function () {
            var _this = this;
            return {
                type: this.xAxisScale,
                suggestedMin: this.forceXAxisMinZero ? 0 : undefined,
                ticks: {
                    autoSkip: false,
                    font: {
                        size: this.chartFontSize,
                    },
                    callback: function (value) {
                        if (Number.isNaN(Number(value)) || _this.type === 'category') {
                            return value;
                        }
                        if (_this.type === 'logarithmic' &&
                            Math.round(Math.log10(Number(value))) !== Math.log10(Number(value))) {
                            return ''; // This is to eliminate any log label that isn't a power of ten
                        }
                        if ((value < 0.001 && value > 0) || value >= 1e4) {
                            return value.toExponential(1);
                        }
                        return Number(value.toPrecision(3)).toString();
                    },
                },
                title: {
                    text: LineChart_1.formatLabel(this.xAxisLabel),
                    font: {
                        size: this.chartFontSize + 2,
                        weight: 'bold',
                    },
                    display: this.xAxisLabel.length > 0,
                },
                /* eslint no-param-reassign: ["error", { "props": false }] */
                afterDataLimits: function (axis) {
                    if (axis.type === 'time') {
                        axis.min -= 60 * 60 * 1000; // 1 hr (in milliseconds) before
                    }
                    else if (axis.min > 0) {
                        axis.min *= 0.999;
                    }
                    // If the max is 1, that's likely because it's a fraction distribution and we don't need the extra space
                    if (axis.type === 'time') {
                        axis.max += 60 * 60 * 1000; // 1 hr (in milliseconds) later
                    }
                    else if (Math.abs(axis.max - 1) < 1e-8) {
                        axis.max = 1;
                    }
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LineChart.prototype, "yAxisProperties", {
        get: function () {
            return {
                type: this.yAxisScale,
                max: this.yScaleMax,
                min: this.yScaleMin,
                ticks: {
                    font: {
                        size: this.chartFontSize,
                    },
                    callback: function (value) {
                        if (Number.isNaN(Number(value)) || this.options.type === 'category') {
                            return value;
                        }
                        if (this.type === 'logarithmic' &&
                            Math.round(Math.log10(Number(value))) !== Math.log10(Number(value))) {
                            return ''; // This is to eliminate any log label that isn't a power of ten
                        }
                        if ((value < 0.001 && value > 0) || value >= 1e4) {
                            return value.toExponential(1);
                        }
                        return Number(value.toPrecision(3)).toString();
                    },
                },
                grid: {
                    tickLength: 5,
                },
                title: {
                    text: LineChart_1.formatLabel(this.yAxisLabel),
                    font: {
                        size: this.chartFontSize + 2,
                        weight: 'bold',
                    },
                    display: this.yAxisLabel.length > 0,
                },
                afterDataLimits: function (axis) {
                    if (axis.min > 0) {
                        axis.min *= 0.999;
                    }
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    LineChart.prototype.resetChart = function () {
        if (this.$refs.chart) {
            this.$refs.chart.resetChart();
        }
    };
    // eslint-disable-next-line class-methods-use-this
    LineChart.formatLabel = function (label) {
        if (label.includes('^2')) {
            var split = label.split('^2');
            // eslint-disable-next-line prefer-template
            return split[0] + '\u00B2' + split[1].substring(0);
        }
        if (label.includes('^3')) {
            var split = label.split('^3');
            // eslint-disable-next-line prefer-template
            return split[0] + '\u00B3' + split[1].substring(0);
        }
        return label;
    };
    LineChart.prototype.valueChanged = function (index, datasetIndex, chart) {
        this.$emit('valueChanged', index, datasetIndex, chart);
    };
    var LineChart_1;
    __decorate([
        Prop({ required: true })
    ], LineChart.prototype, "chartSeries", void 0);
    __decorate([
        Prop({ default: '' })
    ], LineChart.prototype, "yAxisLabel", void 0);
    __decorate([
        Prop({ default: 'linear' })
    ], LineChart.prototype, "yAxisScale", void 0);
    __decorate([
        Prop({ default: '' })
    ], LineChart.prototype, "xAxisLabel", void 0);
    __decorate([
        Prop({ default: 'linear' })
    ], LineChart.prototype, "xAxisScale", void 0);
    __decorate([
        Prop({ default: true })
    ], LineChart.prototype, "forceXAxisMinZero", void 0);
    __decorate([
        Prop({ default: 0 })
    ], LineChart.prototype, "dataPointSize", void 0);
    __decorate([
        Prop({ default: 'line' })
    ], LineChart.prototype, "type", void 0);
    __decorate([
        Prop({ default: function () { return []; } })
    ], LineChart.prototype, "plugins", void 0);
    __decorate([
        Prop({ default: false })
    ], LineChart.prototype, "dragYaxis", void 0);
    __decorate([
        Prop({ default: undefined })
    ], LineChart.prototype, "yScaleMax", void 0);
    __decorate([
        Prop({ default: undefined })
    ], LineChart.prototype, "yScaleMin", void 0);
    __decorate([
        Prop({ default: 0 })
    ], LineChart.prototype, "draggableDataSet", void 0);
    LineChart = LineChart_1 = __decorate([
        Component({
            components: {
                ChartJsWrapper: __vue_component__$6,
            },
        })
    ], LineChart);
    return LineChart;
}(Vue__default["default"]));

/* script */
const __vue_script__$4 = LineChart;

/* template */
var __vue_render__$4 = function () {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("chart-js-wrapper", {
    attrs: {
      data: _vm.chartData,
      type: _vm.type,
      options: _vm.chartOptions,
      plugins: _vm.plugins,
      dragYaxis: _vm.dragYaxis,
      draggableDataSet: _vm.draggableDataSet,
    },
    on: { valueChanged: _vm.valueChanged },
  })
};
var __vue_staticRenderFns__$4 = [];
__vue_render__$4._withStripped = true;

  /* style */
  const __vue_inject_styles__$4 = undefined;
  /* scoped */
  const __vue_scope_id__$4 = undefined;
  /* module identifier */
  const __vue_module_identifier__$4 = undefined;
  /* functional template */
  const __vue_is_functional_template__$4 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$4 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    false,
    undefined,
    undefined,
    undefined
  );

var DistributionChart = /** @class */ (function (_super) {
    __extends(DistributionChart, _super);
    function DistributionChart() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.straightLinesDistTypes = [
            'Triangle',
            'Uniform',
            'LogUniform',
            'UniformLimited',
            'PiecewiseUniform',
            'Histogram',
            'TwoUniform',
            'UniformXDependent',
        ];
        _this.steppedLineDistTypes = ['PiecewiseUniform', 'Histogram'];
        return _this;
    }
    // default properties given for a single data set returned from a distribution sample method
    DistributionChart.prototype.defaultChartProperties = function (seriesIndex, seriesType) {
        return {
            label: '',
            backgroundColor: COLOR_ARRAY_T[seriesIndex],
            borderColor: 'rgba(255, 255, 255, 0)',
            fill: true,
            useStraightLines: this.straightLinesDistTypes.includes(seriesType),
            stepped: this.steppedLineDistTypes.includes(seriesType),
        };
    };
    /* In the case of a distribution sample method returning multiple data sets (e.g. TwoUniform),
        this method is used so that the series backgrounds match, but the subseries have different line colors */
    DistributionChart.prototype.multiSeriesDefaultChartProperties = function (seriesIndex, subSeriesIndex, seriesType) {
        return {
            label: '',
            backgroundColor: COLOR_ARRAY_T[seriesIndex],
            borderColor: PARAM_COLORS[subSeriesIndex],
            fill: true,
            useStraightLines: this.straightLinesDistTypes.includes(seriesType),
            stepped: this.steppedLineDistTypes.includes(seriesType),
        };
    };
    /* For a series object that contains array values for properties, in the case of a sample function
        returning multiple series, this method extracts the property at a given index */
    /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getSingleSeriesProperties"] }] */
    DistributionChart.prototype.getSingleSeriesProperties = function (multiSeriesProperties, index) {
        var series = {};
        if (Array.isArray(multiSeriesProperties)) {
            for (var prop = 0; prop < multiSeriesProperties.length; prop += 1) {
                series[prop] = Array.isArray(multiSeriesProperties[prop])
                    ? multiSeriesProperties[prop][index]
                    : multiSeriesProperties[prop];
            }
        }
        return series;
    };
    Object.defineProperty(DistributionChart.prototype, "distributionData", {
        get: function () {
            var _this = this;
            var distData = [];
            // Construct distribution data objects with sampled data and default chart properties
            // Overwrite any defaults with any defined properties in the series object
            distData = this.distributionSeries.map(function (series, index) {
                // Check if distribution is undefined due to unrecognized type and if all series have a parameters property
                if (!series.IsValid) {
                    _this.validation = {
                        isValid: false,
                        message: "Distribution Chart -- The distribution validator and/or sampler are undefined for series ".concat(index, "."),
                    };
                    return distData;
                }
                _this.validation = {
                    isValid: true,
                };
                var chartData = _this.dataGenerator.PDF(series);
                // If the sample method returns more than one series, then create multiple objects
                if (Array.isArray(chartData[0])) {
                    return chartData.map(function (d, i) {
                        var val = { data: d };
                        Object.assign(val, { pointRadius: 0 }, _this.multiSeriesDefaultChartProperties(index, i, _this.requestedChartType), _this.getSingleSeriesProperties(series, i));
                        return val;
                    });
                }
                var d = { data: chartData }; // just to get by eslint errors
                return Object.assign(d, { pointRadius: 0 }, _this.defaultChartProperties(index, _this.requestedChartType), series);
            });
            return this.validation.isValid ? distData : [];
        },
        enumerable: false,
        configurable: true
    });
    DistributionChart.prototype.onDistributionTypeChanged = function () {
        if (this.$refs.distChart) {
            this.$refs.distChart.resetChart();
        }
    };
    DistributionChart.prototype.onValidationChanged = function (newValid) {
        if (!newValid.isValid) {
            this.$emit('onError', newValid);
        }
    };
    __decorate([
        Prop({ required: true })
    ], DistributionChart.prototype, "distributionSeries", void 0);
    __decorate([
        Prop({
            default: function () { return new dist.DistributionDataGenerator(); },
            type: Object,
        })
    ], DistributionChart.prototype, "dataGenerator", void 0);
    __decorate([
        Prop({ default: 'line' })
    ], DistributionChart.prototype, "requestedChartType", void 0);
    __decorate([
        Prop({ default: '' })
    ], DistributionChart.prototype, "xAxisLabel", void 0);
    __decorate([
        Prop({ default: '' })
    ], DistributionChart.prototype, "yAxisLabel", void 0);
    __decorate([
        Prop({ default: 'linear' })
    ], DistributionChart.prototype, "xAxisScale", void 0);
    __decorate([
        Prop({ default: 'linear' })
    ], DistributionChart.prototype, "yAxisScale", void 0);
    __decorate([
        Prop({ default: true })
    ], DistributionChart.prototype, "forceXAxisMinZero", void 0);
    __decorate([
        Prop({ default: false })
    ], DistributionChart.prototype, "showDataPoints", void 0);
    __decorate([
        Watch('distributionType')
    ], DistributionChart.prototype, "onDistributionTypeChanged", null);
    __decorate([
        Watch('validation')
    ], DistributionChart.prototype, "onValidationChanged", null);
    DistributionChart = __decorate([
        Component({ components: { LineChart: __vue_component__$4 } })
    ], DistributionChart);
    return DistributionChart;
}(Vue__default["default"]));

/* script */
const __vue_script__$3 = DistributionChart;

/* template */
var __vue_render__$3 = function () {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("line-chart", {
    ref: "distChart",
    attrs: {
      "chart-series": _vm.distributionData,
      "x-axis-label": _vm.xAxisLabel,
      "y-axis-label": _vm.yAxisLabel,
      "x-axis-scale": _vm.xAxisScale,
      "y-axis-scale": _vm.yAxisScale,
      "force-x-axis-min-zero": _vm.forceXAxisMinZero,
      "data-point-size": _vm.showDataPoints ? 0 : 12,
    },
  })
};
var __vue_staticRenderFns__$3 = [];
__vue_render__$3._withStripped = true;

  /* style */
  const __vue_inject_styles__$3 = function (inject) {
    if (!inject) return
    inject("data-v-42f78d86_0", { source: "\n#chart[data-v-42f78d86] {\r\n  flex: 1;\r\n  min-height: 300px;\r\n  max-height: 500px;\n}\n#error[data-v-42f78d86] {\r\n  color: red;\r\n  font-size: 1rem;\r\n  font-weight: bold;\r\n  text-align: left;\n}\r\n", map: {"version":3,"sources":["D:\\Repositories\\Common\\Vue\\Charting\\src\\components\\DistributionChart.vue"],"names":[],"mappings":";AAqKA;EACA,OAAA;EACA,iBAAA;EACA,iBAAA;AACA;AAEA;EACA,UAAA;EACA,eAAA;EACA,iBAAA;EACA,gBAAA;AACA","file":"DistributionChart.vue","sourcesContent":["<template>\r\n  <line-chart\r\n    ref=\"distChart\"\r\n    :chart-series=\"distributionData\"\r\n    :x-axis-label=\"xAxisLabel\"\r\n    :y-axis-label=\"yAxisLabel\"\r\n    :x-axis-scale=\"xAxisScale\"\r\n    :y-axis-scale=\"yAxisScale\"\r\n    :force-x-axis-min-zero=\"forceXAxisMinZero\"\r\n    :data-point-size=\"showDataPoints ? 0 : 12\"\r\n  >\r\n  </line-chart>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport Vue, { PropType } from 'vue';\r\nimport { Component, Prop, Watch } from 'vue-property-decorator';\r\nimport Distribution, { DistributionDataGenerator } from 'battelle-common-typescript-statistics';\r\nimport { ChartType } from 'chart.js';\r\nimport LineChart from './LineChart.vue';\r\nimport * as colors from '../assets/colors';\r\nimport { IChartSeries } from '../interfaces/data/IChartSeries';\r\n\r\n@Component({ components: { LineChart } })\r\nexport default class DistributionChart extends Vue {\r\n  @Prop({ required: true }) distributionSeries!: Distribution[];\r\n\r\n  @Prop({\r\n    default: () => new DistributionDataGenerator(),\r\n    type: Object as PropType<DistributionDataGenerator>,\r\n  })\r\n  dataGenerator!: DistributionDataGenerator;\r\n\r\n  @Prop({ default: 'line' }) requestedChartType!: ChartType;\r\n\r\n  @Prop({ default: '' }) xAxisLabel!: string;\r\n\r\n  @Prop({ default: '' }) yAxisLabel!: string;\r\n\r\n  @Prop({ default: 'linear' }) xAxisScale!: string;\r\n\r\n  @Prop({ default: 'linear' }) yAxisScale!: string;\r\n\r\n  @Prop({ default: true }) forceXAxisMinZero!: boolean;\r\n\r\n  @Prop({ default: false }) showDataPoints!: boolean;\r\n\r\n  validation?: any;\r\n\r\n  straightLinesDistTypes = [\r\n    'Triangle',\r\n    'Uniform',\r\n    'LogUniform',\r\n    'UniformLimited',\r\n    'PiecewiseUniform',\r\n    'Histogram',\r\n    'TwoUniform',\r\n    'UniformXDependent',\r\n  ];\r\n\r\n  steppedLineDistTypes = ['PiecewiseUniform', 'Histogram'];\r\n\r\n  // default properties given for a single data set returned from a distribution sample method\r\n  defaultChartProperties(seriesIndex: number, seriesType: ChartType): Partial<IChartSeries> {\r\n    return {\r\n      label: '',\r\n      backgroundColor: colors.COLOR_ARRAY_T[seriesIndex],\r\n      borderColor: 'rgba(255, 255, 255, 0)',\r\n      fill: true,\r\n      useStraightLines: this.straightLinesDistTypes.includes(seriesType),\r\n      stepped: this.steppedLineDistTypes.includes(seriesType),\r\n    };\r\n  }\r\n\r\n  /* In the case of a distribution sample method returning multiple data sets (e.g. TwoUniform),\r\n      this method is used so that the series backgrounds match, but the subseries have different line colors */\r\n  multiSeriesDefaultChartProperties(\r\n    seriesIndex: number,\r\n    subSeriesIndex: number,\r\n    seriesType: ChartType,\r\n  ): Partial<IChartSeries> {\r\n    return {\r\n      label: '',\r\n      backgroundColor: colors.COLOR_ARRAY_T[seriesIndex],\r\n      borderColor: colors.PARAM_COLORS[subSeriesIndex],\r\n      fill: true,\r\n      useStraightLines: this.straightLinesDistTypes.includes(seriesType),\r\n      stepped: this.steppedLineDistTypes.includes(seriesType),\r\n    };\r\n  }\r\n\r\n  /* For a series object that contains array values for properties, in the case of a sample function\r\n      returning multiple series, this method extracts the property at a given index */\r\n  /* eslint class-methods-use-this: [\"error\", { \"exceptMethods\": [\"getSingleSeriesProperties\"] }] */\r\n\r\n  getSingleSeriesProperties(multiSeriesProperties: any, index: number) {\r\n    const series: any = {};\r\n    if (Array.isArray(multiSeriesProperties)) {\r\n      for (let prop = 0; prop < multiSeriesProperties.length; prop += 1) {\r\n        series[prop] = Array.isArray(multiSeriesProperties[prop])\r\n          ? multiSeriesProperties[prop][index]\r\n          : multiSeriesProperties[prop];\r\n      }\r\n    }\r\n    return series;\r\n  }\r\n\r\n  get distributionData(): any {\r\n    let distData: any[] = [];\r\n\r\n    // Construct distribution data objects with sampled data and default chart properties\r\n    // Overwrite any defaults with any defined properties in the series object\r\n    distData = this.distributionSeries.map((series, index) => {\r\n      // Check if distribution is undefined due to unrecognized type and if all series have a parameters property\r\n      if (!series.IsValid) {\r\n        this.validation = {\r\n          isValid: false,\r\n          message: `Distribution Chart -- The distribution validator and/or sampler are undefined for series ${index}.`,\r\n        };\r\n        return distData;\r\n      }\r\n      this.validation = {\r\n        isValid: true,\r\n      };\r\n\r\n      const chartData = this.dataGenerator.PDF(series);\r\n\r\n      // If the sample method returns more than one series, then create multiple objects\r\n      if (Array.isArray(chartData[0])) {\r\n        return chartData.map((d, i) => {\r\n          const val = { data: d };\r\n          Object.assign(\r\n            val,\r\n            { pointRadius: 0 },\r\n            this.multiSeriesDefaultChartProperties(index, i, this.requestedChartType),\r\n            this.getSingleSeriesProperties(series, i),\r\n          );\r\n          return val;\r\n        });\r\n      }\r\n\r\n      const d = { data: chartData }; // just to get by eslint errors\r\n      return Object.assign(d, { pointRadius: 0 }, this.defaultChartProperties(index, this.requestedChartType), series);\r\n    });\r\n\r\n    return this.validation.isValid ? distData : [];\r\n  }\r\n\r\n  @Watch('distributionType')\r\n  onDistributionTypeChanged() {\r\n    if (this.$refs.distChart) {\r\n      (this.$refs.distChart as any).resetChart();\r\n    }\r\n  }\r\n\r\n  @Watch('validation')\r\n  onValidationChanged(newValid: any) {\r\n    if (!newValid.isValid) {\r\n      this.$emit('onError', newValid);\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n#chart {\r\n  flex: 1;\r\n  min-height: 300px;\r\n  max-height: 500px;\r\n}\r\n\r\n#error {\r\n  color: red;\r\n  font-size: 1rem;\r\n  font-weight: bold;\r\n  text-align: left;\r\n}\r\n</style>\r\n"]}, media: undefined });

  };
  /* scoped */
  const __vue_scope_id__$3 = "data-v-42f78d86";
  /* module identifier */
  const __vue_module_identifier__$3 = undefined;
  /* functional template */
  const __vue_is_functional_template__$3 = false;
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$3 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    false,
    createInjector,
    undefined,
    undefined
  );

var BarChart = /** @class */ (function (_super) {
    __extends(BarChart, _super);
    function BarChart() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BarChart.prototype, "chartData", {
        get: function () {
            return {
                labels: this.dataObject.labels,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                datasets: this.dataObject.datasets.map(function (d, i) {
                    return {
                        label: d.label,
                        data: d.data,
                        backgroundColor: d.backgroundColor || COLOR_ARRAY_T[i],
                        borderColor: d.borderColor || COLOR_ARRAY[i],
                        borderWidth: 2,
                    };
                }),
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BarChart.prototype, "chartOptions", {
        get: function () {
            return {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    datalabels: {
                        display: false,
                    },
                    legend: {
                        display: this.displayLegend,
                        labels: {
                            font: {
                                size: this.chartFontSize,
                            },
                            filter: function (item) {
                                return item.text !== undefined && item.text.length > 0;
                            },
                        },
                    },
                    tooltip: {
                        bodyFont: {
                            size: this.chartFontSize,
                        },
                        titleFont: {
                            size: 14,
                        },
                        titleMarginBottom: 10,
                        footerMarginTop: 10,
                        callbacks: {
                            label: function (tooltipItem) {
                                var totalDataPoints = tooltipItem.dataset.data.reduce(function (previousValue, currentValue) { return previousValue + currentValue; });
                                var dataPointsInBin = Number(Number(tooltipItem.formattedValue).toPrecision(3));
                                var percentageInBin = Number(((100 * dataPointsInBin) / totalDataPoints).toPrecision(3));
                                return "".concat(tooltipItem.label || '', " ").concat(dataPointsInBin, " (").concat(percentageInBin, "%)");
                            },
                        },
                    },
                },
                scales: {
                    x: this.xAxisProperties,
                    y: this.yAxisProperties,
                },
                layout: {
                    padding: {
                        left: 15,
                    },
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BarChart.prototype, "xAxisProperties", {
        get: function () {
            return {
                scaleLabel: {
                    labelString: this.xAxisLabel,
                    fontSize: this.chartFontSize + 2,
                    fontStyle: 'bold',
                    display: this.xAxisLabel.length > 0,
                },
                stacked: this.isStacked,
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BarChart.prototype, "yAxisProperties", {
        get: function () {
            return {
                ticks: {
                    fontSize: this.chartFontSize,
                    suggestedMin: 0,
                    callback: function (value) {
                        if ((value < 0.001 && value > 0) || value >= 1e4) {
                            return value.toExponential(1);
                        }
                        return Number(value.toPrecision(3)).toString();
                    },
                },
                scaleLabel: {
                    labelString: this.yAxisLabel,
                    fontSize: this.chartFontSize + 2,
                    fontStyle: 'bold',
                    display: this.yAxisLabel.length > 0,
                },
                stacked: this.isStacked,
            };
        },
        enumerable: false,
        configurable: true
    });
    __decorate([
        Prop({ required: true, validator: function (obj) { return obj.labels !== undefined && obj.datasets !== undefined; } })
    ], BarChart.prototype, "dataObject", void 0);
    __decorate([
        Prop({ default: 'Probability Density' })
    ], BarChart.prototype, "yAxisLabel", void 0);
    __decorate([
        Prop({ default: 'linear' })
    ], BarChart.prototype, "yAxisScale", void 0);
    __decorate([
        Prop({ default: '' })
    ], BarChart.prototype, "xAxisLabel", void 0);
    __decorate([
        Prop({ default: 'linear' })
    ], BarChart.prototype, "xAxisScale", void 0);
    __decorate([
        Prop({ default: 14 })
    ], BarChart.prototype, "chartFontSize", void 0);
    __decorate([
        Prop({ default: true })
    ], BarChart.prototype, "displayLegend", void 0);
    __decorate([
        Prop({ default: false })
    ], BarChart.prototype, "isStacked", void 0);
    BarChart = __decorate([
        Component({
            components: {
                ChartJsWrapper: __vue_component__$6,
            },
        })
    ], BarChart);
    return BarChart;
}(Vue__default["default"]));

/* script */
const __vue_script__$2 = BarChart;

/* template */
var __vue_render__$2 = function () {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("chart-js-wrapper", {
    ref: "chart",
    attrs: {
      type: "bar",
      data: _vm.chartData,
      options: _vm.chartOptions,
      plugins: [],
    },
  })
};
var __vue_staticRenderFns__$2 = [];
__vue_render__$2._withStripped = true;

  /* style */
  const __vue_inject_styles__$2 = function (inject) {
    if (!inject) return
    inject("data-v-2b4bbece_0", { source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", map: {"version":3,"sources":[],"names":[],"mappings":"","file":"BarChart.vue"}, media: undefined });

  };
  /* scoped */
  const __vue_scope_id__$2 = "data-v-2b4bbece";
  /* module identifier */
  const __vue_module_identifier__$2 = undefined;
  /* functional template */
  const __vue_is_functional_template__$2 = false;
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$2 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    false,
    createInjector,
    undefined,
    undefined
  );

var MultiSeriesChart = /** @class */ (function (_super) {
    __extends(MultiSeriesChart, _super);
    function MultiSeriesChart() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiSeriesChart_1 = MultiSeriesChart;
    Object.defineProperty(MultiSeriesChart.prototype, "dataPointSize", {
        get: function () {
            return this.showDataPoints ? 8 : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiSeriesChart.prototype, "dataSeries", {
        get: function () {
            var series = [];
            series.push(__assign({ data: this.baseline }, MultiSeriesChart_1.multiSeriesDefaultChartProperties(0)));
            series.push(__assign({ data: this.current }, MultiSeriesChart_1.multiSeriesDefaultChartProperties(1)));
            return series;
        },
        enumerable: false,
        configurable: true
    });
    /* In the case of a distribution sample method returning multiple data sets (e.g. TwoUniform),
        this method is used so that the series backgrounds match, but the subseries have different line colors */
    MultiSeriesChart.multiSeriesDefaultChartProperties = function (seriesIndex) {
        return {
            label: '',
            backgroundColor: COLOR_ARRAY_T[seriesIndex],
            borderColor: COLOR_ARRAY_T[seriesIndex],
            fill: 'shape',
            pointRadius: 3,
            useStraightLines: true,
            stepped: false,
        };
    };
    MultiSeriesChart.prototype.valueChanged = function (index, datasetIndex, chart) {
        this.$emit('valueChanged', index, datasetIndex, chart);
    };
    var MultiSeriesChart_1;
    __decorate([
        Prop({ required: true })
    ], MultiSeriesChart.prototype, "baseline", void 0);
    __decorate([
        Prop({ required: true })
    ], MultiSeriesChart.prototype, "current", void 0);
    __decorate([
        Prop({ default: 'line' })
    ], MultiSeriesChart.prototype, "requestedChartType", void 0);
    __decorate([
        Prop({ default: '' })
    ], MultiSeriesChart.prototype, "xAxisLabel", void 0);
    __decorate([
        Prop({ default: '' })
    ], MultiSeriesChart.prototype, "yAxisLabel", void 0);
    __decorate([
        Prop({ default: 'linear' })
    ], MultiSeriesChart.prototype, "xAxisScale", void 0);
    __decorate([
        Prop({ default: 'linear' })
    ], MultiSeriesChart.prototype, "yAxisScale", void 0);
    __decorate([
        Prop({ default: undefined })
    ], MultiSeriesChart.prototype, "yScaleMax", void 0);
    __decorate([
        Prop({ default: undefined })
    ], MultiSeriesChart.prototype, "yScaleMin", void 0);
    __decorate([
        Prop({ default: -1 })
    ], MultiSeriesChart.prototype, "draggableDataSet", void 0);
    __decorate([
        Prop({ default: true })
    ], MultiSeriesChart.prototype, "forceXAxisMinZero", void 0);
    __decorate([
        Prop({ default: true })
    ], MultiSeriesChart.prototype, "showDataPoints", void 0);
    __decorate([
        Prop({ default: true })
    ], MultiSeriesChart.prototype, "dragYaxis", void 0);
    MultiSeriesChart = MultiSeriesChart_1 = __decorate([
        Component({ components: { LineChart: __vue_component__$4 } })
    ], MultiSeriesChart);
    return MultiSeriesChart;
}(Vue__default["default"]));

/* script */
const __vue_script__$1 = MultiSeriesChart;

/* template */
var __vue_render__$1 = function () {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("line-chart", {
    ref: "distChart",
    attrs: {
      "chart-series": _vm.dataSeries,
      "x-axis-label": _vm.xAxisLabel,
      "y-axis-label": _vm.yAxisLabel,
      "x-axis-scale": _vm.xAxisScale,
      "y-axis-scale": _vm.yAxisScale,
      dragYaxis: _vm.dragYaxis,
      draggableDataSet: _vm.draggableDataSet,
      yScaleMax: _vm.yScaleMax,
      yScaleMin: _vm.yScaleMin,
      "force-x-axis-min-zero": _vm.forceXAxisMinZero,
      "data-point-size": _vm.dataPointSize,
    },
    on: { valueChanged: _vm.valueChanged },
  })
};
var __vue_staticRenderFns__$1 = [];
__vue_render__$1._withStripped = true;

  /* style */
  const __vue_inject_styles__$1 = function (inject) {
    if (!inject) return
    inject("data-v-e57ae266_0", { source: "\n#chart[data-v-e57ae266] {\r\n  flex: 1;\r\n  min-height: 300px;\r\n  max-height: 500px;\n}\n#error[data-v-e57ae266] {\r\n  color: red;\r\n  font-size: 1rem;\r\n  font-weight: bold;\r\n  text-align: left;\n}\r\n", map: {"version":3,"sources":["D:\\Repositories\\Common\\Vue\\Charting\\src\\components\\MultiSeriesChart.vue"],"names":[],"mappings":";AAgGA;EACA,OAAA;EACA,iBAAA;EACA,iBAAA;AACA;AAEA;EACA,UAAA;EACA,eAAA;EACA,iBAAA;EACA,gBAAA;AACA","file":"MultiSeriesChart.vue","sourcesContent":["<template>\r\n  <line-chart\r\n    ref=\"distChart\"\r\n    :chart-series=\"dataSeries\"\r\n    :x-axis-label=\"xAxisLabel\"\r\n    :y-axis-label=\"yAxisLabel\"\r\n    :x-axis-scale=\"xAxisScale\"\r\n    :y-axis-scale=\"yAxisScale\"\r\n    :dragYaxis=\"dragYaxis\"\r\n    :draggableDataSet=\"draggableDataSet\"\r\n    :yScaleMax=\"yScaleMax\"\r\n    :yScaleMin=\"yScaleMin\"\r\n    :force-x-axis-min-zero=\"forceXAxisMinZero\"\r\n    :data-point-size=\"dataPointSize\"\r\n    @valueChanged=\"valueChanged\"\r\n  />\r\n</template>\r\n\r\n<script lang=\"ts\">\r\n// eslint-disable-next-line import/no-unresolved, import/extensions\r\nimport { Vue, Component, Prop } from 'vue-property-decorator';\r\nimport { ChartType } from 'chart.js';\r\nimport { IChartSeries } from '../interfaces/data/IChartSeries';\r\nimport { IChartPoint } from '../interfaces/data/IChartPoint';\r\nimport LineChart from './LineChart.vue';\r\nimport * as Colors from '../assets/colors';\r\n\r\n@Component({ components: { LineChart } })\r\nexport default class MultiSeriesChart extends Vue {\r\n  @Prop({ required: true })\r\n  baseline!: IChartPoint[];\r\n\r\n  @Prop({ required: true })\r\n  current!: IChartPoint[];\r\n\r\n  @Prop({ default: 'line' }) requestedChartType!: ChartType;\r\n\r\n  @Prop({ default: '' }) xAxisLabel!: string;\r\n\r\n  @Prop({ default: '' }) yAxisLabel!: string;\r\n\r\n  @Prop({ default: 'linear' }) xAxisScale!: string;\r\n\r\n  @Prop({ default: 'linear' }) yAxisScale!: string;\r\n\r\n  @Prop({ default: undefined }) yScaleMax!: number;\r\n\r\n  @Prop({ default: undefined }) yScaleMin!: number;\r\n\r\n  @Prop({ default: -1 }) draggableDataSet!: number;\r\n\r\n  @Prop({ default: true }) forceXAxisMinZero!: boolean;\r\n\r\n  @Prop({ default: true }) showDataPoints!: boolean;\r\n\r\n  @Prop({ default: true }) dragYaxis!: boolean;\r\n\r\n  get dataPointSize(): number {\r\n    return this.showDataPoints ? 8 : 0;\r\n  }\r\n\r\n  get dataSeries(): IChartSeries[] {\r\n    const series: IChartSeries[] = [];\r\n    series.push({\r\n      data: this.baseline,\r\n      ...MultiSeriesChart.multiSeriesDefaultChartProperties(0),\r\n    } as IChartSeries);\r\n    series.push({\r\n      data: this.current,\r\n      ...MultiSeriesChart.multiSeriesDefaultChartProperties(1),\r\n    } as IChartSeries);\r\n\r\n    return series;\r\n  }\r\n\r\n  /* In the case of a distribution sample method returning multiple data sets (e.g. TwoUniform),\r\n      this method is used so that the series backgrounds match, but the subseries have different line colors */\r\n  static multiSeriesDefaultChartProperties(seriesIndex: number): Record<string, unknown> {\r\n    return {\r\n      label: '',\r\n      backgroundColor: Colors.COLOR_ARRAY_T[seriesIndex],\r\n      borderColor: Colors.COLOR_ARRAY_T[seriesIndex],\r\n      fill: 'shape',\r\n      pointRadius: 3,\r\n      useStraightLines: true,\r\n      stepped: false,\r\n    };\r\n  }\r\n\r\n  valueChanged(index: number, datasetIndex: number, chart: Chart): void {\r\n    this.$emit('valueChanged', index, datasetIndex, chart);\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n#chart {\r\n  flex: 1;\r\n  min-height: 300px;\r\n  max-height: 500px;\r\n}\r\n\r\n#error {\r\n  color: red;\r\n  font-size: 1rem;\r\n  font-weight: bold;\r\n  text-align: left;\r\n}\r\n</style>\r\n"]}, media: undefined });

  };
  /* scoped */
  const __vue_scope_id__$1 = "data-v-e57ae266";
  /* module identifier */
  const __vue_module_identifier__$1 = undefined;
  /* functional template */
  const __vue_is_functional_template__$1 = false;
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$1 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    false,
    createInjector,
    undefined,
    undefined
  );

var UniformXDependentChart = /** @class */ (function (_super) {
    __extends(UniformXDependentChart, _super);
    function UniformXDependentChart() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.sliderValue = 1;
        return _this;
    }
    UniformXDependentChart_1 = UniformXDependentChart;
    Object.defineProperty(UniformXDependentChart.prototype, "dataPointSize", {
        get: function () {
            return this.showDataPoints ? 3 : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UniformXDependentChart.prototype, "dataSeries", {
        get: function () {
            var series = [];
            this.data.forEach(function (p, s) {
                p.map(function (data) {
                    return __assign({ data: data }, UniformXDependentChart_1.multiSeriesDefaultChartProperties(s));
                }).forEach(function (d) {
                    series.push(d);
                });
            });
            return series;
        },
        enumerable: false,
        configurable: true
    });
    /* In the case of a distribution sample method returning multiple data sets (e.g. TwoUniform),
        this method is used so that the series backgrounds match, but the subseries have different line colors */
    UniformXDependentChart.multiSeriesDefaultChartProperties = function (seriesIndex) {
        return {
            label: '',
            backgroundColor: COLOR_ARRAY_T[seriesIndex],
            borderColor: COLOR_ARRAY_T[seriesIndex],
            fill: 'shape',
            pointRadius: 0,
            useStraightLines: true,
            stepped: false,
        };
    };
    var UniformXDependentChart_1;
    __decorate([
        Prop({ required: true })
    ], UniformXDependentChart.prototype, "data", void 0);
    __decorate([
        Prop({ default: 'line' })
    ], UniformXDependentChart.prototype, "requestedChartType", void 0);
    __decorate([
        Prop({ default: '' })
    ], UniformXDependentChart.prototype, "xAxisLabel", void 0);
    __decorate([
        Prop({ default: '' })
    ], UniformXDependentChart.prototype, "yAxisLabel", void 0);
    __decorate([
        Prop({ default: 'linear' })
    ], UniformXDependentChart.prototype, "xAxisScale", void 0);
    __decorate([
        Prop({ default: 'linear' })
    ], UniformXDependentChart.prototype, "yAxisScale", void 0);
    __decorate([
        Prop({ default: true })
    ], UniformXDependentChart.prototype, "forceXAxisMinZero", void 0);
    __decorate([
        Prop({ default: false })
    ], UniformXDependentChart.prototype, "showDataPoints", void 0);
    UniformXDependentChart = UniformXDependentChart_1 = __decorate([
        Component({ components: { LineChart: __vue_component__$4 } })
    ], UniformXDependentChart);
    return UniformXDependentChart;
}(Vue__default["default"]));

/* script */
const __vue_script__ = UniformXDependentChart;

/* template */
var __vue_render__ = function () {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("line-chart", {
    ref: "distChart",
    attrs: {
      "chart-series": _vm.dataSeries,
      "x-axis-label": _vm.xAxisLabel,
      "y-axis-label": _vm.yAxisLabel,
      "x-axis-scale": _vm.xAxisScale,
      "y-axis-scale": _vm.yAxisScale,
      "force-x-axis-min-zero": _vm.forceXAxisMinZero,
      "data-point-size": _vm.dataPointSize,
    },
  })
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  const __vue_inject_styles__ = function (inject) {
    if (!inject) return
    inject("data-v-dab278aa_0", { source: "\n#chart[data-v-dab278aa] {\r\n  flex: 1;\r\n  min-height: 300px;\r\n  max-height: 500px;\n}\n#error[data-v-dab278aa] {\r\n  color: red;\r\n  font-size: 1rem;\r\n  font-weight: bold;\r\n  text-align: left;\n}\r\n", map: {"version":3,"sources":["D:\\Repositories\\Common\\Vue\\Charting\\src\\components\\UniformXDependentChart.vue"],"names":[],"mappings":";AA+EA;EACA,OAAA;EACA,iBAAA;EACA,iBAAA;AACA;AAEA;EACA,UAAA;EACA,eAAA;EACA,iBAAA;EACA,gBAAA;AACA","file":"UniformXDependentChart.vue","sourcesContent":["<template>\r\n  <line-chart\r\n    ref=\"distChart\"\r\n    :chart-series=\"dataSeries\"\r\n    :x-axis-label=\"xAxisLabel\"\r\n    :y-axis-label=\"yAxisLabel\"\r\n    :x-axis-scale=\"xAxisScale\"\r\n    :y-axis-scale=\"yAxisScale\"\r\n    :force-x-axis-min-zero=\"forceXAxisMinZero\"\r\n    :data-point-size=\"dataPointSize\"\r\n  />\r\n</template>\r\n\r\n<script lang=\"ts\">\r\n// eslint-disable-next-line import/no-unresolved, import/extensions\r\nimport { Vue, Component, Prop } from 'vue-property-decorator';\r\nimport { ChartType } from 'chart.js';\r\nimport { IChartSeries } from '../interfaces/data/IChartSeries';\r\nimport { IChartPoint } from '../interfaces/data/IChartPoint';\r\nimport LineChart from './LineChart.vue';\r\nimport * as Colors from '../assets/colors';\r\n\r\n@Component({ components: { LineChart } })\r\nexport default class UniformXDependentChart extends Vue {\r\n  @Prop({ required: true })\r\n  data!: IChartPoint[][][];\r\n\r\n  @Prop({ default: 'line' }) requestedChartType!: ChartType;\r\n\r\n  @Prop({ default: '' }) xAxisLabel!: string;\r\n\r\n  @Prop({ default: '' }) yAxisLabel!: string;\r\n\r\n  @Prop({ default: 'linear' }) xAxisScale!: string;\r\n\r\n  @Prop({ default: 'linear' }) yAxisScale!: string;\r\n\r\n  @Prop({ default: true }) forceXAxisMinZero!: boolean;\r\n\r\n  @Prop({ default: false }) showDataPoints!: boolean;\r\n\r\n  sliderValue = 1;\r\n\r\n  get dataPointSize(): number {\r\n    return this.showDataPoints ? 3 : 0;\r\n  }\r\n\r\n  get dataSeries(): IChartSeries[] {\r\n    const series: IChartSeries[] = [];\r\n    this.data.forEach((p, s) => {\r\n      p.map((data) => {\r\n        return {\r\n          data,\r\n          ...UniformXDependentChart.multiSeriesDefaultChartProperties(s),\r\n        } as IChartSeries;\r\n      }).forEach((d) => {\r\n        series.push(d);\r\n      });\r\n    });\r\n    return series;\r\n  }\r\n\r\n  /* In the case of a distribution sample method returning multiple data sets (e.g. TwoUniform),\r\n      this method is used so that the series backgrounds match, but the subseries have different line colors */\r\n  static multiSeriesDefaultChartProperties(seriesIndex: number): Record<string, unknown> {\r\n    return {\r\n      label: '',\r\n      backgroundColor: Colors.COLOR_ARRAY_T[seriesIndex],\r\n      borderColor: Colors.COLOR_ARRAY_T[seriesIndex],\r\n      fill: 'shape',\r\n      pointRadius: 0,\r\n      useStraightLines: true,\r\n      stepped: false,\r\n    };\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n#chart {\r\n  flex: 1;\r\n  min-height: 300px;\r\n  max-height: 500px;\r\n}\r\n\r\n#error {\r\n  color: red;\r\n  font-size: 1rem;\r\n  font-weight: bold;\r\n  text-align: left;\r\n}\r\n</style>\r\n"]}, media: undefined });

  };
  /* scoped */
  const __vue_scope_id__ = "data-v-dab278aa";
  /* module identifier */
  const __vue_module_identifier__ = undefined;
  /* functional template */
  const __vue_is_functional_template__ = false;
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__ = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    false,
    createInjector,
    undefined,
    undefined
  );

Chart.register.apply(Chart, __spreadArray(__spreadArray([], registerables, false), [plugin$1, plugin], false));

exports.BarChart = __vue_component__$2;
exports.ChartJsWrapper = __vue_component__$6;
exports.ChartTitleDefaultSettings = ChartTitleDefaultSettings;
exports.ChartTooltipOptionsDefaultSettings = ChartTooltipOptionsDefaultSettings;
exports.Colors = colors;
exports.ConstantPointStyleProvider = ConstantPointStyleProvider;
exports.CreateDefaultChartOptions = CreateDefaultChartOptions;
exports.CreateDefaultChartPointOptions = CreateDefaultChartPointOptions;
exports.CreateDefaultTitleOptions = CreateDefaultTitleOptions;
exports.CreateDefaultTooltipOptions = CreateDefaultTooltipOptions;
exports.CreateScatterChartDataset = CreateScatterChartDataset;
exports.CycleColorProvider = CycleColorProvider;
exports.CyclePointStyleProvider = CyclePointStyleProvider;
exports.DefaultChartData = DefaultChartData;
exports.DistributionChart = __vue_component__$3;
exports.EmptyChartData = EmptyChartData;
exports.EmptyChartOptions = EmptyChartOptions;
exports.LineChart = __vue_component__$4;
exports.MultiSeriesChart = __vue_component__$1;
exports.PointStyleType = PointStyleType$1;
exports.ScatterChartDatasetDefaultSettings = ScatterChartDatasetDefaultSettings;
exports.ScatterPlotWrapper = __vue_component__$5;
exports.UniformXDependentChart = __vue_component__;
//# sourceMappingURL=index.js.map
